{"./":{"url":"./","title":"Introduction","keywords":"","body":"Web 前端架构师课 - 作业打卡 浅层学习看输入，深入学习看输出 汇总所有同学的：学习打卡，作业，学习笔记，分享 精选文章 week1 需求和架构设计 【郭二蛋】第一周笔记和作业 【点点】需求分析和架构设计 【彩笔】架构方案设计文档 【yhtx1997】第一周作业 week2 脚手架架构设计和框架搭建 【郭二蛋】第二周笔记和作业 【彩笔】脚手架架构设计和框架搭建 【Berners】第二周笔记和作业 【い狂奔的蜗牛】01.Node.js中经典算法（一） 【yhtx1997】02-第二周作业 week3 脚手架核心流程开发 【郭二蛋】03-第三周学习笔记 【い狂奔的蜗牛】02.Node.js中使用ES Module的两种方式 【彩笔】作业-03-脚手架核心流程开发 week4 脚手架命令注册和执行过程开发 【彩笔】作业-04-脚手架命令注册和执行过程开发 【い狂奔的蜗牛】03.sim-cli核心图集 【い狂奔的蜗牛】04.Node.js多进程源码分析 week5 脚手架创建项目流程设计和开发 【い狂奔的蜗牛】08.第五周-类似inquirer列表类型交互实现 查看其他同学的作业和笔记 页面左侧目录，就是所有同学的作业和学习笔记。 提交你的作业和笔记 注意，以下操作需要你了解 github 的 fork 和 pull request 机制。这也是多人协作开发所必备的技能。 fork 源码 进入 https://github.com/imooc-lego/students-learn-task ，fork 项目到自己的 github 空间。 然后下载项目到本地，安装并启动。 cd students-learn-task npm i npm run dev # 访问 localhost:4000 写博客 作业、笔记，都可以用博客的形式。注意，全程使用 markdown 语法，不懂的自己去查。 新建 docs/pages// 目录 ， 即你在慕课网的用户名（或昵称、网名，都可以） 新建 docs/pages//README.md ，内容参考现有的 docs/pages/双越老师/README.md 在 docs/pages// 下新建博客文件，命名格式按照 01-xxx.md 02-yyy.md 03-zzz.md ... 一定以序号 01- 02- 开头！！ 如果需要图片，可把图片文件放在 docs/pages//images/ 中，然后在博客中引入 删掉 docs/SUMMARY.md 你在本地执行 npm run dev 或 npm run build 都会自动生成 docs/SUMMARY.md 。 检查一下，如果你的代码中有 docs/SUMMARY.md 这个文件，请删除掉它。\\ 否则，可能会和别人产生冲突，请一定注意检查！！！ 最后，提交代码到 github 。 提交 pull request 从你 fork 的仓库，提交 pull request 到 https://github.com/imooc-lego/students-learn-task ，请求合并到 main 分支 确定 https://github.com/imooc-lego/students-learn-task 有你提交的 pull request 等待讲师处理（一般会在 24h 之内处理：合并或者回复），注意看 github 的通知 自动发布 pull request 被合并之后，会触发 github actions ，自动打包、发布到 http://homework.imooc-lego.com/ 。 过程大概 3-5 分钟。 重点提醒 第一次，记得新建 docs/pages//README.md 文件 图片文件都放在 docs/pages//images/ 目录中 提交时记得删掉 docs/SUMMARY.md 文件，否则容易产生冲突 Pull request 提交成功之后，自己再检查一下：看是否有冲突？看 Files changed 是否符合预期？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Abaddon/":{"url":"pages/Abaddon/","title":"Abaddon","keywords":"","body":"Abaddon - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Abaddon/01-week01 需求分析与架构设计.html":{"url":"pages/Abaddon/01-week01 需求分析与架构设计.html","title":"Week01 需求分析与架构设计","keywords":"","body":"架构师与业务需求 架构师必须深入理解需求，以架构师的角度分析需求，须有全局思维、整体思维、闭环思维。 在此基础上确定需求范围，设计核心数据结构。 ![](./images/1.png) 产出 编写《整体技术方案设计》 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Baran/":{"url":"pages/Baran/","title":"Baran","keywords":"","body":"Baran - 作业 浅层学习看输入，深层学习看输出&#x1F4AA;&#x1F4AA;&#x1F4AA; 第一周 01-需求分析和架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Baran/01-需求分析和架构设计.html":{"url":"pages/Baran/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析和架构设计 第3章 需求分析 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Berners/":{"url":"pages/Berners/","title":"Berners","keywords":"","body":"高俊峰 - 学习分享 第一周笔记 第二周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Berners/01-第一周笔记和作业.html":{"url":"pages/Berners/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"需求设计 脱离业务的架构就是耍流氓，架构师必须要深入理解需求，参与需求，看透需求背后的业务本质。 主要产出 熟悉产品需求 学会以架构师的思维分析需求 全局思维，整体思维，闭环思维 主要内容 如何以架构师思维分析需求 项目的浅层需求 项目的深度需求 需求总揽 业务模块设计 ![Image text](./images/架构设计.png) 扩展性保证 数据结构层面 一些可能的整体项目级别配置项。主要是是否可编辑，是否锁定等等。 一些页面级别的配置参数，大小，背景色之类的。 编辑器层面 保证组件的可扩展性，组件的锁定，可选，图层等等后续必要的扩展功能。 开发提效 脚手架固化一些重复操作，规范流程，提高开发效率。 创建项目的流程 提交代码的流程 测试项目的流程 打包项目的流程 发布项目的流程 组件平台主要固化组件的开发和发布流程，提升组件开发效率。 运维保障（待补充），大中型企业自研 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 架构师职责：项目设计，模块，逻辑抽象，正在是解决业务问题，梳理业务。通过技术手段实现业务增长，用架构设计模拟业务。 架构师核心思想 通过技术手段，来保证业务的增长。对业务负责，需 要对需求精准深入的理解。 要坚信：技术永远都是为业务服务的，技术是实现业务增长的工具。 学习方法 要有耐心，不要一心想着写代码，觉得需求和设计不重要 抛开你固有的程序员思维，开始准备接受架构师思维 要坚信：技术永远都是为业务服务的，技术是实现业务增长的工具 注意事项 不要关注细节，要看整体，看范围 设计时判断可行性，不确定的就调研一下，（这需要大量的工作经验积累，技术能力） 设计要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Berners/02-第二周笔记和作业.html":{"url":"pages/Berners/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"脚手架架构设计和框架搭建 参考： https://www.imooc.com/wiki/weban/w2c2.html 标题 脚手架框架设计和框架搭建 收获 脚手架实现原理 lerna的常见用法 架构设计机器和架构图绘制方法 主要内容 学习如何以架构师的角度思考基础架构问题 多package项目管理痛点和解决方案，居于lerna脚手架框架搭建 imooc-cli脚手架需求分析和架构设计，架构设计图 附赠内容 脚手架调试技巧 lerna源码分析 node的module模块分析 yargs使用方法 剖析lerna架构设计 关键词 脚手架-掌握脚手架原理和开发流程 lerna-解决多package项目管理痛点 架构设计-学习大厂基础架构设计思路 学习方法 架构三部曲：掌握原理 -> 独立思考 -> 总结反思 深度剖析优秀开源项目，由表及里，由深入浅 视角切换，多切换到架构师视角，从全局思考问题 站在前端研发的视角，分析开发脚手架的必要性 研发效能：提升前端研发效能 脚手架核心价值 将研发过程： 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化，数据化，使的研发过程可量化 脚手架的实现原理(window系统) 1.为什么全局安装 @vue/cli 后台添加的命令为 vue？ npm install -g @vue/cli 查看安装目录 1.1 操作系统注册 vue 命令 在 C:\\Program Files\\nodejs 目录下的 vue 文件中注册 vue 命令到环境变量 直接执行 C:/Users/IG_G005/AppData/Roaming/nvm/v11.15.0/vue 文件命令和 vue 命令是等价的 执行vue命令会在环境变量中找到 vue 命令是否被注册 vue 命令通过 软链接 在指向 C:\\Users\\IG_G005\\AppData\\Roaming\\nvm\\v11.15.0\\node_modules\\@vue\\cli\\bin\\vue.js 这个文件 1.2 为什么 C:\\Users\\IG_G005\\AppData\\Roaming\\nvm\\v11.15.0\\node_modules\\@vue\\cli\\bin\\vue.js 文件可以被node解析器执行 #!/usr/bin/env node 主要是这个句话，声明使用node环境执行该脚本文件 2.全局安装 @vue/cli 时发生了什么 在node安装目录的主目录， bin目录下创建一个软链接，软链接指向的是bin目录指向的实际文件 脚手架的实现原理(mac系统) 1.为什么全局安装 @vue/cli 后会添加的命令为 vue ？ which vue gaojunfengdembp:students-learn-task gaojunfeng$ which vue /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue 该文件是一个可执行文件，是一个软链接（node环境下的全局命令） gaojunfengdembp:bin gaojunfeng$ ls node npm npx nrm vue 目录下 vue文件是个软链接，指向 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js 文件 在执行 vue 命令时，其实就是在执行 指向的文件 那 vue 命令，即软链接的名称，是在 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/package.json 文件中，配置的 vue 命令，执行命令时 指向 bin/vue.js 文件 { ... \"bin\": { \"vue\": \"bin/vue.js\" // 在这里通过key配置，决定名称，绑定 bin 目录下的 vue.js 文件 }, ... } 2.全局安装 @vue/cli 时发生了什么？ 当我们在全局安装了 @vue/cli 模块，会下载到 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules 目录中， 当包下载完成后，会自动解析 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/package.json 文件， 读取文件中 \"bin\" 这个配置，发现 bin 下面有 vue 字符的这样一个配置，会在 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin 目录下创建一个软链接 vue，软链接又指向 bin 对应的文件，即（/Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js）文件 vue(软链接) -> /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js(原始文件) /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue(目录软链接) -> /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js(原始文件) 3.执行 vue 命令时发生了什么？ 首先执行 which vue which vue /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue 返回一个软链接 执行该软链接 和 执行 vue 命令时等价的，该软链接上面讲了，又指向的是vue.js文件，看上面的说明 为什么 vue 指向一个 js 文件，我们却可以通过 vue 命令去执行它？ 查看 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js 文件代码 1.主要是 #!/usr/bin/env node 这句话，添加了执行该文件的环境变量。 表示当执行当前文件时，会到操作系统环境变量找 node 这个命令，找到以后通过 node 命令执行对应的文件。 直接执行 /usr/bin/env node 命令和直接执行 node 命令是一样的。 2.怎么创建软链接(node环境下的全局命令) 创建 imooc 命令 在/Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/目录下，通过 ln -s /xxx/xxx.js imooc 创建一个软链接，指向js文件 区别 #!/usr/bin/env node #!/usr/bin/node 第一种是在环境变量种找 node 第二种是直接执行 /usr/bin/ 目录下的 node 脚手架原理进阶 1.为什么数脚手架的本质是操作系统的客户端？它和我们PC上安装的应用/软件有什么区别？ 脚手架是操作系统上的一个客户端，脚手架执行依赖node，node又是操作系统上的客户端。和其他应用本质上没有区别 2.如何为 node 脚手架创建别名 通过创建软连接，连接到我们自己编写的代码文件上。 创建软链接语法： ln -s 指向的文件路径 软连接名称 例子：ln -s /xxx/xxx.js imooc 3.描述脚手架命令的全过程 脚手架开发流程 脚手架开发流程详解 开发流程 1.创建 npm 项目 2.创建脚手架入口文件，最上方添加 #!/usr/bin/env node 3.配置 package.json，添加 bin 属性 4.编写脚手架代码 5.讲脚手架发布到npm仓库 使用流程 1.安装脚手架 npm install -g your-own-cli 2.使用脚手架 your-own-cli 脚手架开发难点解析 1.分包：将复杂的系统拆分成若干个模块 2.命令注册 vue create vue add vue invoke 3.参数解析 vue command [options] command主命令: 如 create, add, invoke options参数全称: --version, --help options参数简称: -V, -h 带 params 的 options: --path /Users/sam/Desktop/vue-test 帮助文档： global help Usage Options Commands 如 vue 的帮助文档 command help Usage Options vue create 的帮助信息： 还有其他 1.命令行交互 2.日志打印 ... lerna 开发脚手架流程（划重点） 一：脚手架项目初始化 1.初始化npm项目 -> 安装lerna -> lerna init 初始化项目 二：创建 package 1.lerna create创建Package -> lerna add 安装依赖 -> lerna link 链接依赖 三：脚手架开发和测试 lerna exec执行shell脚本 lerna run 执行 npm 命令 lerna clean 清空依赖 lerna boosttrap 重装依赖 四：脚手架发布上线 lerna version bump version lerna changed查看上版本依赖的所有变更 lerna diff 查看diff lerna publish项目发布 lerna 源码阅读 准备工作 1.下载源码 2.安装依赖 2.IDE打开 源码阅读准备完成的标准（划重点） 1.找到入口文件 2.能够本地调试 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Berners/03-第三周笔记和作业.html":{"url":"pages/Berners/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"核心图 直接上代码吧 https://github.com/duanshanghanqing/imooc-test-berners https://github.com/duanshanghanqing/berners-cli 本周作业完成情况 绘制脚手架架构设计图（已完成） 实现脚手架准备过程代码（已完成） 通过 commander 实现一个脚手架，包含自定义 option 和 command 功能：imooc-test-berners（已完成） 通过 webpack 和原生两种方式实现 Node 对 ES Module 的支持（已完成） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Beyond/":{"url":"pages/Beyond/","title":"Beyond","keywords":"","body":"目标只有一个：大厂 大厂 大厂！！！ Week01 Week01-作业-整体架构设计 V1.0 Week02 Week03 Week04 Week05 Week06 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Beyond/01-week01-作业.html":{"url":"pages/Beyond/01-week01-作业.html","title":"Week01 作业","keywords":"","body":"技术方案设计文档 需求背景 慕课乐高 - UI设计和需求 范围 从需求来看，范围包括这几个方面 B端和编辑器 biz-editor-FE biz-editor-server C端 H5（从性能的角度考虑做SSR） 管理后台，做前端分析 admin-FE admin-server 独立的组件库 npm包的形式，供编辑器端和H5端使用； 统计服务 模块设计 核心数据结构设计 基本思路： 每个组件尽量符合vnode规范 用数组来组织数据（有序） 尽量使用引用关系，不用冗余 { 'project one': { title: '', setting: {/*可能需要的配置项*/}, props: {/*页面body的一些设置*/}, components: [ { id: 'xxx1', name: 'xxx1', tag: 'image', attrs: { fontSize: '14px' }, children: [] }, { id: 'xxx2', name: 'xxx2', tag: 'text', attrs: { fontSize: '14px' }, children: null }, ] } //当前选中的组件id activeComponentId: 'xxx' } 扩展性保证 扩展组件 扩展编辑功能，如锁定，隐藏等 扩展页面信息，如增加多语言或者主题色 扩展其他功能，如大数据分析等 研发提效 脚手架：创建/发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Daiyan/":{"url":"pages/Daiyan/","title":"Daiyan","keywords":"","body":"Daiyan 的课程笔记与作业 第一周 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Daiyan/01-week01-整体架构设计.html":{"url":"pages/Daiyan/01-week01-整体架构设计.html","title":"Week01 整体架构设计","keywords":"","body":"整体架构设计V1.0 需求 需求链接 范围 整体设计、模块设计、核心数据结构 模块设计 组件库将独立出来同时服务于 作品管理 和 作品H5页面 统计服务需要进行自研，因为市面上的不是太贵就是不合适 作品的数据结构设计 使用 vNode 描述作品 预留部分字段以保证拓展性 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 尽量避免污染/冗余源数据，使用 getter 返回计算属性 { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证（待补充） 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面配置，如增加多语言、设置背景 扩展其他功能，如大数据分析和计算等 开发提效（待补充） 脚手架：创建发布 组件平台 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大时，基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Daiyan/02-week02-脚手架基础.html":{"url":"pages/Daiyan/02-week02-脚手架基础.html","title":"Week02 脚手架基础","keywords":"","body":"脚手架基础 脚手架创建 创建文件夹 mkdir dai-cli && cd dai-cli 初始化项目 npm init -y 创建并写入文件，注意需要配置下node路径 mkdir bin && echo -e \"#\"\\!\"/usr/bin/env node\\n\\nconsole.log('hello world')\" > bin/index.js 修改 package.json { \"name\": \"dai-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", // 添加bin配置 \"bin\": { \"dai-cli\": \"bin/index.js\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } 进行软链接 npm link && dai-cli #hello world 多库 如脚手架创建一样 在dai-cli 的同级目录下创建一个库dai-cli-lib，但我们把 bin 改名为 lib 同时将 index.js 暴露出一个函数 #!/usr/bin/env node module.exports = { sum(a, b) { return a + b } } 回到 dai-cli 目录下，执行 npm link dai-cli-lib 修改 dai-cli/bin/index.js #!/usr/bin/env node const { sum } = require('dai-cli-lib') console.log('hello world') console.log(sum(1,3)) 执行 dai-cli dai-cli #hello world 4 Lerna基础 文档地址： https://github.com/lerna/lerna#readme lerna的优点： 批量执行操作 管理依赖 减少重复操作 注意事项 在 npm 创建 group 避免包名重复 如果使用 group 时，publish 需在package.json设置 // package.json \"publishConfig\": { \"access\": \"public\" } 需要 git push 之后再 publish Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Devil/":{"url":"pages/Devil/","title":"Devil","keywords":"","body":"Devil - 课程分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Devil/01-week1-需求分析.html":{"url":"pages/Devil/01-week1-需求分析.html","title":"Week1 需求分析","keywords":"","body":"需求分析 如何进行分析 以架构师的思维分析需求，不能只停留在表面实现需求，要考虑怎么实现能给业务带来增长 全局思维、整体思维、闭环思维，不能只考虑自己，要全局考虑整个团队，要做到有输出、有输入、有结果 产品分析 架构设计 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/EddieCookie/":{"url":"pages/EddieCookie/","title":"EddieCookie","keywords":"","body":"2021 也要加油鸭~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/EddieCookie/01-week01.html":{"url":"pages/EddieCookie/01-week01.html","title":"Week01","keywords":"","body":"Week01 笔记 项目概览 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/EditYJ/":{"url":"pages/EditYJ/","title":"EditYJ","keywords":"","body":"EditYJ - 课程打卡作业心得 Week01 Week01-作业-整体架构设计 V1.0 Week02 Week02-笔记-脚手架是什么 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/EditYJ/01-Week01-作业.html":{"url":"pages/EditYJ/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 范围 整体设计，架构设计，没有细节 模块设计 模块关系图 B端是前后端分离开发，受众不是大众所以不采用SSR模式开发，如果H5的编辑器比较复杂，可以拆分成单独项目进行开发。 C端采用的是SSR模式开发，一个原因是性能的考虑，另一个方面受众人数较多。 组件库独立出来作为一个第三方项目，B端的编辑器和C端共用一个组件库进行H5页面的渲染。所见即所得，B端编辑好页面后，C端也可以复用组件库进行渲染，达到视觉统一，降低开发成本。 管理后台采用前后端分离开发，内部人员使用，主要用来进行B端和C端的数据管理，数据统计，可以让运营人员把控产品的全局。 自研统计服务，统计一些自定义事件，供B端和使用后台管理系统的人员知道产品的走向。 自研统计服务主要是因为市面上支持自定义事件的统计服务大而全，而且价格昂贵，我们只需要有选择的开发一些满足自生需求的统计就行。 核心数据结构 单个组件应该使用vnode规范，使用业界统一规范有助于我们少踩一些坑，并能得到扩展性较强的组件结构。vuex store 的大概结构如下： { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图 使用统一的数据库管理数据，B端产生组件的配置数据存入数据库并发布项目，C端读取组件配置数据渲染出H5页面供用户访问，管理后台通过管理数据库的数据达到控制B端和C端的目的。 扩展性保证 数据结构层面 一些可能的整体项目级别配置项。主要是是否可编辑，是否锁定等等。 一些页面级别的配置参数，大小，背景色之类的。 编辑器层面 保证组件的可扩展性，组件的锁定，可选，图层等等后续必要的扩展功能。 开发提效 脚手架固化一些重复操作，规范流程，提高开发效率。 创建项目的流程 提交代码的流程 测试项目的流程 打包项目的流程 发布项目的流程 组件平台主要固化组件的开发和发布流程，提升组件开发效率。 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/EditYJ/02-Week02-笔记-脚手架是什么.html":{"url":"pages/EditYJ/02-Week02-笔记-脚手架是什么.html","title":"Week02 笔记 脚手架是什么","keywords":"","body":"脚手架是什么 核心目标 提升前端研发效能 将研发过程自动化，标准化，数据化。 本质 脚手架的本质是一个操作系统的客户端，通过命令执行。 执行命令通常由主命令、command、option三部分组成，即：主命令 command [command param] [option] [option param] 简单的执行过程 以vue cli为例子，输入vue后的执行的大概过程如下： 输入主命令后，首先会去从环境变量中寻找vue命令的路径 根据找到的vue命令链接到实际的vue.js 利用node执行vue.js 通过vue.js解析用户数据的后续参数 执行用户指令 开发脚手架的简单过程 以vue cli为例： 开发一个包含bin/vue.js目录的npm项目，发布在npm上 安装此项目到node的lib/node_modules下 指定node bin 目录下的vue连接至开发的vue.js 回答三个问题 为什么全局安装@vue/cli后会添加命令为vue? 答：因为安装后会自动在node的bin目录下建立vue软链接文件, 这个软链接文件指向了node/lib/node_modules/@vue对应vue.js，由于node/bin目录是在环境变量下的，所以等于添加了命令vue。 全局安装@vue/cli后发生了什么? 答：执行过程如下： 下载了vue.js命令解析执行文件到node/lib/node_modules下 在node/bin目录下创建vue软链接文件连接到node/lib/node_modules对应vue.js 执行vue命令时发生了什么？为什么vue指向一个js文件我们却可以通过vue命令去执行它? 答：第一个问题参考上面的 简单的执行过程，通过下面的vue软链接文件的内容我们可以知道第二个问题的答案： #!/bin/sh basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\") case `uname` in *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;; esac if [ -x \"$basedir/node\" ]; then \"$basedir/node\" \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" ret=$? else node \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" ret=$? fi exit $ret 通过这个文件的内容我们可以清晰的看到，本质上其实就是利用shell命令执行了node vue.js Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Joker_Yao/":{"url":"pages/Joker_Yao/","title":"Joker Yao","keywords":"","body":" 慕课网 Web 前端架构师课程学习笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Joker_Yao/01-需求分析和架构设计.html":{"url":"pages/Joker_Yao/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":" 课程标题名称——需求分析和架构设计：做什么，如何做？ 作业打卡 暂无内容 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Q小白/":{"url":"pages/Q小白/","title":"Q小白","keywords":"","body":"作业 第一周作业：技术方案设计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Q小白/01-第一周需求分析.html":{"url":"pages/Q小白/01-第一周需求分析.html","title":"第一周需求分析","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） https://www/yuque.com/imooc-lego/zlz87z 范围 使用角色分析 模版作品创建者 普通用户查看者 平台管理员 普通用户使用的看到的 H5 页面 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 H5 SSR渲染 模版作品创建者们使用的 B 端 使用者和用途：模版作品创建者可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 由 editor-fe(作品管理端) + editor-server(作品管理API服务) 构成。 平台管理员使用的管理系统（后台管理系统） 使用者和用途：慕课乐高平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计、分析、监控整个项目的线上运行状况。 由 admin-fe(慕课乐高管理运营平台) + admin-server(运营平台API服务) 构成。 模块设计 模块拆分和关系图 如下图所示（画的不好，还请老师指点） 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范(保持标准化格式，提升数据扩展性)。 用数组来组织数据，有序。 尽量使用引用关系，不要保存多份数据。 数据结构示例 { page: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本组件', data: { on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { }, attrs: { // 元素绑定的属性 title: '134' } }, contorl: { // 扩展 控制组件多种条件行为 isShow: true }, text: '文本1', tag: 'text', children: [ { id: '1-1', name: '图片组件', data: { attrs: { // 元素绑定的属性 href: '134.png' }, on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { } }, contorl: { isShow: true }, text: '图片1', tag: 'image', children: null } ] }, id: '2', name: '图片组件', data: { attrs: { // 元素绑定的属性 href: '222' }, on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { } }, contorl: { isShow: true }, text: '图片1', tag: 'image', children: null } ] } } 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 研发提效 脚手架：快速项目创建、项目快速便捷发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件,全平台输出 多处可用 运维保障 线上服务和运维服务: 接入成熟服务 阿里云 腾讯云 安全: 接入成熟服务 阿里云 腾讯云 监控和报警: 技术埋点和错误收集系统 对接邮件 做到线上问题 发送报警邮件 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Q小白/02-第二周笔记.html":{"url":"pages/Q小白/02-第二周笔记.html","title":"第二周笔记","keywords":"","body":"脚手架架构 光坚持这件事情就可以打败99%的人学习方法 架构三部曲: 掌握原理-> 独立思考 -> 总结反思 深度剖析优秀开源项目,由表及里，由浅入深 视角切换：多切换到架构师视角，从全局思考问题 注意事项 整体难度不高,坚持 优秀的程序员不仅仅能够实现功能，更能读懂别人的代码，读懂别人的想法 学会从优秀的开源项目吸取养分 什么是脚手架？ 脚手架实现原理 脚手架开发流程 站在前端研发的视角，分析开发脚手架的必要性 抽取重复部分 自动化 脚手架核心价值 将研发流程： 自动化：项目重复代码拷贝/git操作/发布流程上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化,数据化，使得研发过程可量化 和自动化构建工具的区别 问题：jenkins,travis等自动化工具已经比较成熟了，为什么还需要自研脚手架？ 不满足需求：jenkins,travis通常在githooks中触发，需要在服务器执行,无法覆盖研发人员本地的功能,如：创建项目自动化,本地git操作自动化等 定制复杂：jenkins,travis定制过程需要开发插件，其过程较为复杂，需要java语言,对前端同学不太友好。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Sunshine/":{"url":"pages/Sunshine/","title":"Sunshine","keywords":"","body":"Sunshine - 课程学习 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Sunshine/01-第一周笔记和作业.html":{"url":"pages/Sunshine/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） 背景链接 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 平台 使用者 开发方式 用途 H5(前台) 普通用户 前后端分离(editor-fe + editor-server) 对作品进行查看、分享 编辑器(中台) 作品创作者 SSR 可以自己创建或者根据模板生成作品，对作品进行创建、分布、管理 管理系统(后台) 管理员 前后端分离(admin-fe + admin-server) 可以对作品进行管理，包括用户管理、模板管理、模板使用统计、作品上下线、作品审核等 模块设计 如下图所示 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据关系流转 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件（丰富组件功能，比如加入一些动画组件） 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/Sunshine/02-第二周作业和笔记.html":{"url":"pages/Sunshine/02-第二周作业和笔记.html","title":"第二周作业和笔记","keywords":"","body":"脚手架架构设计和框架搭建 脚手架的作用 开发脚手架的核心目标是：提升前端研发效能 脚手架的核心价值 自动化：项目重复代码拷贝/git 操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 和自动化构建工具的区别 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动挡化、本地 git 操作自动化等 定制负责：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语音，对前端开发不够友好 入门 脚手架本质上来说，是一个操作系统的客户端。它通过命令行执行： vue create vue-test-app 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置 去在全局的bin目录下(/usr/local/bin)，创建一个软连接，链接到全局的node_modules目录下 @vue对应的执行文件(../lib/node_modules/@vue/cli/bin/vue.js), 软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value，value 指向的文件中需要设置 #! /usr/bin/env node 来标识文件需要用node来执行 基于 lerna 搭建自己的脚手架并且发布到 npm 安装方法 npm install -g @sunshine-cli/core 执行命令 sunshine-cli 进阶 理解 yargs 常用 API 和 开发流程 #!/usr/bin/env node const yargs = require('yargs/yargs') const dedent = require('dedent') const log = require(\"npmlog\") const { hideBin } = require('yargs/helpers') const pkg = require(\"../package.json\"); const context = { lernaVersion: pkg.version, }; const argv = process.argv.slice(2) const listCommand = { command: 'list', describe: 'list local packsges', aliases: [\"ls\", \"la\", \"ll\"], builder: yargs => { return yargs }, handler: argv => { console.log(argv) } } const cli = yargs() yargs() .usage(\"Usage: $0 [options]\") // 配置脚手架的用法 .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") // 配置最少需要参数的个数 .recommendCommands() // 当输入的命令不对时，会根据算法去匹配最接近的正确命令的提示 .strict() // 无法识别的信息错误提示 .command(listCommand) // 向脚手架注入命令 .options({ init: { describe: 'init scaffold', type: 'string', alias: 'i' } }) .fail((msg, err) => { // certain yargs validations throw strings :P const actual = err || new Error(msg); // ValidationErrors are already logged, as are package errors if (actual.name !== \"ValidationError\" && !actual.pkg) { // the recommendCommands() message is too terse if (/Did you mean/.test(actual.message)) { console.log(cli.parsed, 'argv') log.error(\"lerna\", `Unknown command `); } log.error(\"lerna\", actual.message); } // exit non-zero so the CLI can be usefully chained cli.exit(actual.code > 0 ? actual.code : 1, actual); }) .group(['help', 'version'], \"Global Options:\") .alias(\"h\", \"help\") .alias(\"v\", \"version\") .wrap(cli.terminalWidth()).epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `) .parse(argv, context) 理解 lerna 实现原理 lerna 是基于git和npm的包管理工具 实现原理 通过import-local判断当前工程中是否存在lerna包，有的话优先调用当前目录下的 通过yargs生成脚手架，主要包括globalOptions的创建、command注入、参数解析等等；command最主要的两个回调是builder和handler方法 ，分别的作用是builder用于构架命令是可以执行的参数、改命令用法的例子等，handler用于实现该命令的功能，比较重要 lerna在本地开发时可以配置本地依赖，而不需要npm link的方式只需要在package.json中配置\"@lerna/add\": \"file:../../commands/add\", 即可，在代码发布时(lerna publish)会自动替换该路径 import-local 实现原理，理解 require.resolve 实现原理 import-local主要作用是查找本地项目中是否存在该package,有的话会优先用本地的，这样的好处是可以解除全局和本地版本冲突的问题 实现原理 重要实现 fs.realPathSync该方法当找到路劲中存在软连接时，会重头开发在查找一遍，这样做的目的是为了防止软连接中还有软连接 遍历过程中生成的子路径会缓存到knownHard和cache中，这样的好处是提高查询效率； 遍历完成后得到的真实路径也会添加到缓存中，key为原始路径origin,下次就可以直接从缓存中拿到结果 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/apple/":{"url":"pages/apple/","title":"Apple","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/apple/01-week1.html":{"url":"pages/apple/01-week1.html","title":"Week1","keywords":"","body":" Q&A 1、fork 源码执行npm run dev报错 原因：当前node版本是最新版解决： nodejs版本降级到12版本以下 nvm install 12.15.0 nvm use 12.15.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/apple/02-week2-脚手架.html":{"url":"pages/apple/02-week2-脚手架.html","title":"Week2 脚手架","keywords":"","body":" 脚手架 脚手架核心价值 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，研发过程可量化 组成 脚手架本质是一个操作系统的客户端 主命令：vue command：create command的param：vue-test-app vue create vue-test-app // 强制覆盖某个已存在的文件夹 vue create vue-test-app --force // 发布npm包 npm login npm publish 脚手架本地link标准流程 链接本地脚手架 cd your-cli-dir npm link 链接本地库文件 cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件 cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib Q&A windows一些常用命令 # windows里cmd查看所有文件及目录命令 dir # 返回上一级目录 cd .. # 删除某个文件夹 # 如node_modules文件夹 rmdir /s/q node_modules 关于markdown vscode编写markdown使用到的插件 Markdown All in One Markdown Preview Enhanced markdownlint Markdown Preview Mermaid Support Markdown Preview Github Styling chrome浏览器如何预览markdown文档 chrome浏览器的网址栏输入chrome://extensions/ 应用商店安装Markdown Viewer 查看已经下载的扩展程序，然后找到Markdown Viewer 点击详细信息，将允许访问文件网址勾选。 感想 脚手架进大厂必备然鹅我不会，然鹅我不想进大厂 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/apple/03-week2-lerna.html":{"url":"pages/apple/03-week2-lerna.html","title":"Week2 Lerna","keywords":"","body":" Lerna 简介 Lerna是一个优化基于git+npm的多package项目的项目管理工具 多package管理：减少重复操作 版本一致性：操作标准化 架构优化的产物——项目复杂度提升后，架构优化的主要 目标是效能为核心的。 lerna开发脚手架流程 练级[https://github.com/lerna/lerna] Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/":{"url":"pages/clqyfe/","title":"Clqyfe","keywords":"","body":"灿烂千阳FE - 课程打卡作业笔记 Week01 需求分析和整体架构设计 Week01-作业-整体架构设计 V1.0 Week02 脚手架架构设计和框架搭建 理解脚手架 基于原生开发脚手架 基于lerna开发脚手架 yargs使用 lerna源码分析 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/01-Week01-作业.html":{"url":"pages/clqyfe/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 需求 需求文档 慕课乐高体验地址 模块设计 模块拆分: B端和编辑器（前端，后端） H5（ssr） 管理后台（前端，后端） 第三方组件库：为了保证 编辑器和 h5 组件渲染的一致性 自研统计模块：为了满足项目个性化的统计需求 模块的关系图，关键功能及职责： 作品的数据结构 核心数据结构： 组件数据结构尽量复合 VNode 规范 用数组来组织数据，有序 尽量使用引用关系，避免冗余 { // 作品 work: { title: '作品标题', setting: { /* 拓展配置： 如配置渠道 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图： B端将创建好的作品存入数据库；C端从数据库中读取创建的作品，渲染页面；管理后台可以管控作品的显示。 扩展性保证 数据结构层面 页面级别的配置参数，如全局样式配置 项目级别的配置参数，如提供分渠道统计的参数配置项 编辑器层面 组件的扩展性，如组件隐藏，锁定及图层操作 开发提效 脚手架 提供模板创建 CI/CD 组件平台 组件库的创建，发布和预览 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/02-Week02-理解脚手架.html":{"url":"pages/clqyfe/02-Week02-理解脚手架.html","title":"Week02 理解脚手架","keywords":"","body":"理解脚手架 什么是脚手架？ 脚手架本质是一个操作系统的客户端，它通过执行命令来实现相应的功能。比如：vue create vue-test，表示创建一个名为 vue-test 的 vue 项目。 脚手架的必要性 开发脚手架的核心目标是：提升前端研发效率。 脚手架的核心价值是可以将研发过程自动化、标准化、数据化。 自动化：项目重复代码拷贝、git 操作、发布上线操作。 标准化：项目创建、git flow、发布流程、回滚流程。 数据化：研发过程系统化、数据化、使得研发过程可量化。 和自动化工具的区别 问题：jenkins、travis等自动化构建工具已经比较成熟了，为什么还要自研脚手架？ 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能。如：创建项目自动化，本地 git 操作自动化等。 定制复杂：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语言，对前端同学不够友好。 脚手架执行命令解析 例如： vue create vue-test 上面这条命令由 3 个部分组成： 主命令: vue command: create command 的 param: vue-test 这条命令表示创建一个 vue 项目，项目的名字叫 vue-test。 以上是最一个较为简单的脚手架命令，但实际场景往往更加复杂，比如： vue create vue-test-app --force -r https://registry.npm.taobao.org 这里的 --force，-r 都叫做 option，只不过 -r 使用的是简写形式，可以替换成 --registry。 -r https://registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param，其实 --force 可以理解为：--force true，简写为：--force。 脚手架的执行原理 执行原理如下： 在终端执行命令 vue create vue-test 终端解析 vue 命令 终端在环境变量中查找 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端使用 node 执行 vue.js 文件 vue.js 解析 command 、options vue.js 执行 command 执行完成，退出执行 脚手架实现原理 实现原理 如果你能回答以下三个问题，就掌握了脚手架实现原理。 为什么全局安装的 @vue/cli 后会添加的命令为 vue？ 全局安装 @vue/cli 时发生了什么？ 执行 vue 命令时发生了什么？为什么 vue 指向了一个 js 文件，却可以通过 vue 命令去执行它？ 问题 1： 在 @vue/cli 的 npm 包的 package.json 中设置了 bin 属性 { ... \"bin\": { \"vue\": \"bin/vue.js\" }, ... } 该属性决定了安装包后添加的命令为 vue。 问题 2： npm 会将 @vue/cli 下载到 /usr/local/lib/node_modules（全局安装的 node） 目录下 下载完成后会解析 package.json 文件 根据 package.json 中的 bin 属性，在 node 的执行目录 /usr/local/bin 下创建名为 vue 的软链接，并将 vue 链接到 bin 属性中配置的文件 bin/vue.js 问题 3： 执行 vue 命令时发生了什么？ 在环境变量中查找 vue 不存在：提示命令不存在 存在：根据 vue 命令找到实际文件 vue.js 并执行该文件 为什么 vue 指向了一个 js 文件，却可以通过 vue 命令去执行它？ 在 vue.js 文件最顶部声明了使用环境变量中的 node 来执行此文件 #!/usr/bin/env node ... 思考：以下两种方式有啥区别？ #!/usr/bin/env node #!/usr/bin/node 第二种是 node 的实际安装目录，只不过别人安装这个包时，如果 node 的目录不一致就无法运行了。 原理进阶 为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？ 如何为 node 脚手架命令创建别名？ 问题 1： 执行脚手架的时候，其实是作为操作系统上的一个可执行文件来进行执行，所以可以理解脚手架就是操作系统的一个客户端。但是这个客户端本质上并不是我们编写的文件，因为执行脚手架需要借助 node 来执行，node 才是系统的客户端，而我们编写的脚手架文件仅仅只是 node 一个参数。 脚手架和 PC 上安装的软件本质上没什么区别，只是安装的软件存在 GUI 而已，我们也可以通过 node 来调取系统的 GUI 绘制 API 来绘制窗口。 问题 2： 比如：给 vue 设置别名。 vue 在系统中的软链接如下 ll /usr/local/bin/vue # lrwxr-xr-x 1 zhoujiawei wheel 39B 12 26 14:35 /usr/local/bin/vue -> ../lib/node_modules/@vue/cli/bin/vue.js 配置别名为 vue2 cd /usr/local/bin/ ln -s ./vue vue2 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/03-Week02-基于原生开发脚手架.html":{"url":"pages/clqyfe/03-Week02-基于原生开发脚手架.html","title":"Week02 基于原生开发脚手架","keywords":"","body":"基于原生开发脚手架 脚手架开发流程 创建 npm 项目 创建脚手架入口文件，最上方添加：#!/usr/bin/env node 配置 package.json，添加 bin 属性，设置脚手架命令执行该入口文件 编写脚手架代码 将脚手架发布到 npm 注意：如果执行 npm i 命令所在的目录是脚手架的父级目录，安装后 lib/node_modules 中的包会指向本地的脚手架。也就是说本地更改代码后，指向命令其结果也会改变，方便本地调试。如果不想这样，执行安装命令时请更改目录。 脚手架的本地调试方法 除了上述方法，还可以使用 npm link 的方式进行本地 npm 包开发。 进入本地 npm 包所在目录，运行命令 npm link，就会在 /usr/local/lib/node_modules 目录下加入本地包，并且在 /usr/local/bin 目录中创建软链接。 cd zjw-test npm link ll /usr/local/bin/zjw-test # lrwxr-xr-x 1 zhoujiawei wheel 41B 12 26 19:15 /usr/local/bin/zjw-test -> ../lib/node_modules/zjw-test/bin/index.js ll /usr/local/lib/node_modules # lrwxr-xr-x 1 zhoujiawei wheel 44B 12 27 00:20 zjw-test -> /Users/zhoujiawei/Desktop/脚手架/zjw-test 如果本地 npm 包开发过程中还依赖本地另外一个 npm 包，又该怎么处理呢？ 假设两个包为： zjw-test、zjw-test-lib，zjw-test 依赖 zjw-test-lib。 进入 zjw-test 目录，执行 npm link 进入 zjw-test-lib 目录，执行 npm link 此时，两个包都别加入到 lib/node_modules 中了，再在 zjw-test 中执行 npm link zjw-test-lib，相当于安装了依赖包 zjw-test-lib 在 package.json 中，更改版本号，删除 node_modules，执行 npm i，重新安装依赖包。 cd zjw-test-lib && npm link cd zjw-test && npm link && npm link zjw-test-lib && rm -rf node_modules && npm i 如果先在 zjw-test-lib 中执行 npm unlink，再在 zjw-test 执行 npm unlink zjw-test-lib 会报文件不存在的错误。 当 zjw-test-lib 开发完成后需要发布，操作如下： 进入 zjw-test 目录，执行 npm unlink zjw-test-lib 进入 zjw-test-lib 目录，执行 npm unlink，修改 version，执行 npm publish 进入 zjw-test 目录，执行 rm -rf node_module，重新安装依赖，执行 npm publish 发布成功后重新安装全局 zjw-test 总结 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件： cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件： cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解 npm link： npm link：将当前项目链接到 node 全局 node_modules 中作为一个库文件，并解析 bin 配置创建可执行文件 npm link your-lib：将当前项目中 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件 理解 npm unlink： npm unlink：将当前项目从 node 全局 node_modules 中移除 npm unlink your-lib：将当前项目中的库文件依赖移除 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/04-Week02-基于lerna开发脚手架.html":{"url":"pages/clqyfe/04-Week02-基于lerna开发脚手架.html","title":"Week02 基于Lerna开发脚手架","keywords":"","body":"基于lerna开发脚手架 脚手架开发难点 分包：将复杂的系统拆分成若干个模块 命令注册（vue create、vue add、vue invoke） 参数解析： options全称：--version、--help options简写：-V、-h 带 params 的 options：--path /User/zjw/Desktop/vue-test 示例： vue command [options] 帮助文档： global help Usage Options Commands 示例：vue 的帮助信息： Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. command help Usage Options vue create 的帮助信息： Usage: create [options] create a new project powered by vue-cli-service Options: -p, --preset Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset Skip prompts and use inline JSON string as preset -m, --packageManager Use specified npm client when installing dependencies -r, --registry Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists --merge Merge target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions --skipGetStarted Skip displaying \"Get started\" instructions -h, --help output usage information 还有很多，比如： 命令行交互 日志打印 命令行文字变色 网络通信：HTTP/WebSocket 文件处理 等等...... lerna 介绍 原生脚手架开发痛点分析： 痛点一：重复操作 多Package本地link 多Package依赖安装 多Package单元测试 多Package代码提交 多Package代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互依赖版本升级 package越多，管理复杂度越高 lerna 简介: lerna 是一个优化基于git+npm的多package项目的管理工具。 使用 lerna 开发脚手架优势： 大幅减少重复操作 提升操作的标准化 lerna 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 lerna官网 lerna 开发脚手架流程（重点） 基于 lerna 开发脚手架： 安装 lerna npm install -g lerna 创建项目 git init zjw-cli-dev && zjw-cli-dev 初始化 Lerna 项目 lerna init 创建 Package lerna create core 安装依赖 # 安装到所有 package 的 dependencies lerna add mocha # 安装到所有 package 的 devDependencies lerna add mocha --dev # 安装到某个 package 的 devDependencies 下，如果之前已经安装过了，请先把 package.json 中的依赖删除 lerna add mocha package/core --dev 删除依赖 lerna clean 重新安装依赖 lerna bootstrap 执行单元测试 # test 命令是在 package.json 配置的 script 命令 lerna run test 执行特定包的单元测试 # 安装依赖提供的时文件夹名称，而执行命令使用包名称 lerna run --scope @zjw-cli-dev/core test link 项目 lerna link 发布项目 lerna publish 使用细节： lerna init 会自动完成 git 初始化，但不会创建 .gitignore，这个必须要手动添加，否则会将 node_modules 目录都上传到 git，如果 node_modules 已经加入 git stage，可使用： git reset HEAD 执行 unstage 操作，如果文件已经被 git 监听到变更，可使用： git checkout -- 将变更作废，记得在执行操作之前将文件加入 .gitignore # gitignore .vscode .idea .DS_Store node_modules packages/**/node_modules lerna-debug.log lerna create 在创建 package 时，为了防止重名在输入 package name 时一般都是创建在某个组织内，如：@zjw-cli-dev/core。在 @ 和 /之间就是组织名称。 声明在组织内的 package 需要 npm 上创建对应的 组织，否则发布不了。(Add Organization ---> 输入名称，点击 create ---> 点击 skip) // package.json { ... \"name\": \"@zjw-cli-dev/core\", ... } lerna add 第一个参数：添加 npm 包名 第二个参数：本地 package 的路径 选项：--dev：将依赖安装到 devDependencies，不加时安装到 dependencies lerna add [loc] --dev lerna link 如果未发布上线，需要手动将依赖添加到 package.json 再执行 lerna link // 如：在 @zjw-cli-dev/core 的 package.json 中 dependencies 添加 @zjw-cli-dev/utils 依赖 { ... dependencies: { \"@zjw-cli-dev/utils\": \"^1.0.0\" } ... } lerna clean 只会删除 node_modules，不会删除 package.json 中的依赖 lerna exec 和 lerna run --scope 属性后添加的是包名，而不是 package 的路径，这点和 lerna add 用法不同 lerna publish 发布时会自动执行：git add package-lock.json，所以 package-lock.json 不要加入 .gitignore 先创建远程仓库，并且同步一次 master 分支 执行 lerna publish 前先完成 npm login 如果发布的 npm 包名为：@xxx/yyy 的格式，需要先在 npm 注册名为：xxx 的 organization，否则可能会提交不成功 发布到 npm organization(group) 时默认为 private，所以我们需要手动在 package.json 中添加如下配置： \"publishConfig\": { \"access\": \"public\" } lerna 是如何引用本地 lib 库的？ package.json 中引用本地依赖 \"dependencies\": { \"lerna\": \"file:core/lerna\" } 官方文档 lerna publish 发布时会将 file: 进行替换 resolveLocalDependencyLinks() { // resolve relative file: links to their actual version range const updatesWithLocalLinks = this.updates.filter(node => Array.from(node.localDependencies.values()).some(resolved => resolved.type === \"directory\") ); return pMap(updatesWithLocalLinks, node => { for (const [depName, resolved] of node.localDependencies) { // regardless of where the version comes from, we can't publish \"file:../sibling-pkg\" specs const depVersion = this.updatesVersions.get(depName) || this.packageGraph.get(depName).pkg.version; // it no longer matters if we mutate the shared Package instance node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix); } // writing changes to disk handled in serializeChanges() }); } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/05-Week02-yargs使用.html":{"url":"pages/clqyfe/05-Week02-yargs使用.html","title":"Week02 Yargs使用","keywords":"","body":"yargs 使用 #!/usr/bin/env node const dedent = require('dedent'); const yargs = require('yargs/yargs'); const { hideBin } = require('yargs/helpers'); const pkg = require('../package.json'); const context = { cliVersion: pkg.version } // console.log(hideBin(process.argv)) // [ '--help', '*', ... ] // const argv = yargs(hideBin(process.argv)).argv; const cli = yargs(hideBin(process.argv)) cli // 使用提示, $0: argv 中 $0，即脚手架软链接名称 zjw-cli-test .usage('Usage: $0 [options]') // 输入不存在命令会给报误 .strict() // 最少需要一个 command .demandCommand(1, 'A command is required. Pass --help to see all available commands and options.') // 当输入一个不存在的命令时会给出最接近的命令 .recommendCommands() // 发生错误时执行的方法，不写 fail，输入错误指令会给出 --help 结果 .fail((msg, err) => { console.log('msg: ', msg) }) // 设置 help 别名为 h .alias('h', 'help') .alias('v', 'version') // 将容器宽度设置为终端的宽度 .wrap(cli.terminalWidth()) // 在最后面输出的信息 .epilogue(dedent` Your own log `) // 可配置 1 个以上的 option .options({ 'debug': { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) // 配置单个 option .option('registry', { type: 'string', describe: 'Define global registry: npm, yarn', alias: 'r' }) // 将 option 分组 .group(['debug'], 'Debug Options:') .group(['r'], 'Repository Options:') // 注册命令 .command( 'init [name]', 'do init project', // builder: 配置该命令专属 option yargs => { yargs.option('name', { type: 'string', describe: 'Name of project', alias: 'n' }) }, // handler: 处理命令的业务逻辑 argv => { console.log(argv) } ) // 注册命令的第二种方式 .command({ command: 'list', aliases: ['ll', 'la', 'ls'], describe: \"List local packages\", builder: yargs => {}, handler: argv => { console.log(argv) } }) // 解析参数 .argv // 处理使用 .argv 的方式来完成参数解析外，还可以调用 yargs.parse 来完成命令行参数解析 // .parse(argv, context) // hideBin(process.argv) 等价于 process.argv.slice(2)。parse 会将两个对象合并成一个新的对象作为命令行参数。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/clqyfe/06-Week02-lerna源码分析.html":{"url":"pages/clqyfe/06-Week02-lerna源码分析.html","title":"Week02 Lerna源码分析","keywords":"","body":"lerna源码分析 lerna实现原理 通过 import-local 库优先调用本地的 lerna 命令。巧妙的利用异步的方式先输出提示信息，再完成命令的执行。 通过 yargs 生成脚手架，先注册全局属性，在注册命令，最后通过 parse 方法解析命令行参数。 注册命令时需要传入 builder 和 handler 两个方法。builder 用来配置命令的专属 option，handler 用来处理命令的业务逻辑，同时命令行参数作为函数参数方式传入函数。 lerna 通过其自有的方式来引用本地依赖，而不是通过 npm link 的方式。具体写法：在 package.json 的依赖项中写入，在执行 lerna publish 时会自动将该依赖替换。 // package.json { \"dependencies\": { \"lerna\": \"file:core/lerna\" } } import-local 源码分析 TODO: 学完脚手架内容再来啃这部分内容 node 的 module 模块分析 TODO: 学完脚手架内容再来啃这部分内容 vscode 源码调试技巧 vscode 调试技巧 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/coderzlh/":{"url":"pages/coderzlh/","title":"Coderzlh","keywords":"","body":"coderzlh - 学习分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/coderzlh/01-week01-note.html":{"url":"pages/coderzlh/01-week01-note.html","title":"Week01 Note","keywords":"","body":"第一周笔记 体验地址: 慕课乐高 项目架构 使用技术栈 架构设计做什么 如何做 架构师的核心价值 : 通过技术手段保证技术增长,对业务精准理解 需求指导设计,设计指导开发 技术永远是为业务服务的,技术是实现业务增长的工具 整体分析时不需要注意细节 判断可行性,需要适当调研 考虑复杂度,不过度设计 脱离业务的设计就是耍流氓 需求即业务,无业务不架构 需求闭环 业务闭环 前段开发流程 需求关系图 技术方案设计文档 模块设计 h5端: 提供作品展示与分享的功能 编辑器前端: 提供作品编辑 制作与发布功能 编辑器服务端: 支持编辑器前端的功能 并将作品持久化到数据库 后台管理前端: 供管理员使用 用于管理作品与模板 快速下线违规作品 查看运营统计数据 后台管理服务端: 为后台管理提供接口服务 组件库: 为h5与编辑器端提供组件服务 并可以通过脚手架工具快速创建和发布组件 自研统计: 用于统计自定义事件的pv uv等指标 三方服务: 短信服务: 用于注册 登陆以及密码找回等操作需要验证用户身份时使用 oss文件存储: 存储静态文件 埋点统计: 用于统计pv uv等常见运营指标 微信sdk: 用于微信分享 便于传播 核心数据结构 每个组件尽量符合vnode规范 使用数据来组织数据 有序 尽量使用引用关系 不要冗余 { work:{ id:'xxx', title:'标题', props:{/*全局配置属性*/}, settings:{/*拓展预留*/}, components:[ { id:'xxxx', name:'文本1', tag:'text', attrs:{color:red}, children:[] } ] }, //当前被选中的组件id activeComponentId:'xx' } 拓展性 增加动画,音效 甚至简单的交互功能 批量选中与批量修改 多人协作 同时编辑 研发提效 脚手架: 创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控与告警 服务拓展性: 基于云服务,可以随时拓展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jia林_286621855/":{"url":"pages/jia林_286621855/","title":"Jia林 286621855","keywords":"","body":"前端架构 整体思维、全局思维、闭环思维 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jindong/":{"url":"pages/jindong/","title":"Jindong","keywords":"","body":"jindong - 前端架构师课程学习心得 第一周 需求分析和架构设计 第二周 脚手架架构设计和框架搭建 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jindong/01-需求分析和架构设计.html":{"url":"pages/jindong/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析：架构师的思维分析项目需求（浅层需求、深度需求、需求总览） 一眼能看到的需求是浅层需求，比如说：登录，创建作品，发布 不容易一眼看到，却很重要的需求是深层需求，比如说：作品恢复、转赠、统计 对架构师而言，对业务的深层理解是很重要 流程图：分析项目需求的工具 全局思维、整体思维、闭环思维 目标不是一成不变的，必要时可以调整目标 架构师和普通程序员的区别：架构师必须精准理解业务需求，对业务完全负责 技术永远是为业务服务的，技术是实现业务增长的工具 一定要重视需求和设计的重要性 脱离业务的架构就是耍流氓。架构师必须要深入理解需求、参与需求、看透需求背后的业务本质 架构设计：确定需要创建的项目、项目范围、项目之间的关系 规划业务组件库：考虑组件的拆分和复用 注意事项： 不要关注细节，要看整体，看范围 考虑扩展性（这就需要深入理解业务，否则你也不知道未来将如何扩展） 考虑可行性，不确定的就调研一下 考虑实现成本，不要为了设计而设计，技术要永远服务于业务 —— 永远都要选择最简单的实现方案 架构设计：调项目技术研，确定第三方和自研服务 尽量使用第三方服务，如果没有合适的第三方服务，则自行研发，如：自定义事件统计 架构设计：数据结构设计和数据流转设计 数据设计基本思路： 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 绘制数据流转关系图 架构设计：编写技术方案设计文档 写代码前要写，技术方案设计文档（架构设计文档），写文档是为了整理思路，从而更好的写代码 需求背景：把需求文档贴上 范围：整体设计，没有细节 模块设计 模块拆分和关系图 各个模块的功能解释 特殊模块说明：组件库、统计服务 核心数据结构设计 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 研发提效 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 关于运维保障 做架构师，要一直有风险意识，让你的系统时刻在你的监视之内，这才靠谱。 大厂：有自己自研的运维工具和流程，要熟练使用，并知道负责的接口人 小厂：了解市面上比较靠谱的第三方服务 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jindong/02-脚手架架构设计和框架搭建.html":{"url":"pages/jindong/02-脚手架架构设计和框架搭建.html","title":"脚手架架构设计和框架搭建","keywords":"","body":"脚手架学习 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/joge/":{"url":"pages/joge/","title":"Joge","keywords":"","body":"姜浩然-作业及打卡的地方 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/joge/week-01-技术方案设计文档.html":{"url":"pages/joge/week-01-技术方案设计文档.html","title":"Week 01 技术方案设计文档","keywords":"","body":"整体架构设计V1.0 范围 拆分模块范围: 编辑器发布和预览h5, 拆分为前端和后端 管理平台管理用户和h5的上线下线, 拆分为前端和后端 展示端 H5服务端渲染html串 组件库展示端和编辑器公用的组件库 统计自研一个统计服务，H5负责收集信息，然后服务进行分析，通过openApi的方式达到展示，完成闭环 数据库编辑器和管理平台共用一套数据库 模块设计 编辑器 用于发布/预览H5, 新建及更新H5 管理平台 控制H5的上线和下线，比如紧急下线 H5 组件库 编辑器和H5都用到这个组件库 统计 在H5端收集信息，通过openApi的方式提供对外的接口自研主要是为了自定义一些事件提供统计服务业务才能闭环 整体流程及数据流转 作品的数据结构 以数据驱动为思想 维护一份数据，通过这份数据去渲染不同的组建（减少数据同步） 以数组为整体的数据结构，方便排序 单个的数据（组建）以vnode的格式存储读取eg: { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， components: [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 扩展性保证 扩展组件 数据结构层面可扩展 组件库层面扩展 扩展编译器的功能 组件隐藏、锁定、滑动翻页 扩展页面配置 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务用什么 安全 监控和报警 服务扩展性：流量大时怎么解决 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/joge/week-02-cli.html":{"url":"pages/joge/week-02-cli.html","title":"Week 02 Cli","keywords":"","body":"项目脚手架 通过learn发布的npm项目理解git流理解前端自动化 核心是为了提高研发效率（心中牢记） 听完这周课程又理解了node能做的这么多 脚手架开发入门 脚手架的必要性 开源项目 真实项目都会使用脚手架 提升研发效能 创建项目和通用代码 git操作（自动化） 构建和发布上线 价值 研发过程自动化 拷贝重复代码/git操作/发布上线 研发过程标准化 创建项目/git flow/发布流程/回滚流程 数据化 使研发流程可量化 脚手架到底是什么 从使用的角度 到底什么是脚手架本质是操作系统客户端(vue create xxxx --focus -r xxxx) vue主命令 create子命令(command) xxxx(参数) --focus和-r叫option， 子命令向主命令发送请求 整体执行过程vue create 终端到底是怎么执行的 终端会从环境变量中找到vue然后解析出vue.js vue.js解析command options vue.js执行command 执行完毕退出 怎么开发脚手架 开发一个npm项目，包含一个bin/vue.js, 发布到npm 将npm项目安装到node的lib/node_modules 在node/bin目录下配置软连接连接到lib/node_modules/@vue/cli/bin/vue.js 疑问 实现原理 依赖node 和操作系统有关 - 环境变量 root账户 为脚手架设置别名 直接设置软连接 开发流程 npm项目 添加入口文件 最上方添加 #! /usr/bin/env node package.json添加bin属性 编写代码 发布npm包 开发难点 如何将复杂系统拆分然后再合成一个复杂系统 注册一系列命令 参数解析 编写帮助文档 参数解析 注册命令 init --version、 init --name lerna 基于git+npm 多package 解决脚手架过程中的重复操作 重复操作 解决版本一致性问题 使用lerna搭建项目 lerna源码分析 源码结构 核心执行流程 import-local yargs yargs用法 dedent把通过``里换行的部分顶格yargs .options(opts) .group(globalKeys, \"Global Options:\") .option(\"ci\", { hidden: true, type: \"boolean\", }); options: 全局方法，所有的common都可以使用 加载模块过程 Module._resolveFilename Module._resolveFilename(moudleId, { id: fromFile, // 文件路径 filename: fromFile, path: Module._nodeModulePaths(fromDir) // 所有可能的nodemodule的路径 }) // 细节未添加完 架构 效能为核心目标 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jolly_chen/":{"url":"pages/jolly_chen/","title":"Jolly Chen","keywords":"","body":"Jolly_chen - 作业打卡 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/jolly_chen/01-技术方案设计文档.html":{"url":"pages/jolly_chen/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":"整体架构设计V1.0 需求背景 需求文档语雀链接 创建作品、发布作品、管理作品 范围 整体设计、架构设计 包括B端和编辑器、H5端、管理后台、独立组件库、自研统计服务，pv/uv统计，使用第三方统计服务（免费的）。 模块设计 模块拆分 B端和编辑器，比较复杂，前后端分离 H5端，考虑性能，使用SSR，只需要服务端 管理后台也前后端分离，分管理前端和管理后端 组件库分为业务组件库和组件平台 业务组件库渲染B端画布和H5页面，保证B端编辑器和H5内容和样式，即B端编辑器和H5的组件和渲染逻辑一致。组件平台创建、发布组件，支持业务组件库，方便组件扩展。 自研统计服务 模块关系图及各模块职责简要说明 自研统计服务 负责pv/uv之外的统计，pv/uv只是域名级别的访问统计，自研统计服务实现参数级别的统计。具备的功能 支持自定义事件统计，接受埋点统计请求（日志收集） 分析统计结果（日志分析） 提供Open API给使用方 为何自研：调研发现，第三方统计服务，若要满足上述功能，费用很贵。但统计服务是整个业务的输入环节，供公司运营使用，提供决策依据，比如从什么渠道投放广告达到收益和费用的平衡等 。有输入有输出，项目才能闭环，不能砍掉，所以只能自研。 核心数据结构 一个“作品”的数据结构 { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， components: [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 使用vuex store的缓存数据，方便页面上各组件读写。 图层 使用 vuex getter计算得出，这个的getter和vue computed类似 { layers () => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 数据结构设计的解释 使用vnode规范存储组件数据，vue本身也实现了VNode，使用VNode也符合vue特点。其方便组件扩展，增强页面dom节点的表述，增加数据结构的合理性并降低学习成本 使用数组存储组件，方便画布中的组件排序 不单独存储图层数据，规避图层和组件状态同步问题。这里的图层是若干组件的一个索引或者是给组件排序的一个列表，应该使用computed计算出图层的索引，满足较少数据源原则 activeComponentId是画布和属性面板同步更新的重点，组件变了，图层就发生改变 重复一遍，尽量使用索引，避免数据冗余 问题（这个不属于技术方案设计文档的内容）：如何保证画布和属性面板是同步更新的？ ​ 如果要扩展一个图层面板，数据结构该怎么设计？ 数据流转关系图 扩展性保证 扩展组件，当前数据结构层面可扩展，组件库层面扩展 组件库是独立的，按照已有组件规范方便扩展 数据结构上，也可以保证组件扩展 扩展编译器的功能，例如：组件隐藏、锁定、滑动翻页等，前两者在VNode中添加属性即可 扩展页面配置，vuex store setting 开发提效 脚手架 组件平台 运维保障 （后续补充） 线上服务和运维服务用什么 安全 监控和报警 服务扩展性：流量大时怎么解决 大厂自研，小厂使用第三方云服务，后续补充第三方云服务使用 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/linlei/":{"url":"pages/linlei/","title":"Linlei","keywords":"","body":"linlei - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/linlei/01-需求分析.html":{"url":"pages/linlei/01-需求分析.html","title":"需求分析","keywords":"","body":"需求设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/linlei/02-脚手架架构设计和搭建.html":{"url":"pages/linlei/02-脚手架架构设计和搭建.html","title":"脚手架架构设计和搭建","keywords":"","body":"脚手架架构设计和搭建 脚手架是什么 脚手架的本质是一个操作系统的客户端，他通过命令行执行，比如： vue create project 上面的命令由3部分组成： 主命令：vue command：create command的params：project 他表示创建了一个vue的项目，项目名称为project，以上是一个比较简单的脚手架命令，不过实际应用场景会更加复杂： vue create project --force 这里--force叫做option用来辅助脚手架确认在特定的场合下用户的选择，也可以理解成配置。 这里我们就会好奇这些指令是怎么来的？ 打开终端输入：vue -h Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. 通过面板我们可以看到Commands下有create，add等等一系列的命令。如果我们需要查看create的具体配置如下： Usage: create [options] create a new project powered by vue-cli-service Options: -p, --preset Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset Skip prompts and use inline JSON string as preset -m, --packageManager Use specified npm client when installing dependencies -r, --registry Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists --merge Merge target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions --skipGetStarted Skip displaying \"Get started\" instructions -h, --help output usage information 那么我们输入这些指令之后到底发生了什么？ 脚手架实现原理 当用户输入在终端vue create project时： 脚手架的执行原理如下： 在终端输入vue create project 终端解析出vue命令 终端在环境变量中找到vue命令 终端根据vue命令链接到实际到文件vue.js 终端利用node执行vue.js vue.js解析command/options vue执行command 执行完毕，退出终端 脚手架原理进阶 开发一个脚手架 为什么要开发一个脚手架？ 1、减少时间，不必从零开始搭建初始项目，提高开发效率。 2、便于多人协作。 3、项目更新同步方便，只需要更新代码库中项目模板，即可下载最新的项目。 脚手架的开发流程 脚手架开发 创建npm项目 npm init -y 创建脚手架文件入口，最上方添加： #! /usr/bin/env node 配置package.json,添加bin属性，编写脚手架代码，发布npm 然后执行npm link软连接到node下,这个时候就可以直接使用在bin下定义的intest-cli了。 打开终端输入： intest-cli 打印： 开发cli 脚手架安装 以上是我们在本地开发中使用，如果项目发布到npm上了，那么就在终端输入npm i intest-cli -g进行全局安装，就可以进行使用了。 脚手架开发难点 分包：将复杂到系统拆分为若干个模块 命令注册：vue create vue add vue invoke 参数解析：vue command [options] options全称：--version,--help options简写：-V,-h 带params的options：--path/ Users/linlei/Desktop/vue-test 帮助文档： global help Usage Options Commands 还有很多，比如： 比如命令行交互 日志打印 命令行文字变色 网络通信，http/websocket 文件处理 ... 脚手架本地link标准流程 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件： cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件： cd your-lib-dir npm unlink cd your-cli-dir npm unlink your-lib 理解npm link: npm link your-lib: 将当前项目中的node_modules下指定的库文件链接到node全局下的库文件 npm link: 将当前项目链接到node全局node_modules中作为库文件，并解析bin配置，创建可执行文件 理解npm unlink: npm unlink将当前项目从node到全局node_modules下删除 npm unlink your-lib: 将当前项目中的库文件依赖删除 lerna lerna是一个优化给予git+npm的多package项目的管理工具 优势 大幅减少重复操作 提升操作的标准化 lerna是架构优化的产物，它揭示了一个架构真理，项目复杂度提升后，就需要对项目进行架构优化，架构优化的主要目标，往往以效能为核心。 如何使用 1.脚手架项目初始化 初始化npm项目-->安装lerna-->learn init初始化项目 2.创建package lerna create 创建package-->lerna add 安装依赖-->lerna link 链接依赖 3.脚手架开发和测试 lerna exec 执行shell脚本--> lerna run执行npm命令 --> lerna clean 清空依赖 -->lerna bootstrap 重装依赖 4.脚手架发布上线 lerna version bump version --> lerna changed查看上版本以来的所有版本 --> lerna diff 查看diff --> lerna publish发布 基于lerna创建项目 安装lerna npm install -g lerna lerna命令： lerna create xxx创建一个项目 lerna add axios我们可以看到在packages下的所有子项目都会安装这个依赖 lerna add axios packages/xxx给某个项目安装依赖 lerna exec -- rm -rf node_modules 删除目录下的所有的node_modules文件夹 lerna exec --scope xxx -- rm -rf node_modules 删除指定目录下的文件，xxx代表package.json的name值 lerna bootstrap 重装依赖 lerna run xxx xxx表示scripts脚本命令，所有的项目都会执行 lerna run --scope devname xxx执行指定目录下的脚本，devname表示package.json包名，xxx表示scripts脚本命令 yargs的基本使用 1.安装 npm i yargs 2.在项目中使用 #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') const arg = hideBin(process.argv) const dedent = require('dedent') // 终端信息栏对齐 const cli = yargs(arg) cli .usage('Usage: intest-cli [command] ') // 使用方式的介绍 .alias('h', 'help') // 别名 .alias('v', 'version') .wrap(cli.terminalWidth()) // 终端右侧的宽度 .epilogue(dedent`底部信息 111`) // epilogue给底部添加一个信息，dedent，终端左侧栏对齐 .demandCommand(1, 'A command is required. Pass --help to see all available commands and options.') // 最少输入的命令个数 .strict() // 严格模式 .options({ // 对全局的[command]都起作用可以处理多个option debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) .option('registry', {// 同options类似，处理单个 describe: '注册', alias: 'r' }) .group(['debug'], 'Dev Options') // 对option进行分组 .command('init [name]', 'create a project', (yargs)=> {// 执行命令 yargs.option('name', { type: 'string', describe: 'name of a project' }) },(args)=> { console.log(args) }) .command({ // 可以处理多个command以对象对形式处理 command: 'list', aliases: ['ls', 'li'], describe: 'list local packages', builder: (yargs) => { }, handler: (argv) => { console.log(argv) // 打印终端输入的指令 } }) .argv; Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/littlefish1900/":{"url":"pages/littlefish1900/","title":"Littlefish1900","keywords":"","body":"littlefish1900 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/littlefish1900/01-week01-作业.html":{"url":"pages/littlefish1900/01-week01-作业.html","title":"Week01 作业","keywords":"","body":"慕课乐高整体架构设计 需求分析 慕课乐高需求文档 范围 项目整体架构设计 模块设计 组件库，独立的第三方组件库，同时用于编辑器和 H5 自研统计服务，使用自定义事件，统计不同分享渠道的流量 作品的数据结构设计 基本思路 每个组件尽量符合 vnode 规范 用数据来组织数据，保证有序 尽量使用引用关系，减少冗余 work: { title: '', setting: {/*可能需要的配置项*/}, props: {/*页面body的一些设置*/}, components: [ { id: 'xxx1', name: 'xxx1', tag: 'image', attrs: { fontSize: '14px' }, children: [ '文本' ] }, { id: 'xxx2', name: 'xxx2', tag: 'text', attrs: { fontSize: '14px' }, children: null }, ] } //画布当前选中的组件 activeComponentId: 'xxx' } 图层通过计算属性获取 layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } 数据流转 核心： B 端、C 端、管理后台，共用一个数据库 创建作品： 初始化一个 JSON 数据 保存作品： 修改 JSON 数据 发布作品： 修改一个标记 C 端浏览作品： 获取 JSON 数据，SSR 渲染页面 后台管理作品： 修改数据标记，C 端判断是否展示 此外，C 端需要缓存，防止频繁访问数据库 扩展性保证 组件平台提供扩展组件功能 数据结构 setting 和 props 提供了扩展性 扩展编辑器的功能，通过扩展 vnode 实现，例如：组件隐藏，锁定 （讨论，集思广益） 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/liwen/":{"url":"pages/liwen/","title":"Liwen","keywords":"","body":"hi Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/liwen/01-需求分析和架构设计.html":{"url":"pages/liwen/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"week1 init Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/lwjcjmx123/":{"url":"pages/lwjcjmx123/","title":"Lwjcjmx123","keywords":"","body":"lwjcjmx123 - 学习记录 Week01 Week01-笔记 Week01-作业-技术方案设计 V1.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/lwjcjmx123/01-技术方案设计文档.html":{"url":"pages/lwjcjmx123/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":" 整体架构设计V1.0 需求背景 需求文档 创建作品、发布作品、管理作品 范围 根据我的理解，我将作品范围一共分为三层 展示层： 给用户展示海报的H5页面 用户生存海报的B端前端 管理员管理的M端前端 server层： 对应的展示层的各个应用的后端 扩展层： 如自研统计服务等 脚手架 组件平台等 模块设计 核心数据结构 { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， layers: [ /*我的思路是每个layer里一个组件列表*/ [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 图层的设计 我最初的思路是每个图层里都有一个组件列表，然后根据图层来渲染。 扩展性保证 保证配置可扩展：预留扩展字段如setting等 保证服务可扩展：各业务单独部署，互不影响 保证组件可扩展：Vnode格式本身即可满足扩展需求 开发提效 脚手架 脚手架的作用是方便后续工程快速启动。 组件平台 组件平台可以将公用组件封装起来。方便各项目复用，其实简单的封装组件，还是会有一些问题，比如多项目间组件版本管理。 运维保障 线上服务和运维服务用什么： 阿里云，腾讯云等厂商服务 安全： 数据库安全，服务器安全。xss，sql注入等问题。 监控和报警： 第三方监控如sentry，结合sdk可以发送邮件，钉钉消息，短信等告警信息 服务扩展性：流量大时怎么解决，云服务弹性扩容 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/lwjcjmx123/01-第一周笔记.html":{"url":"pages/lwjcjmx123/01-第一周笔记.html","title":"第一周笔记","keywords":"","body":" 核心数据结构设计 写技术方案设计文档 流程图 架构师思维： 全局思维： 考虑全面 整体思维 闭环思维 架构师思维来分析需求 业务组件库： 自定义事件统计 学习方法 要有耐心，不要只想着写代码。要多考虑需求和she ji 抛弃程序员思维 技术永远是为业务服务的，技术是实现业务增长的工具 注意事项 不要只关注于细节，要看整体，看范围 设计时判断可行性，不确定就调研一下 设计要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 抽奖活动设计 接口列表： 奖品列表： 对应奖品中奖几率 活动有效时长：活动上线及结束 调用抽奖接口：返回抽奖结果 兑奖的能力：怎么兑换奖品 抽奖资格校验 看完流程图后的想法： 全局思维还不够，没有以业务增长的角度看问题，分享没想到。统计分析没想到 全面 完整 闭环 这三点都没想到 核心数据结构设计 保存的数据结构 数组结构 分图层保存，低级图层在前面，渲染的时候按图层渲染 数据同步 双向绑定数据，左边组件的数据和右边编辑器里一致 图层设计 每个图层一个数组。数组里是组件 思考： 未考虑到Vnode形式，以前从来就没有用vnode来代替自己的DSL，这是一种新的思路，给我启发了很多。 用vuex来保存数据的话，应该是拖动组件的时候一直延时调用mutation来更新右边的属性列表。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/mazy/":{"url":"pages/mazy/","title":"Mazy","keywords":"","body":"mazy - 学习记录 Week01 Week01-作业-整体架构设计 V1.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/mazy/01-week01.html":{"url":"pages/mazy/01-week01.html","title":"Week01","keywords":"","body":"第一周笔记 收获 自身角度 我目前职位是高级前端工程师, 从今年开始, 开始承担项目负责人的职务, 从老师的讲课中发现大部分还是跟自己的现状比较吻合 虽然说是项目负责人, 但是考虑问题的角度更多还是以前端程序员的角度出发, 这个好做,这个不好做, 这个会有什么问题等等的考虑 在开需求评审的时候很少在整体的角度思考问题, 既需求是不是合理, 做的东西是否有输出有体现, 如何更好的交互等 在开发过程中, 要保证准时上线, 那么可能会跟产品有分歧, 砍掉需求等 总体来说, 目前的状态大多数还是跟产品对立的形式, 并没有统一战线, 使项目向着更好更稳定的方向发展 项目 项目的整体划分 B端和编辑器 biz-editor-FE biz-editor-server C端 H5(SSR) 管理系统 admin-FE admin-server 组件库 统计服务 三方免费pv/uv 自研自定义事件统计服务 为什么这样分 前后端分离, 单独开发, 整体提升工作效率, 这个是必然, 术业有专攻 一个系统从来都不是单纯存在的, 有前台必然有后台, 所以有BC端, 必然有管理系统 组件库, 这个可以复用, 当多个系统同时使用同一套组件库,可以直接看文档传参数直接使用. 或者可以有专门人员来维护, 减少开发成本 统计服务,几乎所有网站都要用到统计, 简单的pv和uv,这个比较浅显, 那么还有一些业务较复杂的统计, 三方很难普及到, 或者说收费高, 那么就需要自己实现一套, 满足于系统业务的统计服务 数据结构 考虑因素 是否可扩展,个人认为比较重要 结构是否清晰, 或者大多数人可以接受 数据结构本身的考量, 既哪些数据结构具有什么样的特点 实现方案 在设计组件或者store的时候都需要考虑扩展性问题 怎么传, 怎么做兼容 如何合并 结构清晰, 数组, 对象的特点, 在设计结构的时候, 是否冗余, 本来可以使用结构特点就可以实现, 最后又加了另外的结构来解决问题, 一直下去, 其他人很难维护 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/renderman/":{"url":"pages/renderman/","title":"Renderman","keywords":"","body":" .logo{ margin-bottom:15px; height:60px; line-height:60px; } .logo img{ height:100%; vertical-align:middle; } .logo img+span{ vertical-align:middle; margin-left:10px; font-size:35px; font-weight:700; color:#459ece; } h2{font-size:0!important;visibility:hidden;} h3{ position:relative; text-indent:1em; } h3:before{ content:\"\"; position:absolute; top:0;left:0; width:0.15em;height:100%; background-color:#459ece; } RENDERMAN _ week01 “永远选择最简单的实现方案” 乐高项目的需求分析思考 乐高项目的整体技术方案思考过程 乐高项目的整体技术方案文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/ricky94/":{"url":"pages/ricky94/","title":"Ricky94","keywords":"","body":"Ricky94 - 学习笔记 第一周：需求分析和架构设计：做什么，如何做？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/ricky94/01-第一周.html":{"url":"pages/ricky94/01-第一周.html","title":"第一周","keywords":"","body":"第一周：需求分析和架构设计：做什么，如何做？ 需求设计 架构脱离不了业务。要做好架构必须要深入理解需求、参与需求、看透需求背后的业务本质。 PV（Page View）：即页面浏览量或点击量，用户每一次对网站中的每个网页访问均被记录一个PV。用户对同一个页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。 UV（Unique Visitor）：是指通过互联网访问、浏览这个网页的自然人。一天内同一个访客多次访问仅计算一个UV。 自定义事件：通过代码埋点，对用户行为进行追踪，完成对用户行为细节的记录。 架构设计 分析需求，确定需要创建的项目 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/yhtx1997/":{"url":"pages/yhtx1997/","title":"Yhtx1997","keywords":"","body":"yhtx1997 - 课程记录 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/yhtx1997/01-第一周作业.html":{"url":"pages/yhtx1997/01-第一周作业.html","title":"第一周作业","keywords":"","body":"幕客乐高技术方案 目录 需求 总体需求 原始需求：用户可按自身需求生成页面，并可分享出去供其他人浏览 确定范围 用户可编辑页面（后台编辑） 其他人可浏览（H5页面） 可分享（埋点，数据分析） 模块设计 模块拆分和关系图；关键功能职责；特殊模块重点说明 模块拆分 后台编辑项目 后台编辑接口项目 后台管理项目 后台管理接口项目 H5 项目 - SSR 公用组件库项目 公用接口项目 埋点项目 特殊模块说明 后台管理和编辑拆两个项目的原因：管理员可以使用用户的操作，以及用户没有的操作将敏感操作和正常操作，尽量隔离 多拆一个公用接口项目：后台管理和编辑，有高度相似接口，例如都支持新增、编辑、删除页面等基础操作 公用组件库：后台管理和编辑有相似组件（例如：页面列表），后台和H5有相似组件（例如：后台预览和H5显示） H5只拆一个项目：没必要再多拆一个后端接口项目（后端预览可通用过来），且页面数据及渲染在编辑后，页面展示结果唯一，以及可能需要较好的 SEO优化，故此使用 SSR 可提升首屏速度，及SEO 关系图 数据结构 数据结构原则 使用 VNode 规范（拓展性好） 有序数据使用数组（数组是一组有序的相同类型的数据） 尽量使用引用关系，不要冗余（保证数据唯一性） 最外层一定要是对象（方便拓展新的顶级参数） 数据结构示例 { page: { // 与H5页面渲染相关的字段 id: \"加密后的用户id-加密后的创建时间-随机标识码\"， title: \"标题\", setting: { // 页面功能性配置 }, style: { // 页面样式配置 }, componets: [ { tag: '组件名', id: '加密后的(用户id+随机标识码)', flag: '', // 模板类（直接返回子元素），组件类（子元素外层包了一层），内容类（最底层的文本显示） data: { // 当前组件的数据 }, children: [ // 子组件：无限套娃 { tag: '组件名', id: '加密后的(用户id+随机标识码)', flag: '', // 模板类（直接返回子元素），组件类（子元素外层包了一层），内容类（最底层的文本显示） data: { // 当前组件的数据 }, children: [ // 子组件 ], setting: { // 组件功能性配置 }, attrs: { style: { // 组件样式 } // 标签属性 }, event: { // 要触发的事件 } } ], setting: { // 组件功能性配置 }, attrs: { style: { // 组件样式 } // 标签属性 }, event: { // 要触发的事件 } } ] }, setting: { // 设置 }, status: { currentComponentId: -1 // 当前选中组件，默认整个页面 } } 数据流转关系图 拓展性 新组件怎么拓展 新功能怎么拓展 数据结构怎么拓展 引导讨论拓展性（大家一起讨论，不是某个人单独就能确定的） 开发提效 复用性，易用性 运维保障 如何保证系统；线上服务运维，安全，监控，报警，服务拓展性 公司有自研运维保障服务，要熟悉自研的 公司没有自研运维保障服务，要熟悉常见服务商提供的 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/yhtx1997/01-第一周笔记.html":{"url":"pages/yhtx1997/01-第一周笔记.html","title":"第一周笔记","keywords":"","body":"笔记 内容分享目录格式 标题 讲师 将收获什么 主要内容 关键词 学习方法 注意事项 架构师原则及思维 总体思维导向 以业务价值为前提（首先要有），提升价值为最终目的（然后增加），并铺垫好今后可能发展的基础（最后发展） 需求 > 设计 > 开发 通过技术手段保证业务的增长 技术为业务服务 设计时判断可行性，不确定就调研 设计时要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 脱离业务的架构就是耍流氓。架构师需要深入理解需求、参与需求、看透需求背后业务本质。 如何深入理解需求 三方面考虑：全面、 完整、 闭环 拿到需求 -> 理解需求 -> 前因后果（哪里来那里去） -> 整体流程 -> 业务增长 -> 回顾总结 实际使用场景：从用户角度思考问题，简单好用 产品及运营角度： 1. 产品第一，运营第二；2. 看重投入产出比，方便做决策 统计，汇总，分析，基础建设； 风险控制、 稳定性;系统稳定才能保证有人长期使用 架构师职责：深入理解需求，用软件把业务模拟出来。保证稳定运行，持续增长。技术永远为业务服务。 如何做技术设计 基于业务 做方案先不要太过关注细节，要看整体，确定范围都哪些 拓展性，可行性 可复用部分 实现成本（永远选择最简单的实现方案） 不确定就调研 技术方案目录示例 标题 目录 需求 范围 模块设计 数据结构 拓展性保证 开发提效 运维保障 数据结构设计思路 拓展性字段的考虑，字段名称的统一性，字段尽可能的少 VNode(将组件或元素用数据描述出来) 单一数据源存储所有的数据（索引类尽量使用引用，避免多数据源强关联关系） 数据流的周期 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/yhtx1997/02-第二周作业.html":{"url":"pages/yhtx1997/02-第二周作业.html","title":"第二周作业","keywords":"","body":"脚手架执行流程 根据流程反推如何开发 npm 包项目要有bin 配置指向js文件 项目发布到 npm 官网 js 入口文件内指定使用 node 执行自己 #!/usr/bin/env node 安装到 node 目录下的 node_modules 环境变量软连接到 node 目录下的 node_modules/脚手架/入口文件 疑问 问： @vue/cli 后为什么使用命令是 vue ？ 答：因为 @vue/cli 只是 npm 包名，实际命令是在 package.json 的 bin 属性配置 问：全局安装 @vue/cli 时发生了什么？ 答：首先 npm 下载包文件到 node 安装目录下的 node_modules，然后将 package.json 文件 bin 属性中的命令配置成环境变量，之后就可以使用相关命令了 问：为什么 vue 命令指向了一个js文件，我们确可以直接运行它？ 答： 因为在 js 文件头部，我们声明了要用 node 去执行当前文件，所以实际上是：系统通过 node 执行 js 文件 基于 lerna 发布的脚手架（无功能） https://www.npmjs.com/package/fe-lazy-cli https://www.npmjs.com/package/@fe-lazy-cli/core https://www.npmjs.com/package/@fe-lazy-cli/utils Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/yhtx1997/02-第二周笔记.html":{"url":"pages/yhtx1997/02-第二周笔记.html","title":"第二周笔记","keywords":"","body":"笔记 内容分享目录格式 标题 讲师 将收获什么 主要内容 关键词 学习方法 注意事项 脚手架架构设计和框架搭建 总体思维导向 需求分析，架构设计，开源项目的深入研究 学习方法 掌握原理 独立思考 总结反思 深度剖析优秀开源项目，由表及里，由浅入深 视角切换，多切换架构师视角，全方位思考 脚手架开发必要性 提升研发效能 脚手架核心价值 将研发过程 自动化、标准化、数据化 自动化： 项目重复性代码复制粘贴/git操作/发布上线 标准化： 项目创建/git flow/发布流程/回滚流程 数据化： 研发过程系统化、数据化；使得研发过程可量化 和自动构建工具的区别 不满足需求：jenkins、travis通常在git hooks中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动化、本地git操作自动化等 定制复杂：jenkins、travis定制过程需要开发插件，其过程较为复杂，需要使用Java语言，对前端同学不够友好 什么是脚手架 脚手架就是命令行操作系统的客户端，例如： vue create vue-test-app --force -r https://registry.npm.taobao.org 命令的组成 主命令：vue 子命令 command: create 子命令参数 command 的 param: vue-test-app 配置 option： -r --force 配置参数 option 的 param：https://registry.npm.taobao.org 脚手架执行流程 根据流程反推如何开发 npm 包项目要有bin 配置指向js文件 项目发布到 npm 官网 js 入口文件内指定使用 node 执行自己 #!/usr/bin/env node 安装到 node 目录下的 node_modules 环境变量软连接到 node 目录下的 node_modules/脚手架/入口文件 疑问 问： @vue/cli 后为什么使用命令是 vue ？ 答：因为 @vue/cli 只是 npm 包名，实际命令是在 package.json 的 bin 属性配置 问：全局安装 @vue/cli 时发生了什么？ 答：首先 npm 下载包文件到 node 安装目录下的 node_modules，然后将 package.json 文件 bin 属性中的命令配置成环境变量，之后就可以使用相关命令了 问：为什么 vue 命令指向了一个js文件，我们确可以直接运行它？ 答： 因为在 js 文件头部，我们声明了要用 node 去执行当前文件，所以实际上是：系统通过 node 执行 js 文件 脚手架开发流程 开发流程 创建 npm 项目npm init -y 创建入口文件，并在顶部声明执行方式#!/usr/bin/env node 配置 bin 属性 编写代码 发布 npmnpm publish 使用流程 安装npm install -g 脚手架 使用脚手架 <> [] 脚手架开发难点 分包：复杂的系统模块拆分 命令注册 参数解析 options 全称 options 简称 option 参数 params 命令行交互 日志打印 命令行文字变色 网络通信 文件处理 帮助文档 npm 本地开发调试 npm link 查找环境变量 which 变量名 在 npm 包目录下将当前包链向 全局环境变量 npm link 将项目 node_modules 目录下指定npm 包链向 全局环境变量 npm lint 要使用的npm包名 在全局环境变量中取消 npm 的 link 指向 npm unlink // 当前目录 npm unlink 包名 // 当前项目 node_modules 目录下指定包名 lerna 介绍（多 package 项目管理） Lerna 是一个用于优化管理基于 git + npm 的多 package 项目的工具 node原生命令注册 参数解析 node 核心库 process argv 属性：所有命令行 命令参数数组 原生脚手架开发痛点 痛点一：重复操作 多 package 本地 link 多 package 依赖 多 package 单元测试 多 package 代码提交 多 package 代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互版本依赖的升级 package 越多，管理复杂度越高 lerna 优势 大幅减少重复操作 提升操作标准化项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 babel vue-cli create-react-app 都在使用 lerna 管理项目 lerna 开发流程 项目初始化 初始化 npm 项目 安装 lerna lerna init 初始化项目 创建package lerna create 创建package lerna add 安装依赖 lerna link 链接依赖 脚手架开发和测试 lerna exec 执行 shell 脚本 lerna run 执行 npm 命令 lerna clean 清空依赖 lerna bootstrap 重装依赖 脚手架发布上线 lerna version bump version lerna changed 查看上版本以来的所有变更 lerna diff 查看 diff lerna publish 项目发布 注意事项： lerna publish 发布时会自动执行： git add package-lock.json ，所以 package-lock.json 不要加入 .gitignore 先创建远程仓库，并且同步一次 master 分支 执行 lerna publish 前先完成 npm login 如果发布的 npm 包名为： @xxx/yyy 的格式，需要先在 npm 注册名为：xxx 的 organization，否则可能会提交不成功 发布到 npm group 时默认为 private，所以我们需要手动在 package.json 中添加如下配置: \"publishConfig\": { \"access\": \"public\" } lerna exec 和 lerna run --scope 属性后添加的是包名，而不是 package 的路径，这点和 lerna add 用法不同 lerna clean 只会删除 node_modules ，不会删除 package.json 中的依赖 lerna link 如果未发布上线，需要手动将依赖添加到 package.json 再执行 lerna link lerna add 第一个参数：添加 npm 包名 第二个参数：本地 package 的路径 选项： --dev：将依赖安装到 devDependencies，不加时安装到 dependencies lerna add [loc] --dev lerna init 会初始化 git 但是不会创建 .gitignore VSCode调试技巧 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/":{"url":"pages/い狂奔的蜗牛/","title":"い狂奔的蜗牛","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/01.Node.js中经典算法（一）.html":{"url":"pages/い狂奔的蜗牛/01.Node.js中经典算法（一）.html","title":"01.Node.Js中经典算法（一）","keywords":"","body":"Node.js中经典算法（一） ​ 给定一个路径和目录，返回在这个路径下所有可能存在当前目录的路径组合算法，摘自Node模块算法 一、声明一个保存node_modules逆序字符串(seludom_edon)的ASCII编码数组 // seludom_edon对应的编码 const nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ]; 二、算法 Module._nodeModulePaths = function(from) { // 得到绝对路径 from = path.resolve(from); // 如果是根目录，直接返回一个['/node_modules'] if (from === '/') return ['/node_modules']; // 存放所有可能存在node_modules的绝对路径数组 const paths = []; // 用户筛选异常路径中可能包含的node_modules目录 var p = 0; var last = from.length; // 路径的长度 // 反向遍历 for (var i = from.length - 1; i >= 0; --i) { // 得到最后一个字符 const code = from.charCodeAt(i); // CHAR_FORWARD_SLASH === '/' === 47 // 判断当前的编码是否为47 if (code === CHAR_FORWARD_SLASH) { if (p !== nmLen) // 比对完一个目录 判断目录是否为node_modules,如果不是则拼接一个/node_modules路径放入paths数组 paths.push(from.slice(0, last) + '/node_modules'); last = i;// 记录当前比对到的字符为'/'的位置(剩余未比对路径的长度+1)，用于拼接上一级目录+'/node_modules' // 重置当前字符比对node_modules逆序时的相等相等的字符长度 如/a/modules_modules会跳过/a/modules_modules // 直接加入paths,而是比对到/a后拼接得到一个/a/modules_modules加入paths目录 p = 0; } else if (p !== -1) { if (nmChars[p] === code) { // 判断当前获取的字符是否和node_modules逆序相同，用于匹配node_modules ++p; } else { p = -1; } } } // 最后追加一个根目录下的node_modules paths.push('/node_modules'); return paths; }; 示例：'/a/b/c' 结果：['/a/b/c/node_modules','/a/b/node_modules','/a/node_modules','/node_modules'] Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/02.Node.js中使用ES Module的两种方式.html":{"url":"pages/い狂奔的蜗牛/02.Node.js中使用ES Module的两种方式.html","title":"02.Node.Js中使用ES Module的两种方式","keywords":"","body":"Node.js中使用ES Module的两种方式 方式一 ​ 使用webpack对源码进行构建，使用babel对js进行处理使其适应于低版本node 依赖： 一、package.json \"devDependencies\": { \"@babel/core\": \"^7.12.10\", \"@babel/plugin-transform-runtime\": \"^7.12.10\", \"@babel/preset-env\": \"^7.12.11\", \"@babel/runtime-corejs3\": \"^7.12.5\", \"babel-loader\": \"^8.2.2\", \"webpack\": \"^5.11.0\", \"webpack-cli\": \"^4.3.0\" } npm scripts \"scripts\": { \"build\": \"webpack\", \"dev\": \"webpack --watch\" }, 二、webpack.config.js配置 const path = require('path'); module.exports = { entry: './bin/core.js', // 入口文件 mode: 'development', // 开发模式，development => 开发模式 production =》 生产模式 output: { // 输出 path: path.join(__dirname, '/dist'), // 输出目录 filename: 'core.js' // 输出的文件名 }, target: 'node', // 默认web，因为需要使用到node原生模块，所以需要更改为node module: { rules: [{ // 配置babel-loader test: /\\.js$/, // 处理js exclude: /(node_modules|dist)/, // 排除node_modules和dist目录 use: { loader: 'babel-loader', // 使用babel对js进行低版本兼容处理 options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { 'corejs': 3, 'regenerator': true, \"useESModules\": true, 'helpers': true }] ] } } }] } } 方式二 ​ 通过Node原生支持ES Module 步骤一、 更改js文件后缀为.mjs 步骤二、 import js的时候，如import './core';不能省略后缀名，需要写成import './core.mjs'; 执行：node --experimental-modules ./bin/index.mjs 步骤三、 由于是实验性质特性，所以需要配置开启 --experimental-modules，否则会报如下错误 internal/modules/cjs/loader.js:821 throw new ERR_REQUIRE_ESM(filename); ^ Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: /Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin/index.mjs at Object.Module._extensions..mjs (internal/modules/cjs/loader.js:821:9) at Module.load (internal/modules/cjs/loader.js:643:32) at Function.Module._load (internal/modules/cjs/loader.js:556:12) at Function.Module.runMain (internal/modules/cjs/loader.js:839:10) at internal/main/run_main_module.js:17:11 开启后会报一个警告，在node版本v14.x.x以后也支持该特性，不会显示警告信息 (node:59215) ExperimentalWarning: The ESM module loader is experimental. Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/03.sim-cli核心图集.html":{"url":"pages/い狂奔的蜗牛/03.sim-cli核心图集.html","title":"03.Sim Cli核心图集","keywords":"","body":"第四周更新 - sim-cli核心图集 一、sim-cli脚手架架构图 二、sim-cli脚手架核心流程图 第四周扩充 三、sim-cli脚手架依赖示意图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/04.第四周-Node.js多进程源码分析.html":{"url":"pages/い狂奔的蜗牛/04.第四周-Node.js多进程源码分析.html","title":"04.第四周 Node.Js多进程源码分析","keywords":"","body":"第四周作业 - Node源码分析 一、总结： exec/execFile/spawn/fork的区别 exec：原理是调用/bin/sh -c执行我们传入的shell脚本，只做了参数处理就调用了execFile execFile：原理是直接执行我们传入的file和args，底层调用spawn创建和执行子进程，并建立了回调，一次性将所有的stdout和stderr结果返回 spawn：原理是调用了internal/child_process，实例化了ChildProcess子进程对象，再调用child.spawn创建子进程并执行命令，底层调用了child._handle_spawn执行process_wrap中的spawn方法，此时才创建了子进程。执行过程是异步的，执行完毕后通过PIPE进行单向数据通信，通信结束后子进程发起onexit回调，同时Socket会执行close回调 fork：原理是通过spawn创建子进程和执行命令，通过setupchannel创建IPC通信，用于父子进程之间双向通信 data/error/exit/cloes回调的区别 data：主进程读取数据过程中通过onread=onStreamRead发起回调 error：命令执行失败后发起回调 exit：子进程关闭完成后发起回调 close：子进程所有Socket实例全部关闭后发起回调（stdin,stdout,stderr） Stdout close /stderr close：特定的PIPE读取完成后调用onReadableStreamEnd关闭socket时发起的回调 二、源码分析思维导图 exec： execSync： Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/05.第四周-import-local源码分析及node模块加载流程源码分析.html":{"url":"pages/い狂奔的蜗牛/05.第四周-import-local源码分析及node模块加载流程源码分析.html","title":"05.第四周 Import Local源码分析及Node模块加载流程源码分析","keywords":"","body":"第四周作业扩展 - import-local源码分析及node模块加载流程源码分析 一、总结 分析入口lerna源码 模块的完整查找流程只会执行一次，执行过后模块会以模块名/查找路径为key，模块真实路径为value缓存 Module._resolveFilename()为node模块加载流程实现核心方法，require等在此基础是进一步封装 import-local以包名（lerna）和入口文件（cli.js）调用resolveCwd.silent(path.join(pkg.name, relativePath))得到lerna源码中cli.js的绝对路径：/Users/snail/Desktop/code/lego/lerna/core/lerna/cli.js 二、import-local源码分析及node模块加载流程源码分析思维导图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/06.第五周-如何解决安装模板时控制台动画闪烁问题.html":{"url":"pages/い狂奔的蜗牛/06.第五周-如何解决安装模板时控制台动画闪烁问题.html","title":"06.第五周 如何解决安装模板时控制台动画闪烁问题","keywords":"","body":"如何解决安装模板时控制台动画闪烁问题 原因分析： ​ 在我们使用cli-spinner给我们的脚手架添加自己的安装动画时，由于我们使用了npminstall作为我们安装npm包的依赖，npminstall本身在安装包的时候就有安装动画。所以我们自己给脚手架添加的动画和npminstall内置的有冲突，导致控制台交替输出，从而导致闪烁。后续思路为去掉npminstall动画出发，保留我们自己的动画为目的进行。 步骤一： ​ 查看npminstall配置，是否有去掉动画配置。通过查看使用说明，未能找到对应的配置。 await npminstall({ // install root dir root: process.cwd(), // optional packages need to install, default is package.json's dependencies and devDependencies // pkgs: [ // { name: 'foo', version: '~1.0.0' }, // ], // install to specific directory, default to root // targetDir: '/home/admin/.global/lib', // link bin to specific directory (for global install) // binDir: '/home/admin/.global/bin', // registry, default is https://registry.npmjs.org // registry: 'https://registry.npmjs.org', // debug: false, // storeDir: root + 'node_modules', // ignoreScripts: true, // ignore pre/post install scripts, default is `false` // forbiddenLicenses: forbit install packages which used these licenses }); 步骤二： ​ 因为没有文档说明如何去掉，于是去翻看源码，查看local_install.js文件，找到默认动画相关核心代码如下 local_install.js module.exports = async options => { options = formatInstallOptions(options); options.spinner && options.spinner.start(); ... } format_install_options.js module.exports = function formatInstallOptions(options) { options.trace = !!options.trace; if (options.trace) { // make sure detail enable when trace enable options.detail = true; } options.spinner = options.detail ? null : ora(); ... } 通过分析代码发现和默认安装动画相关的分别为两个在文档中未提及的参数trace、detail，和ora方法，其中ora方法内部对cli-spinner动画进行了封装，所以当detail为true的时候options.spinner为null，而options.spinner引用着一个cli-spinner中Spinner的实例，当options.spinner为null时，这个时候将没有动画。所以我们在执行npminstall方法的时候传入detail为true，如：npminstall({detail:true})从而达到我们希望去掉npminstall动画的目的。需要注意的是如果我们需要npminstall的默认安装动画，我们不能在执行npminstall方法的时候传入trace为true，否则传入的detail将会被覆盖为true。 步骤三： ​ 测试 trace=false，有加载动画，控制台输出如下 ✔ Installed 1 packages ✔ Linked 1 latest versions ✔ Run 0 scripts ✔ All packages installed (1 packages installed from npm registry, used 631ms(network 630ms), speed 6.18KB/s, json 1(3.9KB), tarball 0B) 测试 trace=true，npminstall代码内部会将options.detail=true此时无加载动画，控制台输出如下 [1/1] imooc-cli-dev-template-vue2@1.0.0 installed at node_modules/_imooc-cli-dev-template-vue2@1.0.0@imooc-cli-dev-template-vue2 All packages installed (1 packages installed from npm registry, used 453ms(network 451ms), speed 8.64KB/s, json 1(3.9KB), tarball 0B) [trace] 454ms &#x1F3CA; memory usage, rss: 50.16MB, heapTotal: 31.02MB, heapUsed: 16.84MB, external: 1.56MB; &#x1F4BB; os free: 41.12MB, os load: 4.5, 5.1, 5.3; &#x1F3C3; cpu usage, user: 0, system: 0 通过设置detail为true动画是可以去掉了，但是安装信息任然存在，通过查看代码发现最终结果日志在local_install.js 569行打印。代码如下 if (options.spinner) { options.spinner.succeed(util.format(...logArguments)); } else { options.console.info(...logArguments); } 思考：如何让npminstall保持沉默，不输出任何信息？ 方式一： ​ 改local_install.js源码，手动改肯定是不行的，可否脚手架代码更改？因为js是动态语言/解释执行，实际上通过找到npminstall包，然后找到local_install.js，通过nodejs提供的文件读写能力干掉以上代码应该可行。细思极恐啊！！！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/07.第五周-readline源码阅读及实现简易版readline.html":{"url":"pages/い狂奔的蜗牛/07.第五周-readline源码阅读及实现简易版readline.html","title":"07.第五周 Readline源码阅读及实现简易版Readline","keywords":"","body":"readline源码阅读及实现简易版readline 一、readline阅读思维导图 二、简版readline实现 function readline(callback) { function onKeyPress(s) { output.write(s); line += s; switch (s) { case '\\r': input.pause(); // 会清空输入时output输出的内容 callback(line.slice(1)); break; } } const input = process.stdin; const output = process.stdout; let line = ''; // 记录输入的内容 input.on('keypress', onKeyPress) emitKeypressEvents(input); input.setRawMode(true); input.resume(); } function emitKeypressEvents(stream) { function onData(chunk) { g.next(chunk.toString()); } const g = emitKeys(stream); g.next() stream.on('data', onData); // 输出一个大于符号 g.next('>'); } function* emitKeys(stream) { while (true) { const ch = yield; stream.emit('keypress', ch); } } readline((res) => { console.log('>' + res); }); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/08.第五周-类似inquirer列表类型交互实现.html":{"url":"pages/い狂奔的蜗牛/08.第五周-类似inquirer列表类型交互实现.html","title":"08.第五周 类似Inquirer列表类型交互实现","keywords":"","body":"类似inquirer列表类型交互实现 一、源码设计思维导图 ​ 二、源码 const EventEmitter = require('events'); const readline = require('readline'); const MuteStream = require('mute-stream'); const {fromEvent} = require('rxjs'); var cliCursor = require('cli-cursor'); const ansiEscapes = require('ansi-escapes'); const options = { type: 'list', name: 'userName', message: '请选择你的名字', choices: [{ name: '张三', value: '张三' }, { name: '李四', value: '李四' }, { name: '王五', value: '王五' }] }; class List extends EventEmitter { constructor(list) { super(); this.type = options.type; this.name = options.name; this.message = options.message; this.choices = options.choices; this.input = process.stdin; // 对标准输出流进行一次包装 const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; // Interface实例 this.rl = readline.createInterface({ input: this.input, output: this.output }); // 当前选中位置 用于光标位移 this.selected = 0; // 列表高度 this.height = 0; // 监听按键按下事件 this.keypress = fromEvent(this.rl.input, 'keypress').forEach(this.onKeyPress); // 是否已经选中完毕 this.haveSelected = false; } onKeyPress = (keymap) => { const key = keymap[1]; if (key.name === 'down') { // 下箭头 this.selected++; if (this.selected === this.choices.length) { this.selected = 0; } this.render(); } else if (key.name === 'up') { // 上箭头 this.selected--; if (this.selected === -1) { this.selected = this.choices.length - 1; } this.render(); } else if (key.name === 'return') { this.haveSelected = true; this.render(); this.close(); // 派发给程序开发者的 this.emit('exit', this.choices[this.selected]); } } close() { // this.input.pause(); this.output.unmute(); this.rl.output.end(); //this.rl.close();内部会调 this.rl.pause(); 会调 this.input.pause(); // this.rl.pause(); this.rl.close(); cliCursor.show(); } // 渲染列表 render() { cliCursor.hide(); // 让用户可以输入 this.output.unmute(); this.clean(); // 输出列表 this.output.write(this.getContent()); // 用户不能继续输入 this.output.mute(); } // 获取输出内容 getContent() { if (!this.haveSelected) { // 用户还没选择结束 // 加粗无效 let content = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choice, index) => { // 是否为当前选中项，高亮显示，因为除了最后一个选项外，每一项后面需要加入\\n换行 if (index === this.selected) { if (index === this.choices.length - 1) { // 最后一行 不要加\\n content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } else { // 不是最后一行，添加\\n content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } } else { // 没有选中 除了最后一个选项外，每一项后面需要加入\\n换行 if (index === this.choices.length - 1) { // 最后一行 不要加\\n content += ' ' + choice.name + '\\n'; } else { // 不是最后一行，添加\\n content += ' ' + choice.name + '\\n'; } } }); // 空行 询问标题占两行 this.height = this.choices.length + 2; return content; } else { // 输出给使用者看的 const name = this.choices[this.selected].name; return '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; } } // 清屏 clean() { const emptyLines = ansiEscapes.eraseLines(this.height); this.output.write(emptyLines); } } function prompt(options) { return new Promise((resolve, reject) => { try { const list = new List(options); list.render(); // 添加退出监听 list.on('exit', function (result) { resolve(result); }); } catch (e) { reject(e); } }); } prompt(options).then((result) => { console.log(result); } ); 思考？ ​ inquirer的list在用户选择时没有光标，而自实现的有光标。如何去掉？ 答案： ​ 使用cli-cursor包提供的hide和show方法完成光标的隐藏与显示（从阅读inquirer源码获得） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/09.第六周-ejs源码分析.html":{"url":"pages/い狂奔的蜗牛/09.第六周-ejs源码分析.html","title":"09.第六周 Ejs源码分析","keywords":"","body":"ejs源码分析 收获一 ​ 简单转义方法实现代码 // 对&<>'\"进行转义 var _ENCODE_HTML_RULES = { '&': '&amp;', '': '&gt;', '\"': '&#34;', \"'\": '&#39;' }; var _MATCH_HTML = /[&<>'\"]/g; function encode_char(c) { return _ENCODE_HTML_RULES[c] || c; } exports.escapeXML = function (markup) { return markup == undefined ? '' : String(markup) .replace(_MATCH_HTML, encode_char); }; 收获二 ​ 对一个字符串按照特定方形进行拆分算法 parseTemplateText: function () { var str = this.templateText; // ` var pat = this.regex; // new Regex('(||-%>|_%>)') var result = pat.exec(str); var arr = []; var firstPos; // 如果匹配到结果进入继续拆分配配 while (result) { firstPos = result.index;// 匹配到的开始位置 if (firstPos !== 0) { arr.push(str.substring(0, firstPos));// 匹配到的结果位置索引不为0，则将索引之前的字符串截取添加到数组中 str = str.slice(firstPos);// 从匹配到的位置开始截取字符串 } arr.push(result[0]); // 将匹配到的结果添加到数组 str = str.slice(result[0].length); // 从匹配到结果的长度处截取剩余的字符串 //匹配一次之后的结果为： user.name %> result = pat.exec(str);// 对剩余的字符串进行再次匹配处理 } // 如果没匹配到但是字符串还有值，则直接添加到数组 if (str) { arr.push(str); } return arr; }, ​ 收获三 ​ fn.apply和fn.call都用于改变方法内部的this指向，第一个参数为this指向对象，第二个参数。其中apply第二个参数为数组，call的2-n为参数，对应传给形参。 收获四 ​ with的简要用法 收获五 ​ ejs三种使用方式执行流程 总结： ​ ejs中最为核心的为templ.compile()方法，ejs.render、ejs.renderFile底层都调用compile()，只是针对不同的场景进行了不同的方法暴露，其中render可通过传入的options中设置cache=true提高效率，当opts.cache为true时，如果已经生成了函数，则直接返回，否则将重新生成函数。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/い狂奔的蜗牛/10.第六周-require源码分析.html":{"url":"pages/い狂奔的蜗牛/10.第六周-require源码分析.html","title":"10.第六周 Require源码分析","keywords":"","body":"require源码分析 - v12.5.0 一、require是如何缓存的？ 缓存模块路径： 通过执行文件的目录和require(path)中的path拼接得到一个路径，在后续查找到模块真实路径的情况下会以之前拼接的路径为key，正式路径为value进行缓存，如： { \"/Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin\\u0000./ejs\": \"/Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin/ejs/index.js\" } 缓存模块： 以上一步拿到的真实文件路径为key，创建的module实例为value缓存到Module._cache对象中 Module._cache = Object.create(null); // 缓存 Module._cache[filename] = module; 二、require支持加载的文件类型？ .js 读取文件内容，移除utf-8 BOM头和移除脚手架中定义的#!/usr/bin/env node，将内容包装在一个函数内进行自执行并传入exports、require、module、filename、dirname； .json 读取文件内容 调用JSON.parse(content)转成json对象后返回； .node .mjs node 14+版本支持，如果低版本需要指定开启 --experimental-modules，否则将报错； 如果文件没有指定文件类型，则按js处理； 注：一个文件中多次加载同一个模块，后面的将使用第一次加载的缓存模块； 三、源码分析思维导图 ​ 包含自定义模块，node_modules下的模块和内置模块 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/一点/":{"url":"pages/一点/","title":"一点","keywords":"","body":"一点 - 作业 第一周 01-需求和架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/一点/01-需求和架构设计.html":{"url":"pages/一点/01-需求和架构设计.html","title":"需求和架构设计","keywords":"","body":"慕课乐高架构方案设计文档 需求分析 需求分析思维导图 范围 从需求上我们大致可以分为 B端（作者端） H5 SSR（用户端） 后台管理系统（管理端） 三个端 而前端开发部分又可以分解成三个项目 editor-fe h5-ssr admin-fe 后端项目分也分解成三个项目 editor-server h5-server admin-server 模块设计 独立业务组件库 编辑器画布使用的组件和渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 作品的数据结构 思路 每个尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 组件扩展 编辑器组件的扩展（比如以后增加其它组件，视频组件，音频组件，抽奖组件等等） 页面信息的扩展（比如以后增加微信/微博/QQ分享） 其他扩展（比如埋点统计大数据分析） 开发提效 实现平滑发布增加用户体验感 脚手架：创建发布 组件平台 运维保障 错误日志收集 监控和报警 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/六个周/":{"url":"pages/六个周/","title":"六个周","keywords":"","body":"学生-六个周-简介 2021年的全年学习目标，就围绕着这门课程展开了。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/六玥/":{"url":"pages/六玥/","title":"六玥","keywords":"","body":"六玥学习分享 2021年的全新征程 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/六玥/01-第一周笔记和作业.html":{"url":"pages/六玥/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"需求 乐高编辑器 范围 整体设计，架构设计，没有细节 C端用户使用的手机端H5 C端用户通过H5端可以通过作品了解详情，并且可以进行转发分享，通过埋点可以了解相关的数据统计。 开发方式：SSR B端用户或者个人所使用的PC端编辑器 B端用户或者个人可以通过乐高编辑器编辑、发布自己想要的广告海报和宣传页，生成对应的H5链接供C端用户使用 开发方式：前后端分离，前端：editor-fe，后端：editor-server 管理员使用的后台管理系统 B端用户和个人可以在后台管理系统进行作品的管理，如发布、下线、用户权限的管理、相关数据的统计等， 开发方式：前后端分离，前端：admin-fe，后端：admin-server 模块设计 特殊的模块重点说明： 组件库 独立第三方，同时用于编辑器和H5，因为编辑器画布使用的组件的渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 作品的数据结构 思路： 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store的数据结构 { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter的数据结构 // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 数据流转关系图 见模块设计 扩展性保证 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面配置，如增加多语言、设置背景 扩展其他功能，如大数据分析和计算等 开发提效 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大时，基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/凹凸曼/":{"url":"pages/凹凸曼/","title":"凹凸曼","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/凹凸曼/01-Week01-作业.html":{"url":"pages/凹凸曼/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 需求 需求稳定 体验地址 范围 从需求来看，可以简单拆分成以下几个大的模块 B端和编辑器 采用前后端分离，因此可以划分为两个代码仓库 biz-editor-FE biz-editor-server 通过可视化平台拖拽等方式，可以生成作品，然后发布。 C 端 面向用户群体，因此可以高性能(使用SSR)，可以对作品进行分享，提升业务增长。 管理后台 admin-FE admin-server 平台管理，负责作品的审核，发布，以及对用户的管理等待。 独立的组件库 提升开发效率和复用，独立的 npm 包，供编辑器端和H5端使用 统计服务 单独拆分，以报表等形式展示，可以清晰的看到 PV/UV，用户人数活跃度，增长等。 需求关系 模快设计 核心数据结构 单个组件应该使用vnode规范，使用业界统一规范有助于我们少踩一些坑，并能得到扩展性较强的组件结构。vuex store 的大概结构如下： { // 作品 work: { title: '作品标题', setting: { /* 拓展配置： 如配置渠道 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转核心 根据组件的位置生成相应的数据结构 JSON，进行入库，然后在 C 端在根据对应的 JSON 对组件进行渲染 扩展性保证 预留一些字段， 后期可能多人协作开发 自定义事件的加入 研发提效 脚手架的搭建，创建发布 组件平台，方便复用 前端开发流程 运维保障 线上服务和运维服务 安全 监控与报警 服务拓展性: 基于云服务,可以随时拓展机器和配置 愿景 保证业务增长，服务于当前的业务。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/凹凸曼/02-Week02-作业.html":{"url":"pages/凹凸曼/02-Week02-作业.html","title":"Week02 作业","keywords":"","body":"脚手架原理和基本搭建 什么是脚手架 脚手架本质是一个操作系统的客户端，它通过命令执行，如： vue create vue-test-app 上面命令由三部分组成 主命令：Vue command:create command 的 parm：vue-test-app 执行此命令后，就会在对应目录下创建一个叫做 vue-test-app 的项目，并自动执行 npm install 按照对应的依赖，通常可以输入下面的命令就可以看到 vue create 支持的所有 options vue create --help 为什么要研发脚手架? 开发脚手架的核心目标就是：提升前端研发效率 在大的开发团队中，提升研发效率是非常有必要的，减少重复操作劳动，统一代码风格和结构。我们通过脚手架讲研发过程： 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚操作 数据化：研发过程系统化、数据化、使得研发过程可量化 脚手架的执行原理 脚手架的执行原理如下： 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command/options vue.js 执行 command 执行完毕退出执行 疑问&#x1F914;️ 为什么全局安装了 @vue/cli 后会添加的命令为 vue? npm install -g @vue/cli 全局安装 @vue/cli 时发生了什么？ 执行 vue 命令时发生了什么？为什么 vue 指向一个 js 文件，我们却可以通过 vue 命令去执行? 带着问题我们来一一刨析! 这里以我本地 create-react-app 脚手架为演示，在执行命令时，终端首先会执行如下命令进行查找： which create-react-app 如图，可以看到在环境变量 /usr/local/bin 目录下创建一个了叫做 create-react-app 的软链接 OK，现在让我们进入到对应的目录，看看 在对应目录下我们看到了 create-react-app 项目的目录结构，查看 pack.json 的 bin 属性，发现如下 \"bin\": { \"create-react-app\": \"./index.js\" }, 同样 @vue/cli 也是该原理，到此，我们就可以回到前面两个问题。 在全局安装 @vue/cli 、create-react-app 时，首先会创建一个软链接，然后指向它真是所在的项目目录，通过上面的图可以看到，通过全局安装会被放在 /yarn/global/node_modules/.bin/ 目录下 通过配置文件 pack.json 的 bin 文件，设置命令的名字，如 vue、create-react-app，cli 就会去执行对应的文件。我们打开 create-react-app 对应的 ./index.js 看看，在头部我们发现这么一行代码 #!/usr/bin/env node 这段代码的作用就是在环境变量中查找 node，然后用 node 去执行，到此基本回到了上面三个问题，下面来进阶一下脚手架原理 脚手架原理进阶 为什么说脚手架的本质操作系统的客户端?它和我们在PC上安装的应用/软件有什么区别？ 如何为 Node 脚手架创建别名？ 我们知道编写的脚手架JS 文件，必须在 Node 环境中运行，我们找到安装 Node 的目录发现，Node 本身就是一个可执行文件，只不过没有 GUI 可视化的操作页面，它和我们在PC上安装的应用本质没有任何区别 可以通过创建软链接的方式给脚手架创建别名 ln -s ./create-react-app create-react-app2 新起的名字叫做 create-react-app2 会指向 create-react-app，create-react-app 会指向真实的地方 用一张图总结脚手架执行的全过程. 脚手架开发流程 在之前文章 从零创建自己的脚手架 中实现了一个脚手架的简单搭建和发布，那么有那些难点没有解决呢？ 脚手架开发难点解析 分包：将复杂的系统分开成若干个模块 注册命令 vue add vue create 参数解析 optinos全称：--version、--help options简写：-V、-h 带params的optinos：--path /Users/xikun/Aotu 示例代码: vue commadn [options] 帮助文档 globale help 以 create-react-app 示例： sage: create-react-app [options] Options: -V, --version output the version number --verbose print additional logs --info print environment debug info --scripts-version use a non-standard version of react-scripts --template specify a template for the created project --use-npm --use-pnp -h, --help output usage information Only is required. A custom --scripts-version can be one of: - a specific npm version: 0.8.2 - a specific npm tag: @next - a custom fork published on npm: my-react-scripts - a local path relative to the current working directory: file:../my-react-scripts - a .tgz archive: https://mysite.com/my-react-scripts-0.8.2.tgz - a .tar.gz archive: https://mysite.com/my-react-scripts-0.8.2.tar.gz It is not needed unless you specifically want to use a fork. A custom --template can be one of: - a custom template published on npm: cra-template-typescript - a local path relative to the current working directory: file:../my-custom-template - a .tgz archive: https://mysite.com/my-custom-template-0.8.2.tgz - a .tar.gz archive: https://mysite.com/my-custom-template-0.8.2.tar.gz If you have any problems, do not hesitate to file an issue: https://github.com/facebook/create-react-app/issues/new 还有很多，比如： 命令行交互 日志打印 命令行文字颜色 网络通信：HTTP/WebSocket 文件处理 等等。。。 原生脚手架开发痛点分析 痛点一：重复操作 多Pageage本地link 多Pageage依赖安装 多Pageage单元测试 多Pageage代码提测 多Pageage代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互依赖版本升级 Pageage 越多，管理复杂度越高 脚手架本地link标准流程 链接本地脚手架 cd your-cli-dir npm link 链接本地库文件 cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件 cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解 npm link npm link your-lib：将当前项目中的 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件 npm link：将项目当前链接到 node 全局 node_modules 中作为一个库文件，并解析 bin 配置创建可执行文件 理解 npm unlink npm unlink：将当前项目从 node 全局 node_modules 移除 npm unlink your-lib：将当前项目的库文件依赖移除 Lerna 简介 Learn 是一个优化基于 git + npm 的多 pageage 项目管理的工具，像 bable、vue-cli、create-react-app 都使用 Lerna 进行管理 Lerna 开发脚手架流程 基于Lerna创建脚手架 全局安装 Lerna npm install -g lerna 在项目目录执行 lerna 初始化命令 lerna init 发现会生成一个 lerna.json 文件和 packages 目录，并且为我们初始化了 git 仓库 使用 Lerna 创建一个 package lerna create core lerna create utils 在输入 package 的 name，我们选择使用 npm 包组织管理默认，如 @aotu-cli/core、@aotu-cli/utils 如下图在 npm 上注册一个命令 aotu-cli 的组织，这样我们所有的包文件都在它下面 使用 Lerna 添加依赖 // 给所有package依赖依赖 lerna add loadash // 给指定package依赖依赖 lerna add loadash packages/core 使用 Lerna 移除所有依赖 lerna add loadash 只会删除 node_modules，不会删除 package.json 中的依赖 使用 Lerna 执行所有命令 lerna run test 使用 Lerna 进行批量发布 lerna publish 初次执行会报错，提示告诉我们 执行 git commit ok，首先在 github 上创建工程并链接到本地进行推送，再次执行 lerna publish 告诉我们需要先进行 npm 登陆，我们执行 npm login 进行登陆，输入账户密码，发现又出现新的报错 这个错误是 npm 要求在发布的时候要求设置环境为原地址，执行以下命令 npm config set registry http://registry.npmjs.org 再次执行 lerna publish，又发现报错 这个错误是因为 Lerna 的项目默认都是私有项目，在每个 packages 的 package.json 里面添加配置 \"publishConfig\": { \"access\": \"public\" } 再次执行 lerna publish 如图发布成功，在 npm 进行搜索，找到了我们刚才发布的两个包 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/凹凸曼/03-Week03-作业.html":{"url":"pages/凹凸曼/03-Week03-作业.html","title":"Week03 作业","keywords":"","body":"脚手架核心开发流程 脚手架架构图 gitFlow 脚手架拆分策略 拆分原则 根据模块的功能来拆分： core: 核心模块 命令模块：commands 模型模块：models 工具模块：utils 拆分结果为以下 核心流程：core 命令：commands 初始化 发布 清除缓存 模型层：models Command 命令 Project 项目 Component 项目 Npm 模块 Git 仓库 支撑模块:utils Git 操作 云构建 工具方法 API请求 Git Api 命令执行流程 检测版本号 直接输出当前 package.json 信息 function checkPkgVersion() { log.info('cli', pkg.version) } 检查 Node 版本 获取系统的 Node版本，然后和我们预定的版本进行对比 function checkNodeVersion() { // 获取当前Node版本 const currentVersion = process.version; const lowestVersion = constant.LOWEST_NODE_VERSION; // 比对最低版本号 if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`aotu-cli 需要安装 v${lowestVersion} 以上版本的 Node.js`)) } } 检查是否 root 启动 利用 root-check 来帮忙我们快速实现，如果是 root 启动，会帮我们进行降级 function checkRoot() { // root 启动的目录无法操作，需要进行降级 // sudo 启动 打印就是 0 正常就是 501 const rootCheck = require('root-check') rootCheck() } 检测用户主目录 const userHome = require('user-home') const pathExists = require('path-exists').sync function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前用户主目录不存在，请检查!')) } } 检测入参 根据输入参数是否开启 debug 模式 function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs() } function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL; } 检查环境变量 function checkEnv() { const dotenv = require('dotenv'); const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量', process.env.CLI_HOME_PATH) } function createDefaultConfig() { const cliConfig = { home: userHome }; if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME); } process.env.CLI_HOME_PATH = cliConfig.cliHome; } 检测是否最新版本 async function checkGlobalUpdate() { // 获取最新版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; // 调用 API 拿到所有版本号 const { getNpmSemverVersion } = require('get-npm-info'); // 提取所有版本号，对比那些版本号大于当前版本号 const lastVersion = await getNpmSemverVersion(currentVersion, npmName); // 获取最新版本号，提示用户更新到该版本 if (lastVersion && semver.gt(lastVersion, currentVersion)) { log.warn(colors.yellow(`请手动更新 ${npmName}，当前版本：${lastVersion}，最新版本 ${lastVersion} 更新命令：npm install -g ${npmName}`)) } } Node 支持 Es Module 可以采用 Gulp 进行编译，可以参考 使用 Gulp 对 Node 进行编译 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:16 "},"pages/前端菜鸟/":{"url":"pages/前端菜鸟/","title":"前端菜鸟","keywords":"","body":"作业 第一周作业：技术方案设计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/前端菜鸟/1、第一周作业.html":{"url":"pages/前端菜鸟/1、第一周作业.html","title":"1、第一周作业","keywords":"","body":"技术方案设计文档 需求 xxx 范围 前端编辑器 用于创建发布作品分享等 开发方式：前后端分离 h5 ssr 对性能考虑，采用ssr 后台管理 用于管理h5内容、 数据分析等 开发方式：前后端分离 模块设计 前端编辑器、后台管理和h5可以共用一个服务端。 前端编辑器和具有相同的样式，将相同样式业务部分独立拆分成共用的组件，方便维护 数据结构 这个项目可以采用vue+vuex或react+redux实现 store中的数据格式 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 props: {}, // 页面的一些信息，如背景等 components: [ //vnode格式 { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] }, activeComponentId:0//当前选中组件的索引 } 拓展一个图层可以通过计算属性获得当前选中的的图层组件，而不是新创建一个数据。这样做可以减少数据冗余 拓展性 扩展组件，页面数据结构 扩展编辑器功能，如隐藏、锁定等 扩展页面配置 开发提效 前端工程化 使用脚手架创建项目、自动化部署项目、规范代码 组件管理 使用脚手架工具管理发布组件库运维保障 线上服务和运维保障 出错后代码可快速回滚 安全 防止xss攻击和csrf攻击 使用https 密码等敏感信息加密 监控和报警 发送短信等给管理员 服务拓展性 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/十三/":{"url":"pages/十三/","title":"十三","keywords":"","body":"十三 - 学习记录 Week01 Week01-作业-整体架构设计 V1.0 第二周作业与笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/十三/01-Week01-作业.html":{"url":"pages/十三/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"《慕课乐高》 整体架构设计 V1.0 项目需求 参见：需求文档 核心功能清单 使用者 功能 B端 模板库 作品管理 编辑器 数据统计 C端 查看作品 分享作品 管理端 用户管理 模板管理 作品管理 数据统计 目标 制定 作品制作>发布>展示 整体架构 为下一步详细方案设计提供依据 范围 根据需求进行整体架构设计，不涉及具体实现。 业务逻辑需自我循环，有始有终，有进有出。 数据流转关系图 模块设计 组件库，独立第三方，同时用于编辑器和H5 因需自定义事件统计，需自研统计服务 扩展性保证 扩展组件 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面的配置 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 备份与安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/十三/02-Week02-作业.html":{"url":"pages/十三/02-Week02-作业.html","title":"Week02 作业","keywords":"","body":"脚手架实现原理 为什么全局安装@vue/cli后会添加vue的命令？ npm install -g @vue/cli 查看vue实际文件路径 > which vue /usr/local/bin/vue bin目录下存放的是可执行文件 > cd /usr/local/bin > ll lrwxr-xr-x 1 song admin 39B 12 28 21:48 vue -> ../lib/node_modules/@vue/cli/bin/vue.js 可以看到vue实际是一个软链接，指向：../lib/node_modules/@vue/cli/bin/vue.js 绑定管理在哪里指定的呢？ 进入到@vue/cli安装目录 > cd /usr/local/lib/node_modules/@vue/cli > ll -rw-r--r-- 1 song admin 2.5K 12 28 21:48 package.json 在package.json中有一个bin的配置 \"bin\": { \"vue\": \"bin/vue.js\" }, 这里配置了安装完之后的软链接名称，以及指向的实际文件 全局安装@vue/cli时发生了什么？ npm install -g @vue/cli 第一步：会把@vue/cli下载到node node_modules中 第二步：下载成功后会解析package.json 中的 bin 配置，有这个配置就会创建一个软链接 vue执行一个js文件，为什么可以执行它？ 执行vue命令时，系统会执行which vue在环境变量中找vue的注册并执行文件# 这两条命令执行是等价的 > vue >/usr/local/bin/vue 执行的真实文件是vue对应的软链接：../lib/node_modules/@vue/cli/bin/vue.js 直接执行一个xx.js执行不了的，vue.js又是怎么执行的呢？ js文件需要一个解释器(node)来执行 vue.js源码第一行#!/usr/bin/env node 自己创建一个js文件,test.js中第一行加入此代码，通过 ./test.js也能直接执行。 为什么能直接执行？ 这句话的意思是，告诉系统在环境变量中去找node命令，来执行此文件> /usr/bin/env node # 会将node命令执行起来，与直接执行node是一样的效果 所以./test.js等于 /usr/bin/env node test.js 等于 node test.js chmod 777 test.js 设置文件为可执行文件自定义一条命令 思路：在环境变量中创建一个软链接，执行 test.js即可 (软链接可以嵌套) 在 /usr/local/bin下执行> ln -s /test/index.js #删除软链接 rm 脚手架的开发流程 创建npm项目 创建脚手架入口文件，最上方添加：#!/usr/bin/env node 配置package.json 添加bin属性 编写脚手架代码 将脚手架发布到npm 脚手架开发难点 分包： 将复杂系统拆分成若干个模块 命令注册：vue create vue add vue invoke 参数解析vue command [options] options全称：--version、--help options简写： -V、-h 帮助文档 命令行交互 日志打印 命令行文字变色 网络通信：HTTP/WebSocket 文件处理 .... 理解npm link npm link your-lib：将当前项目中 node_modules 下指定的库文件链接到 node全局node_modules下的库文件 npm link: 将当前项目链接到node全局node_modules中作为一个库文件，并解析bin配置创建可执行文件 理解npm unlink npm unlink：将当前项目从node全局node_modules中移除 npm unlink your-li：将当前项目中的库文件依赖移除 创建一个脚手架 > mkdir cli-test # 创建一个文件夹 > npm init -y # 初始化 cli-test 目录: -- package.json -- bin |-- inde.js index.js 文件: #!/usr/bin/env node console.log('Hello cli') package.json文件： { ... \"main\": \"index.js\", \"bin\": { \"cli-test\": \"bin/index.js\" } } 将脚手架发布到npm > npm login # 登录npm > npm publish # 发布 在cli-test目录下，进行全局安装 npm install -g cli-test 就会建立一个软链接，方便进行本地调试， 通过npm link 也可。 yargs入门 Yargs通过解析参数来帮助您构建脚手架的工具。 通过yargs创建一个最简单的脚手架工具 定义文件index.js #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') const arg = hideBin(process.argv) yargs(arg) .argv 执行 > ./index.js --help 选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] 严格模式: strict yargs(arg) .strict() .argv 加入strict，如果有无法识别的参数，将会给出提示 用法提示: usage yargs(arg) .usage('Usage: test [command] ') .strict() .argv 使用--help将会打印出使用信息 > ./index.js --help test [command] 选项： --help 显示帮助信息 [布尔] --version 显示版本号 最少输入的command个数: demandCommand yargs(arg) .usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .argv 设置command别名: alias yargs(arg) .usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') //-h 和 --help 效果一样 .argv 设置输出内容的宽度: wrap const cli = yargs(arg) cli.usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') .wrap(cli.terminalWidth()) // terminalWidth返回当前窗口的宽度 .argv 设置结尾显示的内容: epilogue cli.usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') .wrap(cli.terminalWidth()) .epilogue('结尾显示的话') .argv 为全局command添加选项: options cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { // 添加的选项名 type: 'boolean', describe: 'debug mode', alias: 'd' // 别名 } }) .argv // options('name', {}) 一个一个设置的用法 执行效果 > ./index.js -h Usage: test [command] 选项： --version 显示版本号 [布尔] -d, --debug debug mode [布尔] -h, --help 显示帮助信息 [布尔] 将选项分组: group cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { type: 'boolean', describe: 'debug mode', alias: 'd' } }) .group(['debug'], 'Dev Options:') .argv 执行效果 > ./index.js -h Usage: test [command] Dev Options: -d, --debug debug mode [布尔] 选项： --version 显示版本号 [布尔] -h, --help 显示帮助信息 [布尔] 命令纠错提示：recommendCommands() 会根据当前输入的command去找最相似的进行提示 自定义错误信息: fail((err,msg) => {...}) dedent库 去除每行顶部空格，方便多行字符串的输出 const dedent = require('dedent') console.log(dedent` 第一行， 第二行 `) // 将会订购显示输出 /** 第一行， 第二行 */ 自定义命令 官方示例 #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') yargs(hideBin(process.argv)) .command( 'serve [port]', // serve 脚手架后面输入的名，[port]定义的option 'start the server', // 描述 (yargs) => { //builder，在执行这个command之前做的事情 yargs .positional('port', { describe: 'port to bind on', default: 5000 }) }, (argv) => { // handler，执行comand 的行为 if (argv.verbose) console.info(`start server on :${argv.port}`) serve(argv.port) } ) .option('verbose', { alias: 'v', type: 'boolean', description: 'Run with verbose logging' }) .argv 自定义 cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { type: 'boolean', describe: 'debug mode', alias: 'd' } }) .group(['debug'], 'Dev Options:') .command('init [name]', '初始化的命令', (yargs) => { yargs.option('name', { type: 'string', describe: 'init的option', alias: 'n' }) }, (argv) => { console.log(argv) }) .argv 执行效果 > ./index.js init { _: [ 'init' ], '$0': 'index.js' } > ./index.js init -h ndex.js init [name] 初始化的命令 Dev Options: -d, --debug debug mode [布尔] 选项： --version 显示版本号 [布尔] -n, --name init的option [字符串] -h, --help 显示帮助信息 [布尔] 使用对象方式定义 ... .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'list 的描述', builder: (yargs) => { }, handler: (argv) => { console.log(argv) } }) .argv parse 解析命令参数，合并传入的参数，合并完作为一个新的参数注入到脚手架中 #!/usr/bin/env node const yargs = require('yargs/yargs') const pkg = require('../package.json') const argv = process.argv.splice(2) const context = { testVersion: pkg.version } yargs() .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'list 的描述', builder: (yargs) => {}, handler: (argv) => { console.log(argv) } }) .parse(argv, context) 执行效果 > ./index.js list { _: [ 'list' ], testVersion: '1.0.5', '$0': 'index.js' } Lerna初始化过程 npm本地包引用方法 除了npm link 还可以通过file: @lerna/global-options:\"file:../global-options\" Lerna创建发布流程 项目初始化 > mkdir my-cli-dev # 创建项目文件 > npm init -y # 在项目目录下初始化 > npm i -g lerna # 全局安装lerna > lerna init # 初始化 创建package > lerna create core # package name 为 @my-cli-dev/core > lerna create utils # package name 为 @my-cli-dev/utils package.json中name为@my-cli-dev/core这种方式，my-cli-dev则为组织名称，需要在npm上创建一个对应的组织，可以避免名字的重复。若包发布不上去检查下这个组织是否已经建立。 core/package.json 中dependencies 添加@my-cli-dev/utils的依赖。 通过lerna link链接到本地库 发布前的准备 1、创建git仓库 > git remote add origin https://xx/cli.git # 添加仓库的链接 # 代码提交到仓库 > git add . > git commit -m 'init' > git push origin master --set-upstream 2、需要npm login 3、根目录下添加LICENSE.md文件 4、package.json中添加publishConfig设置为公有库 发布 > lerna publish 错误问题 lerna ERR! E403 [no_perms] Private mode enable, only admin can publish this module 出现原因：使用的是淘宝源cnpm,登陆到的是cnpm 解决方法：切换到npmjs的网址，代码如下 npm config set registry http://registry.npmjs.org/ 切换过去之后记得npm login import-lcoal执行流程 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/奕初/":{"url":"pages/奕初/","title":"奕初","keywords":"","body":"奕初--学习笔记 整体架构设计 V1.0 02-脚手架开发入门知识 03-脚手架开发流程详解 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/奕初/01-整体架构设计 V1.0.html":{"url":"pages/奕初/01-整体架构设计 V1.0.html","title":"整体架构设计 V1.0","keywords":"","body":"架构方案设计文档 需求背景 https://www.yuque.com/imooc-lego/zlz87z 功能范围 本系统作为多身份应用平台，存在多个身份角色，暂时分为三种角色 分别为： 前台：C端用户使用的 H5 中台：运营人员使用的业务编辑器 平台：管理员使用的管理系统 H5 端（前台） 使用者和用途：C端普通用户，可以对作品进行操作分享。 开发方式：H5 SSR 的方式。 业务端（中台） 使用者和用途：运营人员、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 管理系统（平台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计。 开发方式：前后端分离的方式由 admin-fe + admin-server 构成。 模块设计 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/奕初/02-脚手架开发入门知识.html":{"url":"pages/奕初/02-脚手架开发入门知识.html","title":"脚手架开发入门知识","keywords":"","body":"脚手架开发入门知识 脚手架简介 脚手架本质是一个操作系统的客户端，它通过命令行执行，比如： vue create project 上面这条命令由 3 个部分组成： 主命令: vue command: create (类似向脚手架发送一个请求，让脚手架执行一个动作 ) command 的 param: project 它表示创建一个 vue 项目，项目的名称为 project，以上是最一个较为简单的脚手架命令。 脚手架的执行原理 脚手架的执行原理如下： 在终端输入vue create project 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command / options vue.js 执行 command / options 执行完毕，退出执行 如何开发一个脚手架 这里以 vue-cli 为例 开发一个项目文件，该项目中应包含一个 bin/vue.js 文件，使用npm进行初始化，打开package.json 配置bin字段，创建一个命令，指向bin/index.js； 将这个项目发布到 npm 将 npm 项目上的项目全局安装到 node 的 lib/node_modules 在 node 的 bin 目录下配置 vue 软链接指向 lib/node_modules/@vue/cli/bin/index.js 这样我们使用第一步中bin字段中配置的命令来使用脚手架，如：执行 vue 命令的时候就可以找到 vue.js 进行相关操作 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置去在 node 的安装目录下的 bin 目录下，创建一个软连接，连接到软件包中，软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value， 指向的文件中需要设置 #! /usr/bin/env node 来标识文件执行的方法 为什么全局安装@vue/cli后会添加命令为vue? 因为安装后会自动在node的bin目录下建立vue的软链接文件, 这个软链接文件指向了node/lib/node_modules/@vue对应vue.js。 全局安装 @vue/cli 时发生了什么？ 执行过程如下： 解析执行文件到node/lib/node_modules下 在node/bin目录下创建vue的软链接连接到node/lib/node_modules对应vue.js文件 执行vue命令时发生了什么 参考上面的执行原理 为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？ .主要是 #!/usr/bin/env node 这句话，添加了执行该文件的环境变量。 #!/usr/bin/env node #!/usr/bin/node //第一种是在环境变量种找 node //第二种是直接执行 /usr/bin/ 目录下的 node Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/奕初/03-脚手架开发流程详解.html":{"url":"pages/奕初/03-脚手架开发流程详解.html","title":"脚手架开发流程详解","keywords":"","body":"脚手架开发流程详 开发流程 创建项目，使用npm初始化这个项目 创建脚手架入口文件，第一行写如下代码： #!/usr/bin/env node 配置package.json文件，添加bin属性 编写脚手架代码 将脚手架发布到npm 发布到npm的流程 打开npm的官网,注册一个账号、创建相关的代码组织库； npm login 输入账号、密码和邮箱进行登录； npm publish 将项目发布上去。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/左子穆/":{"url":"pages/左子穆/","title":"左子穆","keywords":"","body":"子穆 --我是一个测试 学习课程目的 了解前端框架设计，方便后软件测试层反推存进更好的与web开发沟通，同时提升自己的前端设计的理解。 （个人非开发，拓展自己知识边界） 札记目录 第一周学习札记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/左子穆/01-自我学习-web第一周札记.html":{"url":"pages/左子穆/01-自我学习-web第一周札记.html","title":"自我学习 Web第一周札记","keywords":"","body":"文档资料：https://www.imooc.com/wiki/weban 技术永远都是要为业务服务 技术是实现业务增长。 架构师： 不要过多的关注细节，要看整体，看范围。 不要确定内容需要调研设计 设计需要考虑复杂度，越简单越好。 以架构师的思考-分析业务需求 项目-浅层需求 项目-深层需求 没有业务场景无需求架构设计，需要有具体解决方案才需要有架构设计。 前端研发流程： 以架构师的思维来分析需求 核心点：需要分析潜在需求，需要全局的把握思维，需要为用户增长负责。 全面、完整、闭环-三个关键点。 参考业务理解能力：设计测试一个h5抽奖界面，你作为主要测试负责人，你会具体思考哪些需求点（常规、隐形），以 测试过程中可能会涉及到前端实现的技术方案。 -需要通过流程图的完善业务--初级架构师。 浅层需求分析 需求指导设计、设计指导开发 深层需求分析 不容易一眼看出来，但却很重要的。 架构师-需要深度理解业务，技术要为业务增长负责。 功能存在必要性，服务业务增长。 业务闭环，其中统计与统计分销很重要，c端方面渠道分销需要着重统计。 架构设计-全局的结构设计 不同角色，基于角色功能列表，每个功能单个闭环。 pm的关系：统一战线，对业务负责。 技术方案设计 ssr的使用场景需要考虑-b端、c端？需要考虑场景toc 可以考虑ssr使用。 前后端代码库设计。 业务组件库？ 画布什么内容映射到c端h5就是什么样子，render 渲染的逻辑需要一致的。（业务组件-独立第三方内容 ，各个模块都是组件进行应用） 统计服务 日常pv/uv,每个页面的访问、uv每个用户的访问 具体事件-需要一定自定义事件。 项目分析与项目之间依赖关系 前端项目 h5ssr项目 后端项目 统计服务-提供openapi内容（面对用户，面对admin） 脚手架 脚手架-创建项目 脚手架-组件 数据结构的设计 数据的存取与抽象内容。 数据存取结构 画布与同步修改 图层？div? 技术方案 阐述自己的思路，流程，处理方案，流程图，数据流，判断逻辑，库表设计。 也是工作内容的产出。 技术方案整体策略 产品需求 范围：整体设计，架构设计，没有细节 模块设计 模块拆分与关系图，结果 模块的关键功能，职责（组件功能） 特殊的模块重点说明 组件库，独立第三方，用于编辑器 自主研发的统计服务 做的数据结构 Vuex的 结构届时 数据结构关系图 扩展性保证 扩展组件，数据结构层面 扩张选编辑器的功能 扩展页面的配置 （可以进行具体讨论操作，集思广益） 开发提效 脚手架 组件平台 运维平台 线上服务检测 安全 监控和报警 服务扩展性；流量大 大厂自己研发，小厂的第三方运维。 作业打卡 http://homework.imooc-lego.com/ 输入/输出。 学习的思考：浅层学习看输入，深层学习涮出。 技术方案的理解 技术方案是必要的，在日常项目管理也是督促完成方案设计，同时有具体方案可以与产品，测试进行沟通学习。 技术方案是沉淀自己思想的途径。 技术实现（业务） h5抽奖为例 从一个架构师思考： 功能完整性：安全设计需要补充。 网站技术方案流程图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/彩笔/":{"url":"pages/彩笔/","title":"彩笔","keywords":"","body":"彩笔 - 学习分享 学如逆水行舟，不进则退。可我越学越觉得自己离终点越远。 第一周作业 第二周作业 第三周作业 第四周作业 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/彩笔/作业-01-架构方案设计文档.html":{"url":"pages/彩笔/作业-01-架构方案设计文档.html","title":"作业 01 架构方案设计文档","keywords":"","body":"慕课乐高架构方案设计文档 需求 https://www/yuque.com/imooc-lego/zlz87z 范围 根据需求分化出了三个方面的内容：用户端(前台)、企业端(中台)、后台管理(后台) 用户端(前台) 主要用来展示通过编辑器编辑出来的 H5 海报。 由于 移动端 性能上的局限，所以可以考虑使用 SSR H5-server 企业端(中台) 主要提供可产出H5海报模板的功能，以及一系列相关的功能 biz-editor-fe biz-editor-server 后台管理(后台) 主要用来管理 企业端的用户 以及 海报模板 ，掌控全局 admin-fe admin-server 模块设计 如下图所示 其中因为 用户端 和 企业端都会用到 组件库 所以可以独立出一个组件平台。统计服务由于第三方要么是功能不齐全，要么是性价比很低，因此考虑自研一个统计服务。 核心数据结构 { scene: { name: '场景名称', setting: {}, // 扩展性保证 options: {}, // 扩展性保证 }, components: [ { id: '1', name: '组件名1', type: 'text', attr: { w: 50, h: 50, z: 1, }, options: { value: 'xxx' color: 'red', fontSize: 16 }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } }, { id: '2', name: '组件名2', type: 'image', attr: { w: 50, h: 50, z: 1, }, options: { src: 'xxx.png', alt: 'xxx' }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } } ] } 扩展性保证 保证编辑器未来的扩展性 场景的扩展性 scene: { name: '场景名称', setting: {}, // 扩展性保证 options: {}, // 扩展性保证 } 组件的扩展性 { id: '1', name: '组件名1', type: 'text', attr: { w: 50, h: 50, z: 1, }, options: { value: 'xxx' color: 'red', fontSize: 16 }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } }, 开发提效 脚手架组件平台 脚手架 可以开发快速创建 项目 原型的脚手架，来省去配置项目初始化的时间。 可以开发快速发布 项目 上线的脚手架，来省去发布项目的时间 组件平台 搭建业务组件平台，来减少代码的重复率，对业务组件进行抽象，积累业务组件，提升开发效率，减少编写重复代码的时间 运维保障 ... Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/彩笔/作业-02-脚手架架构设计和框架搭建.html":{"url":"pages/彩笔/作业-02-脚手架架构设计和框架搭建.html","title":"作业 02 脚手架架构设计和框架搭建","keywords":"","body":"脚手架架构设计和框架搭建 脚手架的作用 开发脚手架的核心目标是：提升前端研发效能 脚手架的核心价值 自动化：项目重复代码拷贝/git 操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 和自动化构建工具的区别 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动挡化、本地 git 操作自动化等 定制负责：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语音，对前端开发不够友好 入门 脚手架本质上来说，是一个操作系统的客户端。它通过命令行执行： vue create vue-test-app 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置去在 node 的安装目录下的 bin 目录下，创建一个软连接，连接到软件包中，软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value，value 指向的文件中需要设置 #! /usr/bin/env node 来标识文件执行的方法 基于 lerna 搭建自己的脚手架并且发布到 npm 安装方法 npm install -g @weilai-cli/core 执行命令 weilai-cli -h 进阶 理解 yargs 常用 API 和 开发流程 const cli = yargs(); // 创建一个基础脚手架 cli // 配置 使用提示 .usage('Usage: weilai-test-cli [command] ') // 配置 脚手架最少要接收一个命令 .demandCommand(1, \"最少需要输入一个命令。 通过 --help 查看所有可用的命令和选项。\") // 配置 命令输入错误的时候可以根据输入 推荐合适的命令 .recommendCommands() // 配置 严格的无法识别的命令也将报告为错误 .strict() // 配置 发生故障时执行的方法 .fail((err, msg) => { console.log(err) }) // 配置 help 和 version 的别名 .alias('h', 'help') .alias('v', 'version') // 配置 容器宽度 .wrap(cli.terminalWidth()) // 配置 收尾的文字 .epilogue( dedent` 哎哟，不错哟！ 小伙汁 ` ) // 配置 gameStart 配置 类型为布尔值，描述是五黑走起，别名是 g .options({ gameStart: { type: 'boolean', describe: '五黑走起', alias: 'g' } }) .option('gameEnd', { type: 'string', // hidden: true, describe: '冲冲冲', alias: 'r' }) // 配置 分组 把 gameStart 分配到 召唤师峡谷 这个组里面 .group(['gameStart'], '召唤师峡谷:') .group(['gameEnd'], '慕课网:') // 配置 命令 当执行 init [name] 命令的时候一系列的行为 .command( 'init [name]', 'Do init a project', (yargs) => { // 子命令 yargs .option('name', { type: 'string', describe: 'Name of aproject', alias: 'n' }) }, (argv) => { // 行为 console.log(argv) } ) // 配置 命令的第二种方法 .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'List local packages', builder: (yargs) => { }, handler: (argv) => { console.log(argv) } }) // 解析参数 .parse(argv, context) 理解 lerna 实现原理 已经忘掉了&#x1F603;准备二刷三刷 import-local 实现原理，理解 require.resolve 实现原理 已经忘掉了&#x1F603;准备二刷三刷 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/彩笔/作业-03-脚手架核心流程开发.html":{"url":"pages/彩笔/作业-03-脚手架核心流程开发.html","title":"作业 03 脚手架核心流程开发","keywords":"","body":"脚手架核心流程开发 标准 绘制 imooc-cli 脚手架架构设计图 实现 imooc-cli 脚手架准备过程代码 try { checkPkgVersion() checkNodeVersion() checkRoot() checkUserHome() checkInputArgs() checkEnv() await checkGlobalUpdate() } catch(error) { log.error(error.message) } // 检查是否需要全局更新 async function checkGlobalUpdate() { const currentVersion = pkg.version const npmName = pkg.name const lastVersions = await getNpmSemverVersions(npmName, currentVersion) if(lastVersions && semver.gt(lastVersions, currentVersion)) { log.warn('更新提示', colors.yellow( dedent` 请更新 ${npmName} 当前版本: ${currentVersion} 最新版本: ${lastVersions} 更新命令: npm install -g ${npmName}@${lastVersions} `)) } } // 环境变量检查 function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if(pathExists(dotenvPath)) { config = dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量:', process.env.CLI_HOME_PATH) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } process.env.CLI_HOME_PATH = cliConfig['cliHome'] = process.env.CLI_HOME ? path.join(userHome, process.env.CLI_HOME) : path.join(userHome, constant.DEFAULT_CLI_HOME) } // 入参检查 function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs(args) } // debug 模式判断 function checkArgs(args) { log.level = process.env.LOG_LEVEL = args.debug ? 'verbose' : 'info' } // 检查 用户主目录 function checkUserHome() { if(!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登陆用户主目录不存在')) } } // 检查登陆帐号的级别 以及 降级 function checkRoot() { require('root-check')() } // 检查 node 的版本 function checkNodeVersion() { const currentNodeVersion = process.version const lowestNodeVersion = constant.LOWEST_NODE_VERSION if(!semver.gte(currentNodeVersion, lowestNodeVersion)) { throw new Error(colors.red(`weilai-cli 需要安装 v${lowestNodeVersion} 以上版本的 Node.js`)) } log.notice('node', process.version) } // 检查 package 的版本 function checkPkgVersion() { log.notice('cli', pkg.version) } 通过 commander 框架实现一个脚手架，包含自定义 option 和 command 功能 #! /usr/bin/env node const commander = require('commander') const pkg = require('../package.json') // 获取 commander 的单例 // const { program } = commander // 手动实例化一个 commander 实例 const program = new commander.Command() program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false) .option('-e, --env ', '获取环境变量名称', false) // command 注册命令 program .command('clone [destination]') .description('clone a repository') .option('-f, --force', '是否强制拷贝') .action((source, destination, cmdObj) => { console.log('do clone', source, destination, cmdObj.force) }) // addCommand 注册子命令 const service = new commander.Command('service') service .command('start [port]') .description('start service at some port') .action((prot, cmdObj) => { console.log('do server start', prot) }) service .command('stop') .description('stop service') .action(() => { console.log('do server stop') }) program.addCommand(service) // program // .command('install [name]', 'install package', { // executableFile: 'weilai-cli', // // isDefault: true, // // hidden: true // }) // .alias('i') // 高级定制：自定义help信息 // console.log(program.outputHelp()) // console.log(program.helpInformation()) program.helpInformation = () => '' program.on('--help', () => { console.log('your help information') }) program.on('option:debug', () => { console.log('debug') }) program.on('command:*', (obj) => { console.log('未知的命令', obj) const availableCommands = program.commands.map(cmd => cmd.name()) console.log('可用的命令', availableCommands) }) // program // .arguments(' [options]') // .description('test command', { // cmd: 'command to run', // options: 'options for command' // }) // .action((cmd, options) => { // console.log(cmd, 'arguments') // }) program .parse(process.argv) // console.log(program.debug) // console.log(program.env) // console.log(program.opts()) 进阶 通过 webpack 和 原生两种方式实现 node 对 ES Module 的支持 通过配置 webpack 来实现模块化(ES Module)，并且 使用 babel 进行编译，来兼容低版本的 node 设置文件后缀名为 xxx.mjs , node 版本小于 14 需要加上 --experimental-modules 来对 mjs 进行支持 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/彩笔/作业-04-脚手架命令注册和执行过程开发.html":{"url":"pages/彩笔/作业-04-脚手架命令注册和执行过程开发.html","title":"作业 04 脚手架命令注册和执行过程开发","keywords":"","body":"脚手架命令注册和执行过程开发 weilai-cli 脚手架动态命令执行代码 'use strict'; const cp = require('child_process') const path = require('path') const log = require('@weilai-cli/log') const Package = require('@weilai-cli/package') const SETTINGS = { init: '@weilai-cli/init' } const CHCHE_DIR = 'dependencies' async function exec(...argm) { let storePath, pkg let targetPath = process.env.CLI_TARGET_PATH const homePath = process.env.CLI_HOME_PATH log.verbose('targetPath', targetPath) log.verbose('homePath', homePath) const cmdObj = argm[argm.length - 1] const cmdName = cmdObj.name() const packageName = SETTINGS[cmdName] const packageVersion = 'latest' if(!targetPath) { targetPath = path.resolve(homePath, CHCHE_DIR) storePath = path.resolve(homePath, 'node_modules') log.verbose('targetPath', targetPath) log.verbose('storePath', storePath) pkg = new Package({ targetPath, storePath, packageName, packageVersion }) if(await pkg.exists()) { // 更新 log.verbose('package', '更新') await pkg.update() } else { // 安装 log.verbose('package', '安装') await pkg.install() } } else { pkg = new Package({ targetPath, packageName, packageVersion }) } const rootFile = pkg.getRootFile() if(rootFile) { try { // 当前进程 // rootFile && require(rootFile)(argm) // 子进程 const o = Object.create(null) Object.keys(cmdObj).forEach(key => { if( cmdObj.hasOwnProperty(key) && !key.startsWith('_') && key !== 'parent' ) { o[key] = cmdObj[key] } }) argm[argm.length - 1] = o const code = `require('${rootFile}')(${JSON.stringify(argm)})` const child = spawn('node', [ '-e', code ], { cwd: process.cwd(), stdio: 'inherit' // 这个属性是把子进程的输出流直接挂载到父进程 }) child.on('error', e => { log.error(e.message) process.exit(1) }) child.on('exit', e => { log.verbose('命令执行成功:', e) process.exit(e) }) } catch(err) { log.error(err.message) } } } function spawn(command, args, options) { const win32 = process.platform === 'win32' const cmd = win32 ? 'cmd' : command const cmdArgs = win32 ? ['/c'].concat(command, args) : args return cp.spawn(cmd, cmdArgs, options || {}) } module.exports = exec; // package 'use strict'; const path = require('path') const pkgDir = require('pkg-dir') const fsExtra = require('fs-extra') const npminstall = require('npminstall') const pathExists = require('path-exists') const { isObject } = require('@weilai-cli/utils') const formatPath = require('@weilai-cli/format-path') const { getDefaultRegistry, getNpmLatestVersion } = require('@weilai-cli/get-npm-info') class Package { constructor(options) { if(!options) throw new Error('Package 类的 options 参数不能为空') if(!isObject(options)) throw new Error('Package 类的 options 参数必须是对象') // 路径 this.targetPath = options.targetPath // 存储路径 this.storePath = options.storePath // 名称 this.packageName = options.packageName // 版本号 this.packageVersion = options.packageVersion // 缓存目录的前缀 this.cacheFilePathPrefix = this.packageName.replace('/', '_') } async prepare() { if(this.storePath && !pathExists.sync(this.storePath)) { fsExtra.mkdirpSync(this.storePath) } if(this.packageVersion === 'latest') { this.packageVersion = await getNpmLatestVersion(this.packageVersion) } } // 获取缓存文件的路径 get cacheFilePath() { return path.resolve( this.storePath, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}` ) } getSpecificCacheFilePath(packageVersion) { return path.resolve( this.storePath, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}` ) } // 判断当前 package 是否存在 async exists() { if(this.storePath) { await this.prepare() console.log('cacheFilePath', this.cacheFilePath) return pathExists.sync(this.cacheFilePath) } else { return pathExists.sync(this.targetPath) } } // 安装 package install() { npminstall({ root: this.targetPath, storeDir: this.storePath, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: this.packageVersion }] }) } // 更新 package async update() { await this.prepare() // 1. 获取最新的 npm 模块的版本号 const latestPackageVersion = await getNpmLatestVersion(this.packageName) // 2. 查询最新版本号对应的路径是否存在 const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion) // 3. 如果不存在，则直接安装最新版本 if(!pathExists.sync(latestFilePath)) { npminstall({ root: this.targetPath, storeDir: this.storePath, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: latestPackageVersion }] }) this.packageVersion = latestPackageVersion } } // 获取入口文件 getRootFile() { function _getRootFile(targetPath) { // 1. 获取 package.json 所在的目录 const dir = pkgDir.sync(targetPath) if(dir) { // 2. 读取 package.json const pkgFile = require(path.resolve(dir, 'package.json')) // 3. 寻找 main / bin if(pkgFile && pkgFile.main) { // 4. 路径的兼容 return formatPath(path.resolve(dir, pkgFile.main)) } } return null } return this.storePath ? _getRootFile(this.storePath) : _getRootFile(this.targetPath) } } module.exports = Package; // init 'use strict'; const log = require(\"@weilai-cli/log\") const Command = require('@weilai-cli/command') class initCommand extends Command { init() { this.projectName = this._argv[0] || '' this.force = !!this._cmd.force log.verbose('projectName', this.projectName) log.verbose('force',this.force) } exec() { // init 的业务逻辑 console.log('init 的业务逻辑') } } function init(argv) { return new initCommand(argv) } module.exports = init module.exports.initCommand = initCommand 分析 Node 多进程 execSync/execFileSync/SpawnSync 源码 待更新... Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/点点/":{"url":"pages/点点/","title":"点点","keywords":"","body":"&#x1F408;点点 - 作业 第一周 01-需求分析和架构设计第二周 02-脚手架架构设计和框架搭建 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/点点/01-需求分析和架构设计.html":{"url":"pages/点点/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析 熟悉产品需求 以架构师的思维分析需求，不能只停留在表面实现需求，要考虑怎么实现能给业务带来增长 全局思维、整体思维、闭环思维，不能只考虑自己，要全局考虑整个团队，要做到有输出、有输入、有结果 浅层需求 分析表面需要实现的功能，如登录、创建作品、编辑、发布、访问作品等 深度需求 通过浅层需求分析，进一步分析需求 作品的管理 作品统计 作品发布 h5 后台管理 以上需求还有很多细节点，就不一一阐述 需求分析总览图 架构设计 需要的项目 独立业务组件库 编辑器画布使用的组件和渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 各个项目之间关系 作品数据结构设计 思路： 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 扩展组件 扩展编辑器功能、如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 研发效率 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/点点/02-脚手架架构设计和框架搭建.html":{"url":"pages/点点/02-脚手架架构设计和框架搭建.html","title":"脚手架架构设计和框架搭建","keywords":"","body":"1. 脚手架实现原理，基于 Lerna 搭建自己的脚手架并发布到npm 1.1 为什么全局安装 @vue/cli 后会添加的命令为 vue ？ 全局安装脚手架后，会根据脚手架的 package.json 中的 bin 来决定脚手架的命令 \"bin\": { \"vue\": \"bin/vue.js\" }, 当执行vue命令的时候，相当于执行node bin/vue.js 1.2 全局安装 @vue/cli 时发生了什么 首先 npm 下载包文件到 node 安装目录下的 node_modules，然后根据 package.json 文件 bin 属性中配置的命令在 C:\\Program Files\\nodejs 生成一个 vue 文件并注册到环境变量 1.3 执行 vue 命令时发生了什么？为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令去执行它呢？ 因为会在 bin/vue.js 文件头部声明了以下代码 #!/usr/bin/env node 它会告诉系统要用 node 去执行 1.4 已发布到npm脚手架 diao-cli https://www.npmjs.com/package/@diao-cli/core https://www.npmjs.com/package/@diao-cli/utils 2. Yargs 常用 API 和开发流程 const yargs = require('yargs/yargs') // 一个ES6字符串标签，从多行字符串中去除缩进。 const dedent = require(\"dedent\"); const cli = yargs() const argv = process.argv.slice(2) // 注入额外参数 const context = { diaoVersion: '1.0.0', }; cli // 开启严格模式，输入无效命令会报错无法识别命令 .strict() // 在头部输出一段信息 .usage('Usage: diao-cli [command] ') // 设置需要输入命令的最小值，这里设置最少输入一个命令，否则则抛出错误信息 .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") // 如果没有找到匹配的命令，yargs提供关于类似命令的建议 .recommendCommands() // 在有错误的时候执行，可以在这里自定义错误信息 .fail((err, msg) => { console.error('err:', err) }) // 设置 command 的别名 .alias('h', 'help') .alias('v', 'version') // 设置命令行输出时候的宽度 .wrap(cli.terminalWidth()) // 在命令行末尾打印的消息 .epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `) // 配置额外选项 .options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) // 配置额外选项 .option(\"registry\", { type: \"string\", describe: 'Define global registry', alias: 'r' }) // 对选项进行分组 .group(['debug'], 'Dev Options') .group(['registry'], 'Extra Options') // 注册命令 .command('init [name]', 'Do init a project', (yargs) => { yargs .option('name', { type: 'string', describe: 'Name of a project', alias: 'n' }) }, (argv) => { console.log(argv) }) // 注册命令 .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'List local packages', builder: (yargs) => {}, handler: (argv) => { console.log(argv) } }) // 解析命令输入参数 .parse(argv, context) 3. Lerna 常用命令和实现原理 Lerna 是基于 git+npm 的多package项目管理工具 3.1 常用命令 初始化 Lerna 项目 lerna init 创建 Package lerna create @diao-cli/core packages 安装依赖 lerna add mocha packages/core --dev 删除依赖 lerna clean 安装依赖 lerna boorstaap 执行单元测试 lerna run test 执行特定包单元测试 lerna run test @diao-cli/core link 项目 lerna link 发布项目 lerna publish 3.2 Lerna 实现原理 （需要二刷三刷） 通过 import-local 优先调用本地 lerna 命令 用过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数 lerna 命令注册时需要传入 builder 和 handler 两个方法， builder方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑 lerna 通过配置 npm 本地依赖的方式进行本地开发，具体写法是在 package.json 的依赖中写入：fill:your-kicak-module-path，在 lerna publish 时会自动将该路径替换 4. 理解 import-local 实现原理， 理解 require.resolve 实现原理 懵逼中，后面回过头再看~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/猛男落泪/":{"url":"pages/猛男落泪/","title":"猛男落泪","keywords":"","body":"猛男落泪 - 作业打卡 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/猛男落泪/01-第二周作业.html":{"url":"pages/猛男落泪/01-第二周作业.html","title":"第二周作业","keywords":"","body":"脚手架实现原理 为什么全局安装@vue/cli后会添加命令为vue 实际注册的命令是package.json中bin配置的 全局安装@vue/cli是发生了什么 npm会查看package.json,如果发现了bin字段就会在全局node_module同级目录创建可执行文件 执行vue命令时发生了什么?为什么vue指向一个js文件,我们却可以直接通过vue命令去执行它 1.在环境变量中寻找vue命令,如果存在就先找到实际的包目录(有可能是软连接)再执行命令入口文件; 2.因为入口js 顶部 声明了使用node去执行,!# /usr/bin/env node; 执行vue命令时传入的第一个参数是node Yargs常用API和开发流程 传递参数: require('yargs/yargs')(process.argv.slice(2)).argv 等价于 require('yargs/yargs')(process.argv.slice(2)).parse() const { hideBin } = require('yargs/helpers'); process.argv.slice(2) 等价于 hideBin(process.argv) 脚手架初始化流程 Yargs() - 构造函数 Yargs.options - 批量注册全局options Yargs.option - 单个注册全局option Yargs.group - 给定options的键值 将其归于一个分组 Yargs.demandCommand - 允许输入的参数最小个数 不满足时报错 Yargs.recommendCommands - 如果找不到匹配的命令 提示类似命令 Yargs.strict - 无法识别命令会报错 Yargs.fail - 所有错误处理函数 Yargs.alias - 为option 指定别名 Yargs.wrap - 为命令行指定宽度 Yargs.epilogue - 再命令行结尾输出信息Yargs.command Yargs.command(command, describe, builder, handler) Yargs.command({ command, describe, builder, handler }) command - 命令字符串 describe - 命令描述 builder - 添加命令的options handler - 命令处理函数,处理具体业务lerna的实现原理 lerna简单说明 lerna是基于git+npm 的多package项目管理工具;主要解决了多包管理的重复操作,操作的标准化,提高了效能; 主要api lerna init初始化项目 lerna create 创建package lerna add 安装依赖 lerna link link包的依赖 lerna publish 发布到npm上 给特定的package执行命令使用filter-options --scope lerna原理 通过import-local优先调用本地项目: lerna中使用微任务执行命令 在全局入口判断有本地lerna项目的情况下会加载本地项目并执行,然后执行宏任务下的代码输出 using local version of lerna 通过yargs生成脚手架 lerna 通过配置package.json本地依赖的方式进行本地开发,写法\"module-name\":'file:your-local-module-path',lerna再发布时会自动替换该路径require.resolve 实现原理 通过Module._resolveFileName 解析文件名 解析出绝对路径;首先调用Module._resolveLookupPaths逐层往上级目录找并拼接/node_modules存到paths数组中返回paths;然后通过Module._findPath找到真实模块路径; Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/诸神の黄昏/":{"url":"pages/诸神の黄昏/","title":"诸神の黄昏","keywords":"","body":"诸神の黄昏 - 笔记分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/诸神の黄昏/01-项目研发流程.html":{"url":"pages/诸神の黄昏/01-项目研发流程.html","title":"项目研发流程","keywords":"","body":"笔记链接的wolai https://www.wolai.com/93avnY9gotFRaErFoSVTNn?theme=light Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/郭二蛋/":{"url":"pages/郭二蛋/","title":"郭二蛋","keywords":"","body":"郭二蛋 嗨，你好呀！我是郭二蛋，在慕课网混迹已有4个年头，从免费课到实战课到后来的专栏和微课，已经习惯了在慕课网充电学习，期间也认识了不少小伙伴，他们个个都很有才也很骚~ 这门课就当作是在慕课的毕业课程吧，所以要更加认真学习阿，加油！加油！加油！ 在这里记录一下学习《web前端架构》课程的笔记和作业。 没有人天生爱学习，可是这个世界只要成绩,与君共勉。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/郭二蛋/01-第一周笔记和作业.html":{"url":"pages/郭二蛋/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） https://www/yuque.com/imooc-lego/zlz87z 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 普通用户使用的 H5 端（C端） 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 开发方式：H5 SSR 的方式。 企业/作者们使用的 B 端（B端） 使用者和用途：企业、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 平台管理员使用的管理系统（后台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计（统计这部分也会用到第三方，比如百度统计）。 开发方式：前后端分离的方式由 admin-fe + admin-server 构成。 模块设计 如下图所示（初次接触，画的不好，多多海涵） 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据关系流转 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/郭二蛋/02-第二周笔记和作业.html":{"url":"pages/郭二蛋/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"脚手架架构设计和框架搭建 站在前端研发的角度，分析开发脚手架的必要性 脚手架核心价值是将研发过程 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程数据化、系统化，使得研发过程可量化 自研脚手架和自动化构建工具的区别 市面上已经有了如Jenkins,travis等自动化构建工具，我们为什么还要自研脚手架？ 不满足需求：jenkins/travis通常需要在git hooks中触发，在服务端执行，无法覆盖研发人员本地的功能，如创建项目自动化，git操作自动化 定制复杂：jenkins/travis等工具的定制过程需要开发插件，要用到Java语言，对前端开发人员并不友好 从使用的角度来理解什么是脚手架 脚手架简介 其实脚手架的实质就是一个操作系统上的客户端。它通过命令行来执行，下面我们用一个常见的例子来举例： vue create project 上面这条看似简单常见的命令实际上由3个部分组成： 主命令：vue command：create command的param：project 这条命令大家应该都很常见了，它表示创建一个vue项目，项目的名字叫project。 脚手架执行原理 脚手架执行原理如下 在终端输入vue create project 终端解析出vue 在环境变量中找到vue命令 终端根据vue命令链接到实际文件vue.js 终端利用node执行vue.js vue.js解析command或者param vue.js执行command 执行完毕，退出执行 从应用的角度看 如何开发一个脚手架 新建一个文件夹（项目）使用npm进行初始化，打开package.json 配置bin字段，创建一个命令，指向bin/index.js； 将这个项目发布到npm； 全局安装这个脚手架； 使用第一步中bin字段中配置的命令来使用脚手架即可。 脚手架开发流程详解 开发流程 创建项目，使用npm初始化这个项目 创建脚手架入口文件，第一行写如下代码：#!/usr/bin/env node 配置package.json文件，添加bin属性 编写脚手架代码 将脚手架发布到npm 使用流程 安装脚手架：npm install -g imooc-test-erdan 使用脚手架：imooc-test-erdan / imooc-test-erdan -h 把库发布到npm的流程 打开npm的官网,注册一个账号； 打开邮箱，进行验证； npm login 输入账号、密码和邮箱进行登录； npm publish 将项目发布上去。 加深对npm link的使用和理解 新建&连接本地脚手架 mkdir erdan-test cd erdan-test npm init -y mkdir bin cd bin touch index.js npm link 新建本地库文件并在本地脚手架中使用 mkdir erdan-test-lib npm init -y npm link cd erdan-test npm link erdan-test-lib 取消链接本地库文件 cd erdan-test-lib npm unlink cd erdan-test # link存在的情况下执行下面这行 npm unlink erdan-test-lib # link不存在的情况下删除node_modules # 从安装发布到远程仓库上的库文件 npm i -S erdan-test-lib Lerna学习笔记 lerna简介 我们在使用lerna之前，要知道我们为什么要用lerna，我们不妨看看原生开发脚手架存在什么痛点。 重复操作 多package本地link 多package安装依赖 多package代码提交 多package单元测试 多package代码发布 版本一致性 发布时的版本一致性问题 发布后相互依赖版本升级问题 有了上面这些原生开发脚手架的痛点以后，就有了lerna这个优秀的工具。用一句话概述lerna就是一个优化基于git+npm的多package项目的管理工具。 lerna的优势就是可以大幅减少重复操作、提升操作的标准化。 lerna是架构优化的产物，lerna的产生揭示了一个架构真理：项目复杂度提升以后，就需要对项目进行架构优化，架构优化的目的往往都是以效能为核心。 lerna开发脚手架流程图 lerna实操 使用lerna搭建脚手架框架 mkdir tangmen-cli-dev npm init -y npm install -g lerna (// 全局安装) npm install lerna lerna -v ( // 输出版本号说明安装成功) lerna init (// 初始化lerna项目，会创建一个lerna.json) // 经过上面init这一步，会初始化git仓库，再搞一个.gitignore 配置一些不用上传的目录 git remote xxx (// 添加远程仓库) lerna create core (// 创建一个package) lerna create utils(// 又创建了一个package) lerna add (// 批量给两个package都安装依赖) lerna publish (// 发布项目) lerna核心操作 初始化lerna lerna init 创建package lerna create core // 在这一步可以给package起一个别名 为了防止和npm上其它包重名 可以加个前缀@ // 这里要注意的是后面想成功发布这种带前缀的私包的话，需要先在npm上创建一个组织 // 举个栗子：如果你给这个包起的名字叫@tangmen-cli-dev/core // 那你先要建一个叫tangmen-cli-dev的组织 安装依赖 lerna add mocha --dev (// 给所有package都安装) lerna add mocha package/core --dev (给core这个package安装依赖) 清空依赖 lerna clean // 手动从package的package.json中删除依赖 恢复依赖 lerna bootstrap 执行脚本 lerna exec -- rm -rf node_modules (// 在所有package中都执行) lerna exec --scope @tangmen-cli-dev/core --rm -rf node_modules (// 在特定package中执行脚本) 执行 npm script 命令 lerna run test (// 在所有package中都执行) lerna run --scope @tangmen-cli-dev/core test (// 在特定package中执行脚本) 发布项目 lerna publish 学习使用lerna发布项目时候遇到的几个小坑 有没有登录npm tag重复问题 加了@前缀的包默认是private的，要在package.json中改变一下publishConfig 如果发布的是带前缀@的包，一定一定记得要先在npm上穿件一个group package-lock.json不能添加在.gitignore中 作业 已经发布到npm上的简易脚手架 imooc-test-erdan erdan-test-lib @tangmen-cli-dev/core @tangmen-cli-dev/utils 理解Yargs常用API和开发流程 Yargs常用API Yargs.usage(提示脚手架用法) Yargs.strict(开启以后可以报错提示) Yargs.demandCommand(规定最少传几个command) Yargs.recommendCommands(在输入错误command以后可以给你推荐最接近的正确的command) Yargs.alias(起别名) Yargs.options(定义多个option) Yargs.option(定义option) Yargs.fail(错误处理方法) Yargs.group(分组) Yargs.wrap(命令行工具的宽度) Yargs.epilogue(命令行工具底部的提示) Yargs开发流程 脚手架初始化(将process.argv当参数传递给Yargs()) 脚手架命令注册(Yargs.command) 脚手架参数解析(Yargs.parse) 理解lerna实现原理 通过import-local来优先调用本地lerna命令 通过Yargs初始化脚手架，然后注册全局属性，再注册命令，最后通过parse方法解析参数 lerna命令注册时需要传入build和handler两个函数，build用来注册命令专属的options，handler用来处理命令的业务逻辑 lerna通过配置npm本地依赖的方式进行本地开发，具体写法是在package.json中写入：file:your-locale-module-path,在lerna publish的时候会自动替换路径 Node.js模块路径解析流程 Node.js项目模块路径解析是通过require.resolve方法来实现的 require.resolve就是通过Module._resolveFileName来实现的 require.resolve实现原理： Module._resolveFileName核心的3个点: 1.判断是否为内置模块 2.通过Module._resolveLookupPaths生成node_modules可能存在的路径 3.通过Module._findPath查询模块的真实路径 Module._findPath核心流程有4点: 1.查询缓存(将request和paths通过x00合并成cacheKey) 2.遍历paths,将paths与request组成文件路径basePath 3.如果basePath存在则调用fs.realPathSync获取真实路径 4.将真实路径缓存到Module._pathCache(key就是前面生成的cacheKey) fs.realPathSync核心流程有3点: 1.查询缓存（缓存的key为p，也就是上面Module._findPath生成的路径） 2.从左往右遍历路径字符串遇到/时，拆分路径，判断该路径是否为软连接，如果是软连接则查询其真实链接，并生成新路径P，然后继续往后遍历 3.遍历完成得到对应的真实路径，此时会将原始路径original作为key,真实路径保存为value保存到缓存中 require.resolve.paths等价于Module._resolveLoopupPaths,该方法用于获取所有node_modules可能存在的路径 require.resolve.paths的实现原理: 1.如果路径为根目录，直接返回['/node_modules'] 2.否则将路径字符串从后往前遍历，遇见/时，拆分路经，在后面加上node_modules,并传入一个paths数组，直至查询不到/后返回paths数组 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/郭二蛋/03-第三周学习笔记.html":{"url":"pages/郭二蛋/03-第三周学习笔记.html","title":"第三周学习笔记","keywords":"","body":"脚手架核心流程开发 脚手架整体架构设计 前端开发过程中的痛点和需求分析 痛点 存在大量重复代码的拷贝 协同开发时，分支混乱， 操作不规范，导致耗时 发布上线耗时，会出现各种各样的错误 需求分析 1.通用的组件/模板创建能力 模板支持定制，定制后能发布生效 模板支持快速接入，极低的接入成本 2.通用的项目/组件发布能力 发布过程中自动完成标准的 git 操作 发布完成后自动删除开发分支并创建 tag 发布后自动完成云构建、cdn、域名绑定 发布过程支持测试/正式两种模式 大厂是如何做项目的 自己动手画了一下示意图 git 操作规范 自己动手画了一下示意图 架构设计图 脚手架模块拆分策略 拆包原则 根据模块的功能来拆分： core: 核心模块 utils: 工具模块 commands: 命令模块 models: 模型模块 拆包结果 核心流程：core 命令模块：commands 初始化 发布 清除缓存 模型： models Command 命令 Project 项目 Component 组件 Npm 模块 Git 仓库 支撑层： utils Git 操作 云构建 工具方法 API 请求 Git API core 模块技术方案 core 模块的技术方案主要分为三个阶段，分别是准备阶段、命令注册、命令执行。第三周的课程内容主要是讲准备阶段。 涉及到的技术点 核心库 import-local commander 工具库 fs-extra (用于文件操作，基于 fs 封装的库) dotenv (可以获取到环境变量) semver (比较 package 的版本) root-check (进行 root 降级) user-home (拿到用户主目录) colors (可以在终端当中打印不同颜色的文本) npmlog (打印日志用，可以进行定制) 实现脚手架准备过程 检查版本号 思路：直接引用 package.json 文件，获取其中的 version 字段，打印到终端。注意：这里打印的时候可以使用 console.log，也可以使用 npmlog 这个依赖库。 const pkg = require('../package.json') function checkVersion() { console.log(pkg.version) // or log.info(pkg.version) } 检查 Node 版本 思路： 获取当前的 node 版本，和我们事先预设好的版本进行比对，如果当前版本较低，那么给用户一个提示。 const semver = require('semver') const colors = require('colors/safe') function checkNodeVersion() { // 获取当前的 node 版本 const currentVersion = process.version // 和我们事先预设好的版本进行比对 const lowestVersion = constant.LOWET_NODE_VERSION // 如果当前版本较低，那么给用户一个提示 if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`tangmen-cli 需要安装${lowestVersion}版本及以上的Node.js`)) } } 检查 root 是否启动 思路：这个功能比较简单，事情都让 root-check 这个库帮我们做了，我们只需要引用并且调用一下就可以实现 root 降级，规避掉因为 root 用户带来的一系列权限问题。 function checkRoot() { const rootCheck = require('root-check') rootCheck() } 检查用户主目录 const userHome = require('user-home') const pathExists = require('path-exists').sync function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前用户主目录不存在，请检查!')) } } 检查入参 let args function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs() } function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL } 检查环境变量的两种实现方式 function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量', process.env.CLI_HOME_PATH) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME) } process.env.CLI_HOME_PATH = cliConfig.cliHome } function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { config = dotenv.config({ path: dotenvPath }) } config = createDefaultConfig() log.verbose('环境变量', config, process.env.CLI_HOME) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME) } return cliConfig } 检查是否为最新版本 async function checkGlobalUpdate() { // 获取当前用户安装的版本是多少 const currentVersion = pkg.version const npmName = pkg.name // 通过接口请求拿到最新的版本号 const { getNpmSemverVersion } = require('@tangmen-cli-dev/get-npm-info') const latestVersion = await getNpmSemverVersion(currentVersion, npmName) // 拿npm上最新的版本号和本地安装的版本号进行对比，如果前者大于后者，则给用户一个明显的提示 if (latestVersion && semver.gt(latestVersion, currentVersion)) { log.warn( colors.yellow(`请手动更新${npmName}, 当前版本:${currentVersion}, 最新版本: ${latestVersion} 更新命令: npm install -g ${npmName} `) ) } } 本周作业完成情况 绘制脚手架架构设计图（已完成） 实现脚手架准备过程代码（已完成） 通过 commander 实现一个脚手架，包含自定义 option 和 command 功能：npm i -g imooc-test-erdan（已完成） 通过 webpack 和原生两种方式实现 Node 对 ES Module 的支持（已完成） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/郭二蛋/04-第四周笔记.html":{"url":"pages/郭二蛋/04-第四周笔记.html","title":"第四周笔记","keywords":"","body":"脚手架架构优化示意图 脚手架命令动态加载功能架构设计图 本周作业 1.完成tangmen-cli-dev脚手架动态命令执行代码编写 // core/exec/lib/index.js 'use strict'; const cp = require('child_process') const path = require('path') const Package = require('@tangmen-cli-dev/package') const log = require('@tangmen-cli-dev/log') const SETTINGS = { init: '@tangmen-cli-dev/init' } // 缓存目录 const CACHE_DIR = 'dependencies' async function exec() { // 目标目录 let targetPath = process.env.CLI_TARGET_PATH // 用户主目录 const homePath = process.env.CLI_HOME_PATH let storeDir = '' let pkg const cmdObj = arguments[arguments.length - 1] const cmdName = cmdObj.name() const packageName = SETTINGS[cmdName] const packageVersion = 'latest' // 是否执行本地代码 -> 否的话 就执行下面这段逻辑 if (!targetPath) { targetPath = path.resolve(homePath, CACHE_DIR) // 生成缓存路径 // 存储目录 storeDir = path.resolve(targetPath, 'node_modules') log.verbose('targetPath', targetPath) log.verbose('storeDir', storeDir) // 初始化一个Package pkg = new Package({ targetPath, packageName, packageVersion }) // 如果Package存在 if (await pkg.exists()) { // 更新package await pkg.update(); } else { // 安装package await pkg.install(); } } else { pkg = new Package({ targetPath, packageName, packageVersion }) } // 是否执行本地代码 -> 选择是的话 执行下面这段逻辑 // 获取本地代码入口文件 const rootFile = pkg.getRootFilePath(); // 本地代码存在的情况下执行以下逻辑，否则终止执行 if (rootFile) { try { const args = Array.from(arguments); const cmd = args[args.length - 1]; const o = Object.create(null); Object.keys(cmd).forEach(key => { if (cmd.hasOwnProperty(key) && !key.startsWith('_') && key !== 'parent') { o[key] = cmd[key]; } }); args[args.length - 1] = o; // 生成指令执行代码 const code = `require('${rootFile}').call(null, ${JSON.stringify(args)})`; // 启动新进程执行代码 const child = spawn('node', ['-e', code], { cwd: process.cwd(), stdio: 'inherit', }); // 执行产生异常时 打印异常 并终止执行 child.on('error', e => { log.error(e.message); process.exit(1); }); // 执行完毕 正常退出 child.on('exit', e => { log.verbose('命令执行成功:' + e); process.exit(e); }); } catch (e) { log.error(e.message) } } } // windows操作系统spawn执行命令兼容 function spawn(command, args, options) { const win32 = process.platform === 'win32' const cmd = win32 ? 'cmd' : command const cmdArgs = win32 ? ['/c'].concat(command, args) : args return cp.spawn(cmd, cmdArgs, options || {}) } module.exports = exec; // models/package/lib/index.js 'use strict'; const path = require('path') const fse = require('fs-extra') const pkgDir = require('pkg-dir').sync const pathExists = require('path-exists').sync const npminstall = require('npminstall') const {isObject} = require('@tangmen-cli-dev/utils') const formatPath = require('@tangmen-cli-dev/format-path') const {getDefaultRegistry, getNpmLastVersion} = require('@tangmen-cli-dev/get-npm-info') class Package { constructor(options) { // 判断边界情况 如果没有传参 直接提示用户options不得为空 if (!options) { throw new Error('Package类的options参数不能为空') } // 如果参数不是对象的话提示用户options必须是对象 if (!isObject(options)) { throw new Error('Package类的options参数必须是对象') } // package的目标路径 this.targetPath = options.targetPath // 缓存Package的路径 this.storeDir = options.storeDir // package的名字 this.packageName = options.packageName // package的version this.packageVersion = options.packageVersion // package的缓存目录前缀 this.cacheFilePathPrefix = this.packageName.replace('/', '_') } // 准备(预检)阶段 // 如果缓存package的路径目录不存在的话，我们用fs模块创建一个目录 // 如果使用者传进来的版本参数是latest，那么我们就要调取API获取最新版本的信息 async prepare() { if (this.storeDir && !pathExists(this.storeDir)) { fse.mkdirpSync(this.storeDir) } if (this.packageVersion === 'latest') { this.packageVersion = await getNpmLastVersion(this.packageName) } } // 读取缓存路径 get cacheFilePath() { return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}`); } // 获取指定的缓存路径 getSpecificCacheFilePath(packageVersion) { return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}`); } // 判断当前的package是否存在 async exists() { if (this.storeDir) { await this.prepare() return pathExists(this.cacheFilePath) } else { return pathExists(this.targetPath) } } // 安装package async install() { await this.prepare() return npminstall({ root: this.targetPath, storeDir: this.storeDir, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: this.packageVersion }] }) } // 更新package async update() { await this.prepare() const latestPackageVersion = await getNpmLastVersion(this.packageName) const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion) if (!pathExists(latestFilePath)) { await npminstall({ root: this.targetPath, storeDir: this.storeDir, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: latestPackageVersion }] }) this.packageVersion = latestPackageVersion } } // 获取入口文件的路径 async getRootFilePath() { function _getRootFile(targetPath) { // 1.获取package.json所在目录 const dir = pkgDir(targetPath) if (dir) { // 2.读取package.json const pkgFile = require(path.resolve(dir, 'package.json')) // 3.寻找main/lib if (pkgFile && pkgFile.main) { // 路径的兼容 return formatPath(path.resolve(dir, pkgFile.main)) } } return null } if (this.storeDir) { return _getRootFile(this.cacheFilePath) } else { return _getRootFile(this.targetPath) } } } module.exports = Package 'use strict'; const semver = require('semver') const colors = require('colors/safe') const log = require('@tangmen-cli-dev/log') const LOWEST_NODE_VERSION = '12.0.0' class Command { constructor(argv) { if (!argv) { throw new Error('参数不能为空') } if (!Array.isArray(argv)) { throw new Error('参数必须为数组') } if (argv.length { let chain = Promise.resolve() // 检查node版本 chain = chain.then(() => this.checkNodeVersion()); // 初始化参数 chain = chain.then(() => this.initArgs()); // init业务逻辑 chain = chain.then(() => this.init()); // 执行 chain = chain.then(() => this.exec()); chain.catch(err => { log.error(err.message) }) }) } // 初始化参数 initArgs() { this._cmd = this._argv[this._argv.length - 1] this._argv = this._argv.slice(0, this._argv.length - 1) } // 检查node版本 checkNodeVersion() { const currentVersion = process.version const lowestVersion = LOWEST_NODE_VERSION if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`tangmen-cli 需要安装${lowestVersion}版本及以上的Node.js`)) } } // 交给子类去实现 init() { throw new Error('init必须实现！'); } // 交给子类去实现 exec() { throw new Error('exec必须实现！'); } } module.exports = Command Node多进程源码总结 exec和execFile/fork/spawn的区别？ exec: 原理是调用/bin/sh -c执行我们传入的shell脚本，底层调用了execFile execFile: 原理是执行我们传入的file和args，底层调用了spawn创建和执行子进程，并建立了回调，一次性将所有的stdout和stderr结果返回 spawn: 原理是调用了internal/childprocess，实例化了ChildProcess子进程对象，再调用child.spawn创建子进程并执行命令，底层是调用了child. handle.spawn执行process_wrap中的spawn方法，执行过程是异步的，执行完毕后通过PIPE进行单向数据通信，通信结束后子进程会发起onexit回调，同时Socket会执行close回调 fork: 原理是通过spawn创建和执行子进程命令，采用node执行命令，通过setupchannel创建IPC用于子进程和父进程之间的双向通信 data/error/exit/close回调的区别 data: 主进程读取数据过程中通过onStreamRead发起的回调 error: 命令执行失败后发起的回调 exit: 子进程关闭完成后发起的回调 close: 子进程所有Socket通信端口全部关闭后发起的回调 stdout close/stderr close: 特定的PIPE读取完成后调用onReadableStreamEnd关闭Socket时发起的回调 Node多进程执行阶段总结 补充：在自己电脑上如何配置多个公钥 因为疫情的原因，国际庄现在不让出门，我平时是用公司的电脑进行练习的，这次用自己的电脑来配置公钥，但是遇到一个问题：我们这个仓库是在github的，但是我另一个仓库是在gitee上面存放的，于是我使用现有的账号可以正常拉取、推送到github，但是推送到gitee的时候它告诉我说权限不足。 通过百度得知是有办法解决的，那就是在一台电脑上配置多个ssh-key，经过参考网上的教程，终于调通了，将这次经历记下来，如果你和我有一样的问题，希望能帮到你。 这里偷个懒，将教程的链接直接贴在这里了：https://www.cnblogs.com/popfisher/p/5731232.html 石家庄加油！河北加油！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/野火/":{"url":"pages/野火/","title":"野火","keywords":"","body":"野火 web前端架构师学习 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/野火/01-作业-架构设计方案.html":{"url":"pages/野火/01-作业-架构设计方案.html","title":"作业 架构设计方案","keywords":"","body":"慕课乐高架构设计方案 需求文档 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf 范围 H5 展示 作品编辑发布 后台管理 模块设计 模块拆分 H5：作品展示 B端前端：画布能力，提供作者编辑、发布作品和模板。 B端服务端：给B端前端提供接口服务。 后台管理前端：管理作品和用户，查看数据统计。 后台管理服务：提供后台管理前端相关接口服务。 公共组件库：H5展示的组件和B端作品编辑组件的复用。 统计服务：统计数据以及自定义事件，提供给B端的作品反馈和后台管理的数据量统计。 脚手架：创建/发布项目。 模块关系 数据结构设计 作品数据结构 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，例如是否展示，是否推荐，是否是新的 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容 ] } ] } } 数据流转关系 C端、B端、后台管理共用一个数据库。 新增作品：新建一条json数据。 修改作品：修改json数据。 删除作品：标识json数据删除标记。 发布作品：标识json数据发布标记。 屏蔽作品：标识json数据屏蔽标记。 C端获取作品：获取json,判断作品是否展示。 扩展性 组件扩展 编辑器扩展，如支持音频等。 页面扩展：增加多语言。 作品扩展：增加类型，分析用户作品用途，如贺卡等。 开发提效 脚手架：创建/发布 组件平台 运维保障 线上服务和运维服务 安全、监控和报警 服务扩展性 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/點滴心宇/":{"url":"pages/點滴心宇/","title":"點滴心宇","keywords":"","body":"点滴心语 - 作业&笔记 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/點滴心宇/01-第一周笔记和作业.html":{"url":"pages/點滴心宇/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 普通用户使用的 H5 端（C端） 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 开发方式：H5 SSR 的方式。 企业/作者们使用的 B 端（B端） 使用者和用途：企业、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 平台管理员使用的管理系统（后台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计（统计这部分也会用到第三方，比如百度统计）。 开发方式：前后端分离的方式, 前端 admin-fe + 后端 admin-server 。 模块设计 这张图取自双越老师 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余数据结构示例 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据关系流转 这张图取自学员郭二蛋 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/點滴心宇/02-第二周笔记和作业.html":{"url":"pages/點滴心宇/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"Yargs 配置 #!/usr/bin/env node const dedent = require('dedent') const yargs = require('yargs/yargs'); const pkg = require('../package.json'); const { hideBin } = require('yargs/helpers'); const cli = yargs(); const argv = process.argv.slice(2); const context = { winbridgeVersion: pkg.version } cli .usage('Usage: imooc-test [command] ') .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") .strict() .recommendCommands() .alias(\"h\", \"help\") .alias(\"v\", \"version\") .wrap(cli.terminalWidth()) .epilogue(dedent`命令行到这里就结束了`) .options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) .option('registry', { type: 'string', describe: 'Define global registry', alias: 'r' }) .group(['debug'], 'Dev Options') .group(['registry'], 'Extra Options') .command('init [name]', 'Do init a project', (yargs) => { yargs.option('name', { type: 'string', describe: 'Name of a project', alias: 'n' }); }, (argv) => { console.log(argv) }) .command({ command: \"list\", aliases: [\"ls\", \"la\", \"ll\"], describe: \"List local packages\", builder: (yargs) => {}, handler: (argv) => { console.log(argv); } }) .fail((err, msg) => console.log(err, msg)) .parse(argv, context); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/點滴心宇/03-第三周笔记和作业.html":{"url":"pages/點滴心宇/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"大厂做项目的流程 大厂的git操作规范 脚手架需求分析 痛点分析 痛点分析: 创建项目/组件时，存在大量重复代码拷贝：快速复用已有沉淀 协同开发时，由于git操作不规范，导致分支混乱，操作耗时：制定标准的git操作规范并集成到脚手架 发布上线时，容易出现各种错误：制定标准的上线流程和规范并集成到脚手架 需求分析 通用的研发脚手架 通用的项目/组件创建能力 模板支持定制 模板支持快速接入，极地的接入成本 通用个的项目/组件发布能力 发布过程自动完成标准的git操作 发布成功后自动删除开发分支并创建tag 发布后自动完成云构建、OSS上传、CDN上传、域名绑定 发布过程支持测试/正式两种模式 winbridge-cli 脚手架架构设计图 核心模块 脚手架 脚手架核心框架 初始化体系 标准git操作体系 发布体系 服务 OPEN API WebSocket 支撑体系 本地缓存 模板库 数据体系 代码仓库 资源体系 远程缓存体系 脚手架拆包策略 拆包结果 核心流程: core 命令: commands 初始化 发布 清除缓存 模型层: models Command 命令 Project 项目 Component 组件 Npm 模块 Git 仓库 支撑模块: utils Git 操作 云构建 工具方法 API 请求 Git API 拆分原则 根据模块的功能拆分: 核心模块: core 命令模块: commands 模型模块: models 工具模块: utils core模块技术方案 命令执行流程 准备阶段 checkPkgVersion 检查当前脚手架的版本号 function checkPkgVersion() { log.info('cli-version', require('package.json').version) } checkNodeVersion 检查Node版本号 function checkNodeVersion() { const semver = require('semver'); // 第一步， 获取当前Node版本号 const currentVersion = process.version; // 第二步， 比对最低版本号 const lowertVersion = '12.0.0'; if(!semver.gte(currentVersion, lowertVersion)) { throw new Error(colors.red(`winbridge-cli 需要安装 v${lowertVersion} 以上版本的 Node.js`)); } } checkRoot 检查root账户 function checkRoot() { const rootCheck = require('root-check'); rootCheck(); } checkUserHome 检查用户主目录 function checkUserHome() { const userHome = require('userHome); if(!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登录用户主目录不存在！')); } } checkInputArgs 检查命令行参数 // 检查命令行参数 let args; function checkInputArgs() { const minimist = require('minimist'); args = minimist(process.argv.slice(2)); checkArgs(); } // 检查参数 function checkArgs() { if(args.debug) { process.env.LOG_LEVEL = 'verbose'; } else { process.env.LOG_LEVEL = 'info'; } log.level = process.env.LOG_LEVEL; } checkEnv 检查环境变量 // 检查环境变量 const path = require('path'); const userHome = require('user-home'); const pathExits = require('path-exists'); function checkEnv() { const dotenv = require('dotenv'); const dotenvPath = path.resolve(userHome, '.env'); // C:/Users/86130/.env if(pathExists(dotenvPath)) { // 当这个文件存在的时候会生成一个config，不存在就生成一个默认的config dotenv.config({ path: dotenvPath }); // 将.env文件中的内容取出加载到process.env中 } createDefaultConfig(); log.verbose('环境变量', process.env.CLI_HOME); } // 创建默认环境变量配置文件 function createDefaultConfig() { const cliConfig = { home: userHome }; if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME); } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME); } process.env.CLI_HOME = cliConfig.cliHome; } checkGlobalUpdate 检查是否需要全局更新 async function checkGlobalUpdate() { // 1.获取当前版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; // const npmName = '@imooc-cli/core'; // 2.调用npm API, 获取所有版本号 http://registry.npmjs.org/@winbridge-cli/core // 3.提取所有版本号，比对哪些版本号是大于当前版本号 // 4.获取最新的版本号,提示更新 const { getNpmSemverVersion } = require('@winbridge-cli/get-npm-info'); const lastVersions = await getNpmSemverVersion(currentVersion, npmName); if(lastVersions && semver.gt(lastVersions, currentVersion)) { log.warn('更新提示', colors.yellow(`请手动更新 ${npmName} 当前版本: ${currentVersion} 最新版本: ${lastVersions} 更新命令: npm install -g ${npmName}`)) } } *** @winbridge-cli/get-npm-info *** 'use strict'; const axios = require('axios'); const urlJoin = require('url-join'); const semver = require('semver'); // 1 async function getNpmSemverVersion(baseVersion, npmName, registry) { const versions = await getNpmVersions(npmName, registry); const newVersions = getNpmSemverVersions(baseVersion, versions); if(newVersions && newVersions.length > 0) return newVersions[0]; return null; } // 2 async function getNpmVersions(npmName, registry) { const data = await getNpmInfo(npmName, registry); if(data) { return Object.keys(data.versions); } else { return []; } } // 3 function getNpmInfo(npmName, registry) { if(!npmName) { return null; } const registryUrl = registry || getDefaultRegistry(); const npmInfoUrl = urlJoin(registryUrl, npmName); return axios.get(npmInfoUrl) .then(res => { if(res.status === 200) { return res.data; } return null; }).catch(err => { return Promise.reject(err); }) } // 4 function getDefaultRegistry(isOriginal = false) { return isOriginal ? 'http://registry.npmjs.org' : 'http://registry.npm.taobao.org'; } // 5 function getNpmSemverVersions(baseVersion, versions) { return versions .filter(versions => semver.satisfies(versions, `^${baseVersion}`)) .sort((a, b) => semver.gt(b, a)); } 命令注册 命令执行 涉及技术点 核心库 import-local commander #!/usr/bin/env node const { Command } = require('commander'); const pkg = require('../package.json'); // 第一种使用方法: 获取commande的单例 // const { program } = commander; // 第二种使用方法: 手动实例化一个commander实例 const program = new Command(); // 注册参数 program .name(Object.keys(pkg.bin)[0]) // 包名 .usage(' [options]') // 使用建议 .version(pkg.version) // 获取版本号 .option('-d, --debug', '是否开启调试模式', false) // 配置参数 .option('-e, --envName ', '获取环境变量名称', '.imooc-test') // 获取环境变量 // console.log(program.envName); // 获取输入的环境变量参数 // program.outputHelp(); // 输出帮助信息 // console.log(program.opts()); // 输出所有注册的参数 { version: '1.0.3', debug: false, envName: '123' } // command 注册的是当前脚手架下的命令且返回值是command对象而不是program对象 const clone = program.command('clone [destination]'); // 注册命令名称 clone .description('clone a repository into a newly created directory') .option('-f, --force', '是否强制克隆') .action((source, destination, cmdObj) => { console.log(source, destination, cmdObj.force); }); // 注册clone命令的回调 // addCommand 注册的是当前脚手架下的子命令 const service = new Command('service'); service .command('start [port]') .description('start service at some port') .action((prot) => { console.log('do service start', prot) }); service .command('stop [port]') .description('stop service') .action((prot) => { console.log('stop service') }); program.addCommand(service); program .command('install [name]', 'install one or more package', { // 这条命令执行的是个脚本文件相当于在当前目录下执行node node_module@winbridge-cli/core/bin executableFile: 'node_modules/@winbridge-cli/core/bin', // 设置可执行文件路径 // isDefault: true, // 执行imooc-test的时候默认执行这条命令 // hidden: true // 隐藏imooc-test -h 中command的隐藏 }) .alias('i'); // 命令注册的自动匹配 // program // .arguments(' [options]') // .description('test command', { // cmd: 'command to run', // options: 'options for command' // }) // .action((cmd, options) => { // console.log(cmd, options) // }) // 高级定制1: 自定义help信息 program.helpInformation() 获取帮助信息 // console.log(program.helpInformation()); // 方法一 // program.helpInformation = function() { return '' } // 定制 imooc-test --help 返回的帮助信息 // 方法二 // program.on('--help', function() { // 监听 命令行输入的 --help 参数, 并返回信息 // console.log('your help information'); // }) // 高级定制2: 实现 dubug 模式 program.on('option:debug', function() { if(program.debug) { process.env.LOG_LEVEL = 'verbose'; } console.log(process.env.LOG_LEVEL); }) // 高级定制3: 对未知命令监听 program.on('command:*', function(obj) { console.error('未知的命令:' + obj[0]); const availableCommands = program.commands.map(cmd => cmd.name()); console.log('可用命令: '+ availableCommands.join(', ')); }); program .parse(process.argv); // 参数解析 工具库 npmlog (命令行打印) fs-extra () semver (版本比对) colors (命令行输出自定义颜色字体) user-home (获取文件主目录) dotenv (将.env文件内的配置加载到process.env中) root-check (检查是否为root用户) 脚手架执行准备过程实现知识点 require支持加载资源的类型 .js => module.exports/exports .json => JSON.parse .node => process.dloper any => .js (如果任意文件类型内包含的是js代码,那么同样可以解析) 新模块的创建及引用 lerna create 如果需要修改新模块lib目录下的.js文件名, 则需要在新模块package.json文件中修改main的入口 在需要引用新模块的模块中, 修改package.json的dependencies(如：\"@winbridge-cli/log\": \"file:../../utils/log\") 重新执行npm link 这样就可以通过require引入新模块 npmlog可调用的方法 默认 log.level 为'info'，所以小于2000等级的方法都不会被调用 log.addLevel('silly', -Infinity, { inverse: true }, 'sill') log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb') log.addLevel('info', 2000, { fg: 'green' }) log.addLevel('timing', 2500, { fg: 'green', bg: 'black' }) log.addLevel('http', 3000, { fg: 'green', bg: 'black' }) log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' }) log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN') log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!') log.addLevel('silent', Infinity) Node项目如何支持ES Module 方案一: webpack + bable-loader 安装模块 npm i -D babel-loader @babel/core @babel/preset-env npm i -D @babel/plugin-transform-runtime npm i -D @babel/runtime-corejs3 创建webpack.config.js const path = require('path'); module.exports = { entry: './bin/core.js', output: { path: path.join(__dirname, '/dist'), filename: 'core.js' }, mode: 'development', target: 'node', // 默认是 web 环境 // 以上四步完成后就可以支持es module // 还想要支持低版本的node, 就需要配置babel-loader转义 module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, regenerator: true, useESModules: true, helpers: true } ] ] } } } ] } } 方案二: Node原生支持ES Module 这种方案的实现,所有文件必须以.mjs结尾。文件内必须以ES Module的方式导出或引用 创建index.mjs文件 node版本小于14 node --experimental-modules index.mjs node版本大于14 node index.mjs Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/🐟红鲤驴与绿驴鱼/":{"url":"pages/🐟红鲤驴与绿驴鱼/","title":"🐟红鲤驴与绿驴鱼","keywords":"","body":"红鲤驴与绿驴鱼 - 学习分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/🐟红鲤驴与绿驴鱼/01-作业-架构方案设计.html":{"url":"pages/🐟红鲤驴与绿驴鱼/01-作业-架构方案设计.html","title":"作业 架构方案设计","keywords":"","body":"整体架构设计方案 v1.0 需求 需求地址 范围 整体设计，架构设计，没有细节 编辑b端(前后分离)、项目服务端(中台)、管理端(前后分离)、作品展示c端(服务端渲染) 模块设计 模块的拆分和关系图，结果模块的关键功能，职责等特殊的模块重点说明 组件库，独立第三方，同时用于编辑器和 H5 自研统计服务，为何自研 作品的数据结构 vuex store 的结构，解释数据流转关系图 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } vuex getter 选择当前选中的图层 { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 扩展组件，数据结构层面扩展编辑器的功能，例如：组件隐藏、锁定扩展页面的配置（讨论，集思广益） 开发提效 脚手架 创建：可以开发快速创建项目原型的脚手架，来省去配置项目初始化的时间。 脚手架 发布：。。。 组件平台 运维保障 线上服务和运维服务安全监控和报警服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🎓风情炀/":{"url":"pages/👨‍🎓风情炀/","title":"👨‍🎓风情炀","keywords":"","body":"&#x1F468;‍&#x1F393;风情炀 - 作业 先入坑打卡，后面补充 目录 01-weak01学习笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🎓风情炀/01-weak01学习笔记.html":{"url":"pages/👨‍🎓风情炀/01-weak01学习笔记.html","title":"Weak01学习笔记","keywords":"","body":"慕课乐高架构方案设计文档 有空再补充 需求背景 范围 模块设计 数据结构 扩展性保证 研发提效 运维保障 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫Sam老师/01-前端未来趋势分析.html":{"url":"pages/👨‍🏫Sam老师/01-前端未来趋势分析.html","title":"前端未来趋势分析","keywords":"","body":"前端未来趋势分析 前端未来趋势是一个非常大的命题，它错综复杂，涉猎广泛，今天我试图从前端工程师的视角来分析行业未来的发展趋势，这与我们每个前端工程师都息息相关。 趋势一：融合 基本判断：前端与其他领域结合更加紧密，前端领域分工将更加精细 在技术融合的趋势下，前端将不断与其他领域进行融合，开发出各种令人惊叹的应用： 前端+算法：算法将大大提升前端效能，大家可以参考imgcook，这是一个由淘宝团队推出的根据设计稿自动生成前端代码的工具，相信在不远的未来根据设计稿直接生成业务代码不是梦！ 前端+后端：在Node.js+express/koa2/egg.js等一系列后端框架的驱动下，前端和后端结合越来越紧密，从最早的前后端分离，到Serverless、GraphGL，在可预见的未来，前端工程师将包揽所有业务逻辑，并且通过Serverless技术快速生产API，独立完成整个业务系统的研发、发布和运维，所以一手流利的服务端代码能力是必备技能。 前端+架构：前端架构师是未来发展的主流趋势，每个具有一定规模的前端团队都需要合格的前端架构师，前端架构师将完成团队基础架构和工具链设计和开发，并为团队或公司设计和规划业务架构，为公司创造海量业务价值。 趋势二：中台 基本判断：前端中台系统将迅速崛起和壮大 前端工程化的快速普及催生了前端中台的快速发展，一线互联网大厂前端中台发展速度极快，不管是面向营销的h5搭建系统，还是Native动态定制，又或是复杂的中后台可视化搭建平台，可谓百花齐放、应有尽有，前端中台已然成为前端发展的重要方向之一，未来将有大量前端工程师专门从事中台开发，中台开发的核心是前端架构师，他需要负责复杂的中台系统架构、研发效能监控和提升，这是一个极具挑战的工作，但大势所趋，中台的时代已经到来。 趋势三：跨端 基本判断：跨端技术的迅速发展催生新型研发模式 曾几何时，App和Web是完全不同的两个领域，但h5、小程序的火爆，加上javascript日趋成熟，各种跨端技术如雨后春笋，从构建时到运行时，跨端技术正大踏步地前行，面对跨端技术，前端工程师必须拥抱。而跨端技术的背后是高水准前端架构师的精巧构思，掌握跨端技术，合理选择技术栈，是前端工程师的必修课。 总结 要跟紧时代，与时俱进，那么就一定要保持开放的思维，不断吸收新的知识，不断迭代旧的思想，不断拓宽能力边界。前端的发展势头汹涌而又壮阔，每一名前端工程师都有可能成为弄潮儿，这是前端的黄金时代，也是我们每一名前端工程师的黄金时代。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫Sam老师/02-为什么要学习前端架构.html":{"url":"pages/👨‍🏫Sam老师/02-为什么要学习前端架构.html","title":"为什么要学习前端架构","keywords":"","body":"为什么要学习前端架构 无处不在 首先架构无处不在，架构的本质是解决业务快速增长中的技术复杂度问题，所以只要你所在的组织业务存在增长，就需要用架构的思想去解决一些问题，比如： 项目代码量越来越大，如何提升项目的构建性能？ 如何抽取项目公共模块进行快速复用？ 如果你没有架构思维和相对应的技术能力，面对这些问题的时候是无从下手的。所以学习架构的第一目标是为了应对和解决项目开发中碰到的各类问题，通常需要架构层面去解决的问题包括： 工程问题 复杂业务 复用问题 至关重要 其次架构至关重要，2009年node诞生以后，前端工程化得到飞速发展，前端项目量级和研发效率直线上升，目前前端领域已出现进一步细分的趋势，主要有三个方向： 前端业务开发 前端全栈开发（偏服务端node） 前端基础架构开发（偏工具） 而前端架构师可能是这三个岗位中的任意一个： 偏业务的前端架构师主要解决复杂业务问题 偏服务端的前端架构师主要解决服务架构和运维体系问题 偏基础架构的前端架构师主要解决研发体系和效能的问题 所以不管你当前处于哪个岗位、哪个阶段，前端架构对你而言都有价值、都非常重要。 直通高薪 最后架构直通高薪，通过调研不难发现很多中级以上的前端开发岗位中已经对架构能力有需求，包括组件库研发、性能优化、工具开发等等，而高级前端职位中，前端架构能力几乎是绝对和必须的，随着前端技术的飞速发展，薪资基于已经与服务端旗鼓相当，所以掌握架构能力毫无疑问是快速进阶高薪的法宝。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫Sam老师/03-脚手架入门.html":{"url":"pages/👨‍🏫Sam老师/03-脚手架入门.html","title":"脚手架入门","keywords":"","body":"脚手架入门 脚手架简介 脚手架本质是一个操作系统的客户端，它通过命令行执行，比如： vue create vue-test-app 上面这条命令由 3 个部分组成： 主命令: vue command: create command 的 param: vue-test-app 它表示创建一个 vue 项目，项目的名称为 vue-test-app，以上是最一个较为简单的脚手架命令，但实际场景往往更加复杂，比如： 当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装 vue 项目，此时我们就可以输入： vue create vue-test-app --force 这里的 --force 叫做 option，用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景： 通过 vue create 创建项目时，会自动执行 npm install 帮用户安装依赖，如果我们希望使用淘宝源来安装，可以输入命令： vue create vue-test-app --force -r https://registry.npm.taobao.org 这里的 -r 也叫做 option，它与 --force 不同的是它使用 -，并且使用简写，这里的 -r 也可以替换成 --registry，有的同学可能要问，为什么老师知道这个命令，其实我们输入下面的命令就可以看到 vue create 支持的所有 options： vue create --help -r https://registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param，其实 --force 可以理解为：--force true，简写为：--force 或 -f 脚手架的执行原理 脚手架的执行原理如下： 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command / options vue.js 执行 command 执行完毕，退出执行 从应用的角度看如何开发一个脚手架 这里以 vue-cli 为例 开发 npm 项目，该项目中应包含一个 bin/vue.js 文件，并将这个项目发布到 npm 将 npm 项目安装到 node 的 lib/node_modules 在 node 的 bin 目录下配置 vue 软链接指向 lib/node_modules/@vue/cli/bin/vue.js 这样我们在执行 vue 命令的时候就可以找到 vue.js 进行执行 还有很多疑问需要解答 为什么全局安装 @vue/cli 后会添加的命令为 vue？ npm install -g @vue/cli 全局安装 @vue/cli 时发生了什么？ 为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫双越老师/":{"url":"pages/👨‍🏫双越老师/","title":"👨‍🏫双越老师","keywords":"","body":"双越老师 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫双越老师/01-我如何理解Web前端架构师的角色和职责.html":{"url":"pages/👨‍🏫双越老师/01-我如何理解Web前端架构师的角色和职责.html","title":"我如何理解Web前端架构师的角色和职责","keywords":"","body":"我如何理解 Web 前端架构师 的角色和职责 架构师的核心指责：保证业务增长 —— 《聊聊架构》 架构师这个角色，在行业中和各个公司中，都没有明确的定位。甚至，有些公司都没有架构师这个职位。 但是，你的身边总是需要这样的角色。他们技术能力好，有深度、有广度，熟悉公司产品的业务需求，熟悉公司各个部门和负责人，遇到问题能拆分任务，计划和跟踪 …… 即，他们不仅仅是做开发，还有其他更加重要的工作。有了这个角色，你就有了依靠，你就会感觉很踏实，很放心。这种角色，就是架构师。 特别是近些年技术栈细分严重，大家各司其职，更加需要这样的角色去整合团队的工作。保证多人协作顺利有效的进行，否则就乱套了。 无论是大公司还是创业公司，只要有了研发团队，不是单兵作战或者小作坊（通讯靠吼），就需要这样的角色。 下面，我根据我的工作经验和理解，说一下 Web 前端架构师这个角色的一些职责。虽然没法给出一个文字定义，但可以从不同的方面来表达一下。 负责人 首先，作为 Web 前端架构师，你就是前端及相关技术方面的负责人。只要跟你相关的，你都要负责，赢了给你奖励，输了你也要得到惩罚。 所以，架构师就是“将”。所谓“千军易得一将难求”，招聘人员很简单，但招聘一个架构师是很难的。一般情况，都是从本公司培养。 三国时 “蜀国无大将廖化作先锋”，蜀国此时也不是没人了，只是没将了。 这个项目或者系统，交给一个架构师（再配一些开发人员）老板就会安心，一切都在掌控之中，不会发生惊喜，但也不会有意外。 高效 有节奏 稳定 安全 高效：发挥每个人的最大价值，不让人闲着。但这并不代表要加班，要 996 —— 反而加班 996 就是因为没有高效而导致的。 有节奏：当下有安排，未来有计划，做完一个任务立马安排下一个任务，持续进行中。 稳定：完善的研发流程（单元测试，接口测试），完善的监控报警体系，才能保证稳定，课程中都会讲到。 安全：不会被轻易攻击，如最常见的 DDOS XSS SQL 注入等。 PS：如何做到以上几点，以及如何让老板放心，这都是有方法论的。具体哪些方法，大家可以参考我们的课程。 深入理解业务 脱离业务的架构，就是耍流氓，架构是基于业务的 —— 要再说：不想做业务，想做架构。 架构师的核心职责是保证业务增长，翻译过来就是：如何用技术只支撑现在和未来的业务。所以，你得非常清楚的了解公司产品的业务，未来规划和目标。 所以，建议各位同学，如果现在的工作机会还不错，一定要积极参与到公司产品业务的讨论中，不要只是一门心思的写代码。 技术是为业务服务的，光靠技术，没有持久的竞争力。 个人技术能力 架构师也要写代码，且要有广度和深度。 广度：做技术方案时，要有多种选择，且能熟悉前后端的关系。 深度：要能解决一些别人搞不定的问题，不一定是亲自解决，可以指导从某个方向入手查询。 总结 无论公司有没有架构师的职位，无论你现在是否还在一线开发。 只要是作为开发人员，你都要学会以架构师的思维去思考问题，这样才能保证持久竞争力。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫双越老师/02-Web 前端架构师课 vs 普通实战课.html":{"url":"pages/👨‍🏫双越老师/02-Web 前端架构师课 vs 普通实战课.html","title":"Web 前端架构师课 Vs 普通实战课","keywords":"","body":"Web 前端架构师课 vs 普通实战课 我们要做一门不一样的课，要能体现出“架构师”这个主题，要和普通的实战课做出明显的区别。 在课程制作过程中，我们三位讲师经常自我提问：我们这门课和实战课有何区别呢？—— 我们必须要说服自己，否则就自欺欺人了。 最终，我们总结出了以下几点，证明我们这门课和实战课确实完全不一样。 真正的线上项目，不是 demo 有一次和七月老师打电话，我们聊了一个多小时，我们都承认，现在的实战课，都是 demo ，远远达不到生产环境的级别要求。 线上项目和 demo 虽然功能看似一样，但实则完全不同。随随便便就能说出很多方面： demo 没有线上环境，如域名，服务器，数据库等 demo 没有上线、回滚的流程 demo 没有运维监控和报警，这些在实际工作中都是重点 demo 没有统计、分享等正式的业务场景 demo 不用考虑安全、攻击、敏感内容过滤等 demo 不用担心万一半夜出 bug 该怎么办？ …… 还有很多，一次性说不完，都在课程里 【注意】并不是说课程中讲到了上述知识点，它就是线上项目了。光讲知识点没用，必须得把项目正式上线，用正式的域名、证书、服务器等跑起来，而且要流程闭环才可以。 业务负责度高，流程闭环 脱离了业务谈架构，就是耍流氓。做架构师课，就得用复杂度高的业务，否则体现不出来。 h5 编辑器，是前端领域中一个非常复杂的业务，这跟“社区” “电商”这种实战课项目，不是一个难度级别。 全栈，流程闭环：创建 h5 ，发布，分享，还有统计，这是闭环的，实战课里是没有这样做的。实战课讲的，都是完整流程的一个环节而已。 不讲业务代码，不讲基础知识 业务代码会演示，但不会在一行一行带着写了。基础知识也不再详细讲，如 vue3 ts 语法等。 实战课基本都 20h 左右，而且要详细演示代码，根本做不出来这么复杂的项目。 我看过其他的号称架构师的课，虽然时间很长，但是大部分都用在讲基础知识上，做的项目也远远达不到这个复杂度。 有些课程会讲框架源码、造轮子，这看似很牛 x ，但其实这些仅仅是架构师的一个能力“个人技术深度”，对于架构师整体的技能，这是很小的一个方面，算不了什么。 更关注设计、研发流程、运维 这些远比开发重要，特别是运维。 如何开发，大部分业务代码，大家学实战课就好了，这些没多少难度。 而设计、流程和运维，这些是实战课不常见的，也是架构师最需要了解的内容 —— 否则，大家都会开发，凭什么你是架构师呢？ 总结 实战课能带你从 0 到 1 入门，接下来 1 - 2 就需要架构师课来帮助你突破瓶颈。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫双越老师/03-动真格的了！为做一门课程花费 1.5万 购买云服务.html":{"url":"pages/👨‍🏫双越老师/03-动真格的了！为做一门课程花费 1.5万 购买云服务.html","title":"动真格的了！为做一门课程花费 1.5万 购买云服务","keywords":"","body":"动真格的了！为做一门课程花费 1.5万 购买云服务.md 最贵的 iPhone12 Pro Max 要 11899 元，我没有买。今年新出的 iPad mini 据说玩游戏体验很好，要 2921 元，我也没有买。 我把这些钱都花在了正在制作的课程上，1.5w 购买了各种云服务：两台云服务器、各种数据库、OSS、CDN、域名、https 证书、Web 防火墙、短信服务、内容审核服务…… 哦，还花钱请了以为 UI 设计师来设计页面。 你可能会疑问：就讲一门课而已吗，还需要花钱？现在网上各种“Vue 做电商”，就写代码就好了，一分钱都不用花。 对此，我也有一个疑问：现在有哪一门课程，讲师会亲自花钱来投资？（平台的广告、运营费用不能算哈～） 你可以说我：不按套路出牌，可能会踩坑～ 但我还是要坚持自己的风格和态度：输出优质内容，独立思考，做不一样的事情，做真正有价值的课程！ PS：课程链接这里不写了，有意向的可以私聊我。本文我们只谈钱～ 为何要花钱呢？ 书归正传。不开玩笑、不卖关子了，正式解释一下这个问题。 其实答案很简单 —— 我要做一个真实的线上项目，而不是 demo 。这是项目地址 https://www.imooc-lego.com/ ，有兴趣的可以体验，这里不过多介绍。【但是】要解释一下，虽然看着就是一个网站，但它背后有 12 个代码仓库，所以复杂度还是很高的。 我要把一个真实项目的从 0 到 1 的过程，搬到课程里。包括需求、架构设计、技术方案、研发流程、CI/CD ，发布上线/回滚，运维，监控和报警。 我在这最近忙碌的半年多里，我都傻傻分不清自己到底是一名讲师，还是一名外包。 讲课为何非得用真实项目，不都是 demo 吗？ 这个问题要分开说。 入门适合用 demo 零基础入门的课程，为了让学员能更快的学习到语言、环境、框架和工具的使用，就在本地运行，用 demo 非常合适。 此时如果强行用线上环境，第一会扰乱学员的学习重点，第二是难度太大学员不易接受。 近几年是国内在线编程教育的高速发展阶段，但也是刚刚起步不久（回想 5 年之前，哪儿有那么多付费课程）。 正好近几年又是程序员行业发展壮大的关键时间，新人纷纷涌入。 所以，这段时间出现了大量的入门课程，各个平台，各个讲师，各个框架，各种“vue + 电商”的课程铺天盖地。以至于学员写简历，都写这些项目，面试官们应该有点印象。 在此，也就解答了本文一开始的问题“就讲一门课而已吗，还需要花钱？” —— 这是和我们大环境相关的。 进阶不再适合 demo 为啥进阶还要学习课程？而且花钱更多？—— 你上班的时候看看你身边的人，就知道了。 一块和你挤地铁的有多少人？一块和你堵车的有多少人？你上午占个厕所的坑位有多不容易？—— 就是因为人多，竞争激烈，不进则退呀！ 我家人经常劝告我：别那么累了，慢着点干，你现在这么忙每月挣 xxx 钱，你歇着干每月挣个 70% 不也挺好的吗？ 我说：这和你想的不一样，我现在这么干，每月挣 xxx ，我要稍微一懈怠，别说 70% 60% ，我一分钱都挣不到。因为大家都是一个集体，不再是自己种那一亩三分地了，你歇着干就会影响其他人，你就会被淘汰。大家想一下是不是这个道理？ 好了，把话题拉回来。 所以，进阶的课程，我觉得不应该再用 demo ，要把标准提高，要能输出更有竞争力的内容。demo 和线上项目，哪个更有竞争力，这一点大家都知道。 真实项目有啥特别的，看功能和我做的 demo 一样啊？ 举个例子。demo 就是实验室里的概念车，线上项目就是大街上跑的量产车。看着功能都一样，但本质有很大区别的。 加入要把这个概念车卖给你，你敢买吗？万一坏了零部件怎么办，有地方换吗？4S 店是否也有 10w 公里的质保？它作出碰撞测试吗，安全吗？它内饰做过甲醛等气体测试吗？它排量标准符合国家规定吗？它有出厂检测和 3C 证书吗？…… 同理，对于我们软件项目，demo 和线上项目也是有本质区别的。 demo 没有线上环境，如域名，服务器，数据库等 demo 没有上线、回滚的流程 demo 没有运维监控和报警，这些在实际工作中都是重点 demo 没有统计、分享等正式的业务场景 demo 不用考虑安全、攻击、敏感内容过滤等 demo 不用担心万一半夜出 bug 该怎么办？ …… 还有很多，一次性说不完，都在课程里 上述这些，对于一个网站或者任何一个软件产品，是不是都非常重要？相信大家都懂得。但是这些都要借助线上项目，来讲出来，否则就是空口白说。 为啥很少见其他课程也用线上项目？ 成本高啊，而且收益如何都还不知道呢～ 首先得像我，花钱买各种服务。而且现在服务器都不便宜，看看阿里云服务器，一年动辄 3k+ 。有人说可以买华为云、腾讯云 —— 是便宜，但做课程吗，还是要考虑找个大众的，这样容易理解。 再者，多了上线、回滚、运维、监控和报警、网络安全预防，这么多内容，自己的时间成本会增加很多。 但是，我还是做了这样的尝试，不试试怎么知道不行呢。 这些钱给报销吗？ &#x1F62D;很明显，不给报销。 发票都还没开呢，哪位需要的话，可以私信我。 现在各个平台，都没有给讲师报销服务器花费的机制。因为现在我没发现哪门课是在做一个正式的线上项目。PS：也或许有，只是我没发现。 即便是所谓的线上项目，最常见的形式，也就是平台给免费提供一个测试机，然后给一个二级甚至三级域名，能给学员演示一下。 毫不客气的说，全都是 demo 。 未来编程教育方向，之我见 第三次科技革命还在进行中，所有涉及的行业，都会越来越多元化、精细化。编程教育也是一样，各个技术栈，入门教程、进阶教程都会越来越精细。 而且，随着行业的发展，初期红利期结束，淘汰掉很多凑热闹的。课程会越来越贴合实际应用，越来越以产出实际价值为主，无论是入门的还是进阶的，学的就是工作中要用的到，有价值的东西。 基于以上两点，我还是坚信自己走的方向是正确的。 如果反馈不如预期的好，那可能是时机未到。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫张轩老师/":{"url":"pages/👨‍🏫张轩老师/","title":"👨‍🏫张轩老师","keywords":"","body":"张轩老师 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫张轩老师/01-在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？.html":{"url":"pages/👨‍🏫张轩老师/01-在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？.html","title":"在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？","keywords":"","body":"在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？ 因为很多同学学习技术陷于一个瓶颈，尤其是很多在中小型公司的同学，发现工作中每天都深陷重复业务的泥潭，不由的产生一种恐慌的心情，觉得自己在浪费时间没有提高。很多同学都向我要求的复杂前端项目和高级课程。 什么是复杂项目 那么什么是复杂项目呢？一个陈年老项目有10w+代码 ？ 一个增删改查项目有 50 个分开的页面算复杂吗？虽然它的代码量够大，但是它更不称不上复杂。反而会让人很有挫败感和无力感。 我认为想真正尝试复杂的项目的必须要是一个现代的前端开发项目，涉猎多个不同领域： 交互的复杂性 - 可能包含元素的复杂交互 移动，拖动大小，拖动排序 等。 数据状态的复杂性 - 嵌套数据和多种类型的组件相对应，同时两者要互相同步。 多项目之间的依赖性 - 有可能要抽取出一系列的公共库供多个项目使用。 测试 - 保证代码质量，减少 Bug 的必备技能。 打包 - 对应不同类型的功能的项目（web 应用或者是 library），怎样生成多种类型对应的可复用的代码格式。 性能优化 - 大型项目性能是要点，让加载速度提升就等于省的是真金白银。 第三方库使用和二次开发 - 怎样快速找到和使用已经有的技术方案解决特定问题。 持续集成 - 让代码能够自动化的测试，部署，是去大厂的敲门砖。也是大型项目必备的内容。 ... 只有满足了这样需求的项目才能把前端开发的方方面面都包含在其中，才能掌握其中的复杂项目的奥义。 写出高质量符合大厂要求的代码 除了项目，代码质量也是一块需要考量的因素。 很多人都知道大厂镀金是个对于每个人的职业都是重要的一环，但是很多在中小心公司的同学都不熟悉大厂开发的流程和要求，有的人甚至经常是公司的“全干工程师”，从前端到后端都是一个人说了算。大厂由于工程师众多，必须采取一套标准化自动高效的流程来管理代码和部署以及测试。 简单可以描述为： 从 git flow 分支的创建，管理已经合并 到 lint 工具保证代码的格式正确 到 单元测试 尽可能保证代码的质量 到 代码提交 尽可能详尽可追溯的提交信息， 到 PR review，再次保证代码的质量 到最后 CI/CD ，保证持续迭代和部署等等。 这些概念如果你觉得陌生，一两句话很难说的清楚，那么就需要通过一个大型多人协作的项目去真是的实践这些过程。软件开发肯定会伴随着 Bug 的出现，关键是怎样使用科学和优良的实践来尽可能的发现和规避风险。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "},"pages/👨‍🏫张轩老师/02-Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程.html":{"url":"pages/👨‍🏫张轩老师/02-Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程.html","title":"Typescript 是不是前端开发必备的技能？一个 Ts 黑到 Ts 粉的心路历程","keywords":"","body":"Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程 2020年 Typescript 各种火，就像我之前说的在 jsconf 2019上，typescript 也变成了一个主要议题，占到了很大比重，来自微软的讲师韩骏还拿出了这么一张图，来表达自己的观点， 我觉得这个不是夸大其词，而实实在在的是一个趋势，来自 2018 年 stateofjs 权威调查显示，80% 的程序员都希望在新的项目中学习和使用 typescript。大家可以明显看到从 2016 年到 2018年 这个趋势的绝大变化，这就说明 typescript 越来越流行了。 在我的编程生涯到现在，我一直在使用动态类型语言（Dynamically Typed Language），聊起这个概念，那就要说说 动态类型语言 和他的对立面 - 静态类型语言（Statically Typed Language）。我刚写 typescript 的时候，对类型声明嗤之以鼻，添加一大堆类型浪费我宝贵的时间，还时不时遇到根本看不懂的类型错误，感觉很抓狂，我当时想对 ts 编译器说：“老子能管好自己写的类型，不用你报错”，实在搞不定的类型错误发生的时候，我就会使用 any 大法，完全是一副应付差事的用法。 我当时维护的项目是一个十几万行的大型项目，当时还在推另外一个小型项目，我极力反对 typescript，据理力争，“你是想让我赶快完成任务？还是浪费时间在写 any 上面？这玩意儿根本就不能给你避免 Bug，都是扯犊子。” 后来我花更多的时间在老项目上面，我每天写 any 发 PR 被老外一阵喷。这时候可不能给自己丢脸啊，我开始认真对待起 type 来。 我发现当我在代码中打入了越来越多类型的时候，效率居然变得很高（自动补全），遇到各种傻瓜错误（比如说 typo，我的单词记不住，经常打错 ）的几率也越来越少，在后来两年的工作生涯中，我在很多比较大型的项目中都使用了它，并且越来越感受到它的优势。虽然精通 ts 真的有一定的难度，但是其实你也不必那么精通，能差不多看懂，帮你提高效率就好了，我总结几点编码过程中，实实在在帮助到我的点。 1 程序更容易理解 当我们进行编码的时时候，我们非常关心这几个问题，一个函数或者方法接受什么样什么类型的参数，它的返回值和类型是什么？有什么其他外部数据需要被引进？为了解决这几个问题，我们一般都要详细的查阅文档，搞清楚所有的来龙去脉，因为动态语言的约束我们很难完成这几项任务，我们需要在代码真正运行的时候来调试才能知道答案，比如说加断点或者 console.log 去查看输出，甚至还需要社交过程，我有好几次都是直接跑去问同事或者blame原来写这段代码的人，发个邮件问这些代码究竟是干嘛的，扯皮扯个好几天。有了 typescript，这几个问题都迎刃而解，代码就是全部的注释，通过代码你不再需要去进行猜测，而是直接就可以知道这些问题的答案。看下面上古神器 jQuery 的提示，这参数，返回值的说明，还有文档地址和代码示例，这水平比你百度出来不知几百年前的csdn博客文章不知道高到哪里去了。 2 效率更高 有了 IDE 和 compiler 的帮助，你可以非常方便的在不同的代码块和定义之间进行跳转，同时进行代码补全，还有丰富的接口提示，可以是事半功倍。我就享受这个感觉，能让 IDE 炫酷的提示是每个程序员的梦想。可以疯狂的体验下“老夫就是 jQuery 一把梭”的快感。 3 更少的错误 在编译期间能够发现大部分的错误，这远远要比运行时候再出现这些错误要好的多。在 typescript 之前，我不知道有多少次出现变量名称打错这种错误，传入错误类型的参数，还有就是还有就是排在前端错误第一名：最经典的“Cannot read property 'xxx' on undefined：无法在 undefined 上读取 xxx 属性，通常出现在 a.b.c 的情况。” 4 非常好的包容性 typescript 是 javascript 超集，即使我们把 js 文件直接命名为 ts 文件，也不会有任何的问题，兼容第三方库，即使这些库没有用 ts 编写，也可以给他们编写单独的类型文件进行读取。大部分非常流行的库都用 typescript 实现或者提供写好的类型文件供开发者使用，比如 React，vue，angular，和 ant design 等等，使用起来可谓是无缝衔接。 5 提高自身水平 ts 内部有非常多的内置对象，这些对象我们平时在使用的时候都没有过多的在意，比如 NodeList 和 HTMLCollection 的异同，Event 对象，衍生出来的 MouseEvent，TouchEvent 都有啥区别和属性 等等。。。 把这些接口都一一搞清楚以后，对BOM 和 DOM 的机制了解可以达到另外一个境界，潜移默化的就变成了 API 使用高手。当别人看到没用过的属性的时候，你可以骄傲的化身 API 达人。 结论： 假如你工作在一个大中型项目上面，typescript 对你应该是利大于弊。可以学！还能从另外一个方便了解静态类型语言是怎么玩的，看到别人的 Java 代码居然能有看得懂的部分了。 当然要学会根据自己的需求和项目的规模合理选用工具，如果你的应用就是一个简单的展示页面，加几个 UI 状态改变，就没有必要使用。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-01-18 01:35:17 "}}