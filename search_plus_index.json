{"./":{"url":"./","title":"Introduction","keywords":"","body":"Web 前端架构师课 - 学习笔记 浅层学习看输入，深入学习看输出！ 慕课网《Web 前端架构师》课程学习笔记汇总，课程要求每位同学每周都要及时产出学习笔记。 精选学习笔记 【郭二蛋】第一周笔记和作业 【点点】需求分析和架构设计 【彩笔】架构方案设计文档 【yhtx1997】第一周作业 【郭二蛋】第二周笔记和作业 【六玥】第二周笔记和作业 【彩笔】脚手架架构设计和框架搭建 【Berners】第二周笔记和作业 【い狂奔的蜗牛】01.Node.js中经典算法（一） 【yhtx1997】02-第二周作业 【郭二蛋】03-第三周学习笔记 【い狂奔的蜗牛】02.Node.js中使用ES Module的两种方式 【彩笔】作业-03-脚手架核心流程开发 【Berners】03-第三周笔记和作业 【clqyfe】07-Week03-脚手架核心流程开发 【彩笔】作业-04-脚手架命令注册和执行过程开发 【い狂奔的蜗牛】03.sim-cli核心图集 【い狂奔的蜗牛】04.Node.js多进程源码分析 【郭二蛋】04-第四周笔记 【い狂奔的蜗牛】07.第五周-readline源码阅读及实现简易版readline 【い狂奔的蜗牛】08.第五周-类似inquirer列表类型交互实现 【Sunshine】第五周笔记和作业 【彩笔】作业-05-脚手架创建项目流程设计和开发 【い狂奔的蜗牛】09.第六周-ejs源码分析 【jolly_chen】第六周 ejs使用和源码解析 【jolly_chen】第六周 node require 加载模块.md 【い狂奔的蜗牛】10.第六周-require源码分析 【彩笔】作业-06-脚手架项目和组件初始化开发 提交你的学习笔记 注意，以下操作需要你了解 github 的 fork 和 pull request 机制。这也是多人协作开发所必备的技能。 fork 源码 进入 https://github.com/imooc-lego/students-learn-task ，fork 项目到自己的 github 空间。 然后下载项目到本地，安装并启动。 cd students-learn-task npm i npm run dev # 访问 localhost:4000 写学习笔记 即写博客文章。注意，全程使用 markdown 语法，不懂的自己去查。 新建 docs/pages// 目录 ， 即你在慕课网的用户名（或昵称、网名，都可以） 新建 docs/pages//README.md ，内容参考现有的 docs/pages/双越老师/README.md 在 docs/pages// 下新建博客文件，命名格式按照 01-xxx.md 02-yyy.md 03-zzz.md ... 一定以序号 01- 02- 开头！！ 如果需要图片，可把图片文件放在 docs/pages//images/ 中，然后在博客中引入 删掉 docs/SUMMARY.md 你在本地执行 npm run dev 或 npm run build 都会自动生成 docs/SUMMARY.md 。 检查一下，如果你的代码中有 docs/SUMMARY.md 这个文件，请删除掉它。\\ 否则，可能会和别人产生冲突，请一定注意检查！！！ 最后，提交代码到 github 。 提交 pull request 从你 fork 的仓库，提交 pull request 到 https://github.com/imooc-lego/students-learn-task ，请求合并到 main 分支 确定 https://github.com/imooc-lego/students-learn-task 有你提交的 pull request 等待讲师处理（一般会在 24h 之内处理：合并或者回复），注意看 github 的通知 自动发布 pull request 被合并之后，会触发 github actions ，自动打包、发布到 http://homework.imooc-lego.com/ 。 过程大概 3-5 分钟。 重点提醒 第一次，记得新建 docs/pages//README.md 文件 图片文件都放在 docs/pages//images/ 目录中 提交时记得删掉 docs/SUMMARY.md 文件，否则容易产生冲突 Pull request 提交成功之后，自己再检查一下：看是否有冲突？看 Files changed 是否符合预期？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Abaddon/":{"url":"pages/Abaddon/","title":"Abaddon","keywords":"","body":"Abaddon - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Abaddon/01-week01 需求分析与架构设计.html":{"url":"pages/Abaddon/01-week01 需求分析与架构设计.html","title":"Week01 需求分析与架构设计","keywords":"","body":"架构师与业务需求 架构师必须深入理解需求，以架构师的角度分析需求，须有全局思维、整体思维、闭环思维。 在此基础上确定需求范围，设计核心数据结构。 ![](http://imooc-lego-homework.oss-cn-hangzhou.aliyuncs.com/docs/pages/Abaddon/images/1.png) 产出 编写《整体技术方案设计》 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Baran/":{"url":"pages/Baran/","title":"Baran","keywords":"","body":"Baran - 作业 浅层学习看输入，深层学习看输出&#x1F4AA;&#x1F4AA;&#x1F4AA; 第一周 01-需求分析和架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Baran/01-需求分析和架构设计.html":{"url":"pages/Baran/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析和架构设计 第3章 需求分析 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Ben/":{"url":"pages/Ben/","title":"Ben","keywords":"","body":"Ben - 学习笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Ben/01-技术方案设计文档.html":{"url":"pages/Ben/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":"《整体技术方案设计 V1.0》 需求 完成幕客乐高产品需求 范围 整体设计、架构设计 模块设计 作品管理-b端、管理后台-admin端、作品H5页面-c端 模块的关系图以及主要功能描述 作品的数据结构 使用vnode规范定义数据结构 { work: { title: '作品', settings: {}, // 页面配置项 props: {}, // 页面属性 // 组件图层的顺序按数组下标排序 components: [ { id: 1, name: '文本1', tag: 'text', attrs: {}, // 组件属性 children: ['文本内容'] }, { id: 2, name: '图片2', tag: 'image', attrs: {}, // 组件属性 children: null } ] }, activeComponentId: 1 // 当前选中的组件 } 数据流转图 扩展性保证 通过组件库进行组件的扩展 通过数据结构保留字段，对页面的配置和页面的属性进行扩展 开发提效 通过脚手架自动创建和发布 通过组件库设计可复用组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，随时可以扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Berners/":{"url":"pages/Berners/","title":"Berners","keywords":"","body":"高俊峰 - 学习分享 第一周笔记 第二周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Berners/01-第一周笔记和作业.html":{"url":"pages/Berners/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"需求设计 脱离业务的架构就是耍流氓，架构师必须要深入理解需求，参与需求，看透需求背后的业务本质。 主要产出 熟悉产品需求 学会以架构师的思维分析需求 全局思维，整体思维，闭环思维 主要内容 如何以架构师思维分析需求 项目的浅层需求 项目的深度需求 需求总揽 业务模块设计 ![](http://imooc-lego-homework.oss-cn-hangzhou.aliyuncs.com/docs/pages/Berners/images/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1.png) 扩展性保证 数据结构层面 一些可能的整体项目级别配置项。主要是是否可编辑，是否锁定等等。 一些页面级别的配置参数，大小，背景色之类的。 编辑器层面 保证组件的可扩展性，组件的锁定，可选，图层等等后续必要的扩展功能。 开发提效 脚手架固化一些重复操作，规范流程，提高开发效率。 创建项目的流程 提交代码的流程 测试项目的流程 打包项目的流程 发布项目的流程 组件平台主要固化组件的开发和发布流程，提升组件开发效率。 运维保障（待补充），大中型企业自研 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 架构师职责：项目设计，模块，逻辑抽象，正在是解决业务问题，梳理业务。通过技术手段实现业务增长，用架构设计模拟业务。 架构师核心思想 通过技术手段，来保证业务的增长。对业务负责，需 要对需求精准深入的理解。 要坚信：技术永远都是为业务服务的，技术是实现业务增长的工具。 学习方法 要有耐心，不要一心想着写代码，觉得需求和设计不重要 抛开你固有的程序员思维，开始准备接受架构师思维 要坚信：技术永远都是为业务服务的，技术是实现业务增长的工具 注意事项 不要关注细节，要看整体，看范围 设计时判断可行性，不确定的就调研一下，（这需要大量的工作经验积累，技术能力） 设计要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Berners/02-第二周笔记和作业.html":{"url":"pages/Berners/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"脚手架架构设计和框架搭建 参考： https://www.imooc.com/wiki/weban/w2c2.html 标题 脚手架框架设计和框架搭建 收获 脚手架实现原理 lerna的常见用法 架构设计机器和架构图绘制方法 主要内容 学习如何以架构师的角度思考基础架构问题 多package项目管理痛点和解决方案，居于lerna脚手架框架搭建 imooc-cli脚手架需求分析和架构设计，架构设计图 附赠内容 脚手架调试技巧 lerna源码分析 node的module模块分析 yargs使用方法 剖析lerna架构设计 关键词 脚手架-掌握脚手架原理和开发流程 lerna-解决多package项目管理痛点 架构设计-学习大厂基础架构设计思路 学习方法 架构三部曲：掌握原理 -> 独立思考 -> 总结反思 深度剖析优秀开源项目，由表及里，由深入浅 视角切换，多切换到架构师视角，从全局思考问题 站在前端研发的视角，分析开发脚手架的必要性 研发效能：提升前端研发效能 脚手架核心价值 将研发过程： 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化，数据化，使的研发过程可量化 脚手架的实现原理(window系统) 1.为什么全局安装 @vue/cli 后台添加的命令为 vue？ npm install -g @vue/cli 查看安装目录 1.1 操作系统注册 vue 命令 在 C:\\Program Files\\nodejs 目录下的 vue 文件中注册 vue 命令到环境变量 直接执行 C:/Users/IG_G005/AppData/Roaming/nvm/v11.15.0/vue 文件命令和 vue 命令是等价的 执行vue命令会在环境变量中找到 vue 命令是否被注册 vue 命令通过 软链接 在指向 C:\\Users\\IG_G005\\AppData\\Roaming\\nvm\\v11.15.0\\node_modules\\@vue\\cli\\bin\\vue.js 这个文件 1.2 为什么 C:\\Users\\IG_G005\\AppData\\Roaming\\nvm\\v11.15.0\\node_modules\\@vue\\cli\\bin\\vue.js 文件可以被node解析器执行 #!/usr/bin/env node 主要是这个句话，声明使用node环境执行该脚本文件 2.全局安装 @vue/cli 时发生了什么 在node安装目录的主目录， bin目录下创建一个软链接，软链接指向的是bin目录指向的实际文件 脚手架的实现原理(mac系统) 1.为什么全局安装 @vue/cli 后会添加的命令为 vue ？ which vue gaojunfengdembp:students-learn-task gaojunfeng$ which vue /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue 该文件是一个可执行文件，是一个软链接（node环境下的全局命令） gaojunfengdembp:bin gaojunfeng$ ls node npm npx nrm vue 目录下 vue文件是个软链接，指向 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js 文件 在执行 vue 命令时，其实就是在执行 指向的文件 那 vue 命令，即软链接的名称，是在 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/package.json 文件中，配置的 vue 命令，执行命令时 指向 bin/vue.js 文件 { ... \"bin\": { \"vue\": \"bin/vue.js\" // 在这里通过key配置，决定名称，绑定 bin 目录下的 vue.js 文件 }, ... } 2.全局安装 @vue/cli 时发生了什么？ 当我们在全局安装了 @vue/cli 模块，会下载到 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules 目录中， 当包下载完成后，会自动解析 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/package.json 文件， 读取文件中 \"bin\" 这个配置，发现 bin 下面有 vue 字符的这样一个配置，会在 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin 目录下创建一个软链接 vue，软链接又指向 bin 对应的文件，即（/Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js）文件 vue(软链接) -> /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js(原始文件) /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue(目录软链接) -> /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js(原始文件) 3.执行 vue 命令时发生了什么？ 首先执行 which vue which vue /Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/vue 返回一个软链接 执行该软链接 和 执行 vue 命令时等价的，该软链接上面讲了，又指向的是vue.js文件，看上面的说明 为什么 vue 指向一个 js 文件，我们却可以通过 vue 命令去执行它？ 查看 /Users/gaojunfeng/.nvm/versions/node/v14.15.3/lib/node_modules/@vue/cli/bin/vue.js 文件代码 1.主要是 #!/usr/bin/env node 这句话，添加了执行该文件的环境变量。 表示当执行当前文件时，会到操作系统环境变量找 node 这个命令，找到以后通过 node 命令执行对应的文件。 直接执行 /usr/bin/env node 命令和直接执行 node 命令是一样的。 2.怎么创建软链接(node环境下的全局命令) 创建 imooc 命令 在/Users/gaojunfeng/.nvm/versions/node/v14.15.3/bin/目录下，通过 ln -s /xxx/xxx.js imooc 创建一个软链接，指向js文件 区别 #!/usr/bin/env node #!/usr/bin/node 第一种是在环境变量种找 node 第二种是直接执行 /usr/bin/ 目录下的 node 脚手架原理进阶 1.为什么数脚手架的本质是操作系统的客户端？它和我们PC上安装的应用/软件有什么区别？ 脚手架是操作系统上的一个客户端，脚手架执行依赖node，node又是操作系统上的客户端。和其他应用本质上没有区别 2.如何为 node 脚手架创建别名 通过创建软连接，连接到我们自己编写的代码文件上。 创建软链接语法： ln -s 指向的文件路径 软连接名称 例子：ln -s /xxx/xxx.js imooc 3.描述脚手架命令的全过程 脚手架开发流程 脚手架开发流程详解 开发流程 1.创建 npm 项目 2.创建脚手架入口文件，最上方添加 #!/usr/bin/env node 3.配置 package.json，添加 bin 属性 4.编写脚手架代码 5.讲脚手架发布到npm仓库 使用流程 1.安装脚手架 npm install -g your-own-cli 2.使用脚手架 your-own-cli 脚手架开发难点解析 1.分包：将复杂的系统拆分成若干个模块 2.命令注册 vue create vue add vue invoke 3.参数解析 vue command [options] command主命令: 如 create, add, invoke options参数全称: --version, --help options参数简称: -V, -h 带 params 的 options: --path /Users/sam/Desktop/vue-test 帮助文档： global help Usage Options Commands 如 vue 的帮助文档 command help Usage Options vue create 的帮助信息： 还有其他 1.命令行交互 2.日志打印 ... lerna 开发脚手架流程（划重点） 一：脚手架项目初始化 1.初始化npm项目 -> 安装lerna -> lerna init 初始化项目 二：创建 package 1.lerna create创建Package -> lerna add 安装依赖 -> lerna link 链接依赖 三：脚手架开发和测试 lerna exec执行shell脚本 lerna run 执行 npm 命令 lerna clean 清空依赖 lerna boosttrap 重装依赖 四：脚手架发布上线 lerna version bump version lerna changed查看上版本依赖的所有变更 lerna diff 查看diff lerna publish项目发布 lerna 源码阅读 准备工作 1.下载源码 2.安装依赖 2.IDE打开 源码阅读准备完成的标准（划重点） 1.找到入口文件 2.能够本地调试 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Berners/03-第三周笔记和作业.html":{"url":"pages/Berners/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"核心图 直接上代码吧 https://github.com/duanshanghanqing/imooc-test-berners https://github.com/duanshanghanqing/berners-cli Node项目如何支持ES Module 方案一: webpack + bable-loader 安装模块 npm i -D babel-loader @babel/core @babel/preset-env npm i -D @babel/plugin-transform-runtime npm i -D @babel/runtime-corejs3 创建webpack.config.js const path = require('path'); module.exports = { entry: './bin/core.js', output: { path: path.join(__dirname, '/dist'), filename: 'core.js' }, mode: 'development', target: 'node', // 默认是 web 环境 // 以上四步完成后就可以支持es module // 还想要支持低版本的node, 就需要配置babel-loader转义 module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, regenerator: true, useESModules: true, helpers: true } ] ] } } } ] } } 方案二: Node原生支持ES Module 这种方案的实现,所有文件必须以.mjs结尾。文件内必须以ES Module的方式导出或引用 1.创建index.mjs文件 2.node版本小于14 node --experimental-modules index.mjs 3.node版本大于14 node index.mjs 本周作业完成情况 绘制脚手架架构设计图（已完成） 实现脚手架准备过程代码（已完成） 通过 commander 实现一个脚手架，包含自定义 option 和 command 功能：imooc-test-berners（已完成） 通过 webpack 和原生两种方式实现 Node 对 ES Module 的支持（已完成） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Beyond/":{"url":"pages/Beyond/","title":"Beyond","keywords":"","body":"目标只有一个：大厂 大厂 大厂！！！ Week01 Week01-作业-整体架构设计 V1.0 Week02 Week03 Week04 Week05 Week06 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Beyond/01-week01-作业.html":{"url":"pages/Beyond/01-week01-作业.html","title":"Week01 作业","keywords":"","body":"技术方案设计文档 需求背景 慕课乐高 - UI设计和需求 范围 从需求来看，范围包括这几个方面 B端和编辑器 biz-editor-FE biz-editor-server C端 H5（从性能的角度考虑做SSR） 管理后台，做前端分析 admin-FE admin-server 独立的组件库 npm包的形式，供编辑器端和H5端使用； 统计服务 模块设计 核心数据结构设计 基本思路： 每个组件尽量符合vnode规范 用数组来组织数据（有序） 尽量使用引用关系，不用冗余 { 'project one': { title: '', setting: {/*可能需要的配置项*/}, props: {/*页面body的一些设置*/}, components: [ { id: 'xxx1', name: 'xxx1', tag: 'image', attrs: { fontSize: '14px' }, children: [] }, { id: 'xxx2', name: 'xxx2', tag: 'text', attrs: { fontSize: '14px' }, children: null }, ] } //当前选中的组件id activeComponentId: 'xxx' } 扩展性保证 扩展组件 扩展编辑功能，如锁定，隐藏等 扩展页面信息，如增加多语言或者主题色 扩展其他功能，如大数据分析等 研发提效 脚手架：创建/发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/D7-Dorr/":{"url":"pages/D7-Dorr/","title":"D7 Dorr","keywords":"","body":"D7-Dorr - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/D7-Dorr/01-week01-技术方案设计文档 .html":{"url":"pages/D7-Dorr/01-week01-技术方案设计文档 .html","title":"Week01 技术方案设计文档 ","keywords":"","body":" 需求背景 需求文档 范围 运营人员 普通用户 后台管理员 模块设计 模块拆分和关系图 核心数据结构设计 数据结构 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图 扩展性保证 扩展组件 扩展功能 数据结构扩展 引导讨论扩展性 研发提效 复用性 易用性 例：脚手架、组件平台 运维保障 线上服务和运维服务（采购第三方服务） 安全 监控和报警（自研） 服务扩展性 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Daiyan/":{"url":"pages/Daiyan/","title":"Daiyan","keywords":"","body":"Daiyan 的课程笔记与作业 第一周 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Daiyan/01-week01-整体架构设计.html":{"url":"pages/Daiyan/01-week01-整体架构设计.html","title":"Week01 整体架构设计","keywords":"","body":"整体架构设计V1.0 需求 需求链接 范围 整体设计、模块设计、核心数据结构 模块设计 组件库将独立出来同时服务于 作品管理 和 作品H5页面 统计服务需要进行自研，因为市面上的不是太贵就是不合适 作品的数据结构设计 使用 vNode 描述作品 预留部分字段以保证拓展性 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 尽量避免污染/冗余源数据，使用 getter 返回计算属性 { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证（待补充） 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面配置，如增加多语言、设置背景 扩展其他功能，如大数据分析和计算等 开发提效（待补充） 脚手架：创建发布 组件平台 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大时，基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Daiyan/02-week02-脚手架基础.html":{"url":"pages/Daiyan/02-week02-脚手架基础.html","title":"Week02 脚手架基础","keywords":"","body":"脚手架基础 脚手架创建 创建文件夹 mkdir dai-cli && cd dai-cli 初始化项目 npm init -y 创建并写入文件，注意需要配置下node路径 mkdir bin && echo -e \"#\"\\!\"/usr/bin/env node\\n\\nconsole.log('hello world')\" > bin/index.js 修改 package.json { \"name\": \"dai-cli\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", // 添加bin配置 \"bin\": { \"dai-cli\": \"bin/index.js\" }, \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" } 进行软链接 npm link && dai-cli #hello world 多库 如脚手架创建一样 在dai-cli 的同级目录下创建一个库dai-cli-lib，但我们把 bin 改名为 lib 同时将 index.js 暴露出一个函数 #!/usr/bin/env node module.exports = { sum(a, b) { return a + b } } 回到 dai-cli 目录下，执行 npm link dai-cli-lib 修改 dai-cli/bin/index.js #!/usr/bin/env node const { sum } = require('dai-cli-lib') console.log('hello world') console.log(sum(1,3)) 执行 dai-cli dai-cli #hello world 4 Lerna基础 文档地址： https://github.com/lerna/lerna#readme lerna的优点： 批量执行操作 管理依赖 减少重复操作 注意事项 在 npm 创建 group 避免包名重复 如果使用 group 时，publish 需在package.json设置 // package.json \"publishConfig\": { \"access\": \"public\" } 需要 git push 之后再 publish 脚手架实现原理 脚手架执行原理 终端输入 vue create dai-cli 终端在环境变变量中找到vue指令 因为文件头部编写了#!/usr/bin/env node表示用node运行此文件 vue解析并执行命令 使用Lerna搭建自己的脚手架并发布到npm 在 2021/01/15 搭建了我的第一个脚手架 npm install -g @daiyan-cli/daiyan && daiyan # hello daiyan-cli # 13 Yargs开发流程 脚手架初始化 Yargs () 脚手架命令注册Yargs.command 脚手架参数解析Yargs.parse Yargs常用API Yargs.options Yargs.option 配置选项 Yargs.group 指令分组 Yargs.demandCommand 指定至少有 n 个 Command Yargs.recommendCommands 指令输入错误时 给出提示 例如输入 craete 提示 create Yargs.strict 输入未识别的指令是否提示 Yargs.fail 发生错误时提示 Yargs.alias 设置指令别名 Yargs.wrap 设置显示区域宽度 Yargs.epilogue 设置底部提示 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Daiyan/03-week03-脚手架核心流程开发.html":{"url":"pages/Daiyan/03-week03-脚手架核心流程开发.html","title":"Week03 脚手架核心流程开发","keywords":"","body":"脚手架核心流程开发 脚手架架构图 流程简介 使用 import-local 优先运行本地脚手架 对比本地 node 版本号 使用 process.version 读取本地node版本 检查是否为 root 账号，如果是则需要对齐进行权限降级 直接用 root-check 这个包就行了 检查用户主目录是否存在 获取用户主目录使用 user-home 使用 pathExists 判断目录是否存在 检查 input 参数（这里在后面会被替代） 可以通过 minimist 检查参数、这里检查了 debug 模式是否为 true 如果为 debug 模式，将 log 的模式设置为 verbose 检查环境变量 读取本地 path.resolve(userHome, 'env') 下时候存在环境变量文件 使用 dotenv 设置环境变量 如果环境变量不存在 则创建一个默认的环境变量 检查版本号是否为最新 通过 urlJoin(registryUrl, npmName) 可以找到 npm 最新的包信息。url-join 是一个 npm 包 通过 axios 获取最新包信息 通过 semver 这个包来对比版本 其他 通过 colors 可以输出不同颜色的log Commander包的应用 由于后面课程还会提到，暂时可以直接参阅中文文档： 7.x.x 版本 6.x.x 版本 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Devil/":{"url":"pages/Devil/","title":"Devil","keywords":"","body":"Devil - 课程分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Devil/01-week1-需求分析.html":{"url":"pages/Devil/01-week1-需求分析.html","title":"Week1 需求分析","keywords":"","body":"需求分析 如何进行分析 以架构师的思维分析需求，不能只停留在表面实现需求，要考虑怎么实现能给业务带来增长 全局思维、整体思维、闭环思维，不能只考虑自己，要全局考虑整个团队，要做到有输出、有输入、有结果 产品分析 架构设计 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/EddieCookie/":{"url":"pages/EddieCookie/","title":"EddieCookie","keywords":"","body":"2021 也要加油鸭~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/EddieCookie/01-week01.html":{"url":"pages/EddieCookie/01-week01.html","title":"Week01","keywords":"","body":"Week01 笔记 项目概览 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/EditYJ/":{"url":"pages/EditYJ/","title":"EditYJ","keywords":"","body":"EditYJ - 课程打卡作业心得 Week01 Week01-作业-整体架构设计 V1.0 Week02 Week02-笔记-脚手架是什么 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/EditYJ/01-Week01-作业.html":{"url":"pages/EditYJ/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 范围 整体设计，架构设计，没有细节 模块设计 模块关系图 B端是前后端分离开发，受众不是大众所以不采用SSR模式开发，如果H5的编辑器比较复杂，可以拆分成单独项目进行开发。 C端采用的是SSR模式开发，一个原因是性能的考虑，另一个方面受众人数较多。 组件库独立出来作为一个第三方项目，B端的编辑器和C端共用一个组件库进行H5页面的渲染。所见即所得，B端编辑好页面后，C端也可以复用组件库进行渲染，达到视觉统一，降低开发成本。 管理后台采用前后端分离开发，内部人员使用，主要用来进行B端和C端的数据管理，数据统计，可以让运营人员把控产品的全局。 自研统计服务，统计一些自定义事件，供B端和使用后台管理系统的人员知道产品的走向。 自研统计服务主要是因为市面上支持自定义事件的统计服务大而全，而且价格昂贵，我们只需要有选择的开发一些满足自生需求的统计就行。 核心数据结构 单个组件应该使用vnode规范，使用业界统一规范有助于我们少踩一些坑，并能得到扩展性较强的组件结构。vuex store 的大概结构如下： { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图 使用统一的数据库管理数据，B端产生组件的配置数据存入数据库并发布项目，C端读取组件配置数据渲染出H5页面供用户访问，管理后台通过管理数据库的数据达到控制B端和C端的目的。 扩展性保证 数据结构层面 一些可能的整体项目级别配置项。主要是是否可编辑，是否锁定等等。 一些页面级别的配置参数，大小，背景色之类的。 编辑器层面 保证组件的可扩展性，组件的锁定，可选，图层等等后续必要的扩展功能。 开发提效 脚手架固化一些重复操作，规范流程，提高开发效率。 创建项目的流程 提交代码的流程 测试项目的流程 打包项目的流程 发布项目的流程 组件平台主要固化组件的开发和发布流程，提升组件开发效率。 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/EditYJ/02-Week02-笔记-脚手架是什么.html":{"url":"pages/EditYJ/02-Week02-笔记-脚手架是什么.html","title":"Week02 笔记 脚手架是什么","keywords":"","body":"脚手架是什么 核心目标 提升前端研发效能 将研发过程自动化，标准化，数据化。 本质 脚手架的本质是一个操作系统的客户端，通过命令执行。 执行命令通常由主命令、command、option三部分组成，即：主命令 command [command param] [option] [option param] 简单的执行过程 以vue cli为例子，输入vue后的执行的大概过程如下： 输入主命令后，首先会去从环境变量中寻找vue命令的路径 根据找到的vue命令链接到实际的vue.js 利用node执行vue.js 通过vue.js解析用户数据的后续参数 执行用户指令 开发脚手架的简单过程 以vue cli为例： 开发一个包含bin/vue.js目录的npm项目，发布在npm上 安装此项目到node的lib/node_modules下 指定node bin 目录下的vue连接至开发的vue.js 回答三个问题 为什么全局安装@vue/cli后会添加命令为vue? 答：因为安装后会自动在node的bin目录下建立vue软链接文件, 这个软链接文件指向了node/lib/node_modules/@vue对应vue.js，由于node/bin目录是在环境变量下的，所以等于添加了命令vue。 全局安装@vue/cli后发生了什么? 答：执行过程如下： 下载了vue.js命令解析执行文件到node/lib/node_modules下 在node/bin目录下创建vue软链接文件连接到node/lib/node_modules对应vue.js 执行vue命令时发生了什么？为什么vue指向一个js文件我们却可以通过vue命令去执行它? 答：第一个问题参考上面的 简单的执行过程，通过下面的vue软链接文件的内容我们可以知道第二个问题的答案： #!/bin/sh basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\") case `uname` in *CYGWIN*|*MINGW*|*MSYS*) basedir=`cygpath -w \"$basedir\"`;; esac if [ -x \"$basedir/node\" ]; then \"$basedir/node\" \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" ret=$? else node \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" ret=$? fi exit $ret 通过这个文件的内容我们可以清晰的看到，本质上其实就是利用shell命令执行了node vue.js Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/":{"url":"pages/GreedyCat/","title":"GreedyCat","keywords":"","body":"GreedyCat - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/01-week01-需求分析.html":{"url":"pages/GreedyCat/01-week01-需求分析.html","title":"Week01 需求分析","keywords":"","body":"慕课乐高架构方案设计文档 需求 https://www/yuque.com/imooc-lego/zlz87z 范围 从需求上看，我们需要:B端和编译器，H5，管理系统 B端和编译器 做前后端分离： biz-editor-fe biz-editor-server H5适合做SSR，因为要考虑性能 H5-server 管理后台 admin-fe admin-server 模块设计 核心数据结构 数据结构思路 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据关系图 核心:B端，C端，管理后台，公用一个数据库 创建作品:初始化一个JSOn数据 保存作品:修改JSON数据 发布作品:修改一个标记，仅此而已 C端浏览作品:获取JSON数据，SSR渲染页面 屏蔽作品：修改一个标记，C端来判断 扩展性保证 扩展组件 扩展编辑器功能，如锁定，隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 开发提效 脚手架:创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性:基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/02-week02-笔记.html":{"url":"pages/GreedyCat/02-week02-笔记.html","title":"Week02 笔记","keywords":"","body":"脚手架架构设计和框架搭建 站在前端研发的视角，分析开发脚手架的必要性 研发性能 开发脚手架的核心目标是: 提升前端研发效能 脚手架核心价值 将研发过程: 自动化:项目重复代码拷贝/git操作/发布上线操作 标准化:项目创建/git flow/发布流程/回滚流程 数据化:研发过程系统化、数据化、使得研发过程可量化 和自动化构建工具区别 问题:jenkins,travis等自动化构建工具已经比较成熟了，为什么还需要自研脚手架？ 不满足需求:jenkins,travis通常在git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地得功能，如:创建项目自动化，本地git操作自动化等 定制复杂:jenkins,travis定制过程需要开发插件，过程比较复杂，需要使用java语言，对前端同学不够友好 从使用角度理解什么是脚手架？ 脚手架简介 脚手架本质是一个操作系统得客户端，它通过命令行执行，比如: vue create vue-test-app 上面这条命令由3个部分组成: 主命令:vue command:create command的param:vue-test-app 它表示创建一个vue项目，项目得名称为vue-test-app,以上是最简单得脚手架命令，但实际场景往往更加复杂，比如： 当前目录已经有文件了，我们需要覆盖当前目录下得文件，强制进行安装vue项目，此时我们可以输入: vue create vue-test-app --force 这里得--force叫做option，用来辅助脚手架确认在特定场景下用户得选择，可以理解为配置 脚手架的执行原理 脚手架的执行原理如下: 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command / options vue.js 执行 command 执行完毕，退出执行 从应用得角度看如何开发一个脚手架 这里以 vue-cli 为例 开发npm项目，该项目中应包含一个bin/vue.js文件，并将这个项目发布到npm 将 npm 项目安装到node的lib/node_modules 在 node 的 bin 目录下配置 vue 软链接指向 lib/node_modules/@vue/cli/bin/vue.js 这样我们在执行vue命令的时候就可以找到vue.js进行执行 脚手架实现的原理 首先来看几个问题: 为什么全局安装@vue/cli后会添加得命令为vue? 那是因为在package.json中，通过bin来配置的是vue,指向了bin/vue.js 全局安装@vue/cli时发生了什么？ 首先npm会把当前的包下载到node下面的node_modules这个目录里面,如果是全局安装的，它可能存在/usr/lib这个目录下面。当这个包完全下载完成后，它回去解析package.json中的bin这个目录,如果说发现bin下面有vue的配置，它就会在node的bin目录下。(说白了就是:把对应的依赖下载到指定的node_modules目录下面，然后去配置一个bin的软连接) 执行vue命令时发生了什么？为什么vue指向一个js文件，我们却可以正好直接通过vue命令去执行它？ 操作系统会根据which vue找到bin命令有没有被注册。 这是因为我在js目录上方添加一个环境变量 #!/usr/bin/env node 两种写法的区别#!/usr/bin/env node; #!/usr/bin/node 第一种是在环境变量中查找node 第二种是直接执行/usr/bin目录下的的node 脚手架的开发流程 脚手架开发流程详情 开发流程 脚手架开发流程 脚手架开发难点 分包:将复杂的系统拆分成若干个模块 命令注册: vue create vue add vue invoke 参数解析 options全称:--version,--help options缩写:-V,'-h' 带params的options:--path /Users/xucong/Desktop/RoyCli 示例: vue command [options] 帮助文档 global help Usage Options Commands 实例:vue create的帮助信息 Usage: create [options] create a new project powered by vue-cli-service Options: -p, --preset Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset Skip prompts and use inline JSON string as preset -m, --packageManager Use specified npm client when installing dependencies -r, --registry Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists --merge Merge target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions --skipGetStarted Skip displaying \"Get started\" instructions -h, --help output usage information Missing required argument . 还有很多，比如: 命令行交互 日志打印 命令行文字变色 网络通信:HTTP/WebSocket 文件处理 等等... 脚手架本地link的标准流程 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件: cd your-cli-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件: cd your-cli-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解npm link: npm link your-lib: 将当前项目中的node_modules下指定的库文件链接到node全局node_modules下的库文件 npm link: 将当前项目链接到node全局node_modules中作为一个库文件，并解析bin配置创建可执行文件 理解npm unlink: npm unlink: 将当前项目从node全局node_modules中移除 npm unlink your-lib: 将当前项目中的库文件依赖移除 Lerna简介 原生脚手架开发痛点分析 痛点一:重复操作 多Package本地link 多Package依赖安装 多Package单元测试 多Package代码提交 多Package代码发布 痛点二:版本一致性 发布时版本一致性 发布后相互依赖版本升级 package 越多，管理复杂度越高 Lerna简介 Lerna是一个优化基于git+npm的多package项目的管理工具 优势 大幅减少重复操作 提升操作的标准化 Lerna是架构优化的产物，它揭示了一个结构真理:项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心 lerna开发脚手架流程 基于Lerna创建项目 安装Lerna npm install -g lerna 在创建目录下执行lerna初始化命令 lerna init 会在目录结构下创建一个packages文件夹和lerna.json文件,并且为我们初始化一个git仓库 通过lerna来创建package lerna create core lerna create utils 创建package的时候会让你输入package name，我们试用npm包组织管理，如@roy-cli-dev/core、@roy-cli-dev/utils 在npm上注册一个命令roy-cli-dev的组织，这样我们发布后就会在指定组织下面,如图 通过lerna来添加依赖 # 给所有的packge添加依赖 lerna add @imooc-cli/utils # 给指定的package添加依赖 lerna add @imooc-cli/utils packages/core 通过lerna来删除依赖 # 删除package里面的node_modules learn clean # 删除package里面的node_modules lerna exec -- rm -rf node_modules/ # 安装依赖 在package.json里面添加了依赖 lerna bootstap # 删除指定package里面的node_modules lerna exec --scope core -- rm -rf node_modules/ 删除的是node_modules文件夹，不会删除package.json 中的依赖 执行单元测试 lerna run test 发布项目 我们先查看下版本 lerna --version 运行报错，如图 这说明让我们git commit,首先我们在github上创建一个工程并把链接链接到本地推送 在没有把项目链接到github上的时候，执行lerna public也会报上述错误。下面开始发布项目 lerna publish 这个报错说明我们没有在本地登录npm，因此我们需要执行npm login，登录npm，然而登录的时候出现报错，如图: 该报错说明我们没有把镜像换成npm镜像，还是使用的taobao镜像,执行npm config set registry http://registry.npmjs.org，切换镜像为npm的就可以了 在执行lerna public的时候，如果报错是lerna ERR! E402 You must sign up for private packages,这说明lerna项目默认都是私有项目，我们要在packages的每个包里面的package.json里面添加配置信息: \"publishConfig\": { \"access\": \"public\" } 我们继续执行lerna public,如图 没有显示错误，npm上也没有看到包，这时候看控制台日志就能看出，我们的版本已经存在了，这是为什么呢？因为我们在lerna publish的时候，lerna会在git上把版本打成tag标签，如图: 这时候我们需要重新提交代码到github上。 然后执行lerna publish，最终结果如下: 显示发布成功，然后在npm上搜索可以找到这两个包 Lerna使用细节 lerna init: 会自动完成git初始化，但不会创建.gitignore，这个必须要手动添加，否则会将node_modules目录都上传到git，如果node_modules已经加入git stage，使用: git reset HEAP 执行unstage操作，如果文件已经被git监听到变更，可使用: git checkout -- 将变更作废，记得在执行操作之前将文件加入.gitignore learn add: 第一个参数:添加npm包名 第二个参数:本地package的路径 选项: --dev:将依赖安装到devDependencies，不加时安装到dependencies lerna add [loc] --dev lerna link: 如果未发布上线，需要手动将依赖添加到package.json在执行lerna link lerna clean: 只会删除node_modules，不会删除虎package.json中的依赖 learn exec 和 lerna run: --scope属性后添加的是包名，而不是package的路径，这点和lerna add用法不同 lerna publish: 发布时会自动执行git add package-lock.json,所以package-lock.json不要加入.gitignore 先创建远程仓库，并且同步一次master分支 执行lerna publish前先完成npm login 如果发布的npm包名为:@xxx/yyy的格式，需要先在npm注册名为:xxx的organization，否则可能会提交不成功 发布到npm group时默认为private，所以我们需要手动在package.json中添加如下配置: \"publishConfig\": { \"access\": \"public\" } 如何通过Yargs来开发脚手架? 脚手架分为三部分构成(vue create vuex) bin:主命令在package.json中配置bin属性，npm link本地安装 command:命令 options:参数(boolean/string/number) 文件顶部增加#!/usr/bin/env node,这行命令的用途时告诉操作系统要在环境变量当中查询到node命令,通过node命令来执行文件 脚手架初始化流程 构造函数:Yargs() (通过Yargs构造函数的调用去生成一个脚手架) 常用方法: Yargs.options (注册脚手架的属性) Yargs.option Yargs.group (将脚手架属性进行分组) Yargs.demandCommand (规定最少传几个command) Yargs.recommendCommands (在输入错误command以后可以给你推荐最接近的正确的command) Yargs.strict (开启以后可以报错提示) Yargs.fail (监听脚手架的异常) Yargs.alias (起别名) Yargs.wrapper (命令行工具的宽度) Yargs.epilogus (命令行工具底部的提示) 脚手架参数解析方法 hideBin(process.argv) Yargs.parse(argv, options) 命令注册方法 Yargs.command(command,describe, builder, handler) Yargs.command({command,describe, builder, handler}) lerna有什么用，以及它是如何实现命令的调用? Lerna是基于git+npm 的多package项目管理工具,它的作用是降低我们很多package项目当中的操作成本,完成一个发布的标准版 实现原理: 通过import-local优先调用本地lerna命令 通过Yargs生成脚手架，先注册全局属性，再注册命令，最后通过parse方法解析参数 lerna 命令注册时需要传入builder和handler两个方法，builder方法用于注册命令专属的options,handler用来处理命令业务的逻辑 lerna通过配置npm本地依赖的方法来进行本地开发，具体写法是在package.json的依赖中写入:file:your-local-module-path,在lerna public的时候自动将该路径替换 Node.js模块路径解析流程 Node.js项目模块路径解析是通过require.resolve方法来实现的 require.resolve就是通过Module._resolveFileName方法实现的 require.resolve实现原理: Module._resolveFileName方法核心流程有3点: 判断是否为内置模块 通过Module._resolveLookupPaths方法生成node_modules可能存在的路径 通过Module._findPath查询模块的真实路径 Module._findPath核心流程有4点: 查询缓存(将request和paths通过\\x00(空格)合并成cacheKey) 遍历paths,将path与request组成文件路径basePath 如果basePath存在则调用fs.realPathSync获取文件真实路径 将文件真实路径缓存到Module._pathCache(key就是前面生成的cacheKey) fs.realPathSync核心流程有3点: 查询缓存(缓存的key为p，即Module._findPath中生成的文件路径) 从左往右遍历路径字符串，查询到/时，拆分路径，判断该路径是否为软连接，如果是软连接则查询真实链接，并生成新路径p，然后继续往后遍历，这里有1个细节需要注意: 遍历过程中生成的子路径base会缓存在knownHard和cache中，避免重复查询 遍历完成得到模块对应的真实路径，此时会将原路径original作为key，真实路径作为value，保存到缓存中 require.resolve.paths等价于Module._resolveLoopupPaths,该方法用于获取所有的node_modules可能存在的路径 require.resolve.paths实现原理: 如果路径为/(根目录)，直接返回['/node_modules'] 否则，将路径字符串从后往前遍历，查询到/时，拆分路径，在后面加上node_modules,并传入一个paths数组，直至查询不到/后返回paths数组 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/03-week03-笔记.html":{"url":"pages/GreedyCat/03-week03-笔记.html","title":"Week03 笔记","keywords":"","body":"脚手架核心流程开发 脚手架需求分析 大厂做项目流程 痛点分析 创建项目/组件时，存在大量重复代码拷贝:快速复用已有沉淀 协同开发时，由于git操作不规范，导致分支混乱，操作耗时:制定标准的git操作规范并集成到脚手架 发布上线耗时，而且容易出现各种错误:定制标准流程混合规范并集成到脚手架 需求分析 通用的研发脚手架 通用的项目/组件创建能力 模板支持制定，制定后能够发布生效 模板支持快速接入，极低的接入成本 通用的项目/组件发布能力 发布过程自动完成标准的git操作 发布成功后自动删除开发分支并创建tag 发布后自动完成云构建、CDN、域名绑定 发布过程支持测试/正式两种模式 git规范 架构设计图 脚手架拆包策略 拆包原则 核心流程: core 命令:commands 初始化 发布 模型层:models Commands命令 Project项目 Component组件 Npm模块 Git仓库 支撑模块: utils Git操作 云构建 工具方法 API请求 Git API core模块技术方案 命令执行流程 准备阶段 命令注册 命令执行 准备阶段的过程 涉及技术点 核心库 import-local:优先执行本地的命令 commander:命令注册 工具库 npmlog:打印日志 fs-extra:文件操作，基于fs封装了很多有价值的操作 semver:版本比对 colors:在终端中打印不同的颜色文本 user-home:快速拿到用户的主目录 dotenv:获取环境变量 root-check:root账户的检查和自动降级 代码编写 通过week02-笔记里面的代码来做修改。 通过拆包原则，在根目录下创建 core，modules，commands，utils 目录，修改lerna.json里面packages的代码: { \"packages\": [ \"core/*\", \"commands/*\", \"models/*\", \"utils/*\" ], \"version\": \"1.0.4\" } 然后把packages目录下的core文件夹移动到根目录core文件夹下面并把core改成cli，把utils文件夹拖到根目录下的utils目录下。 在core/cli/bin/index.js里面写入下面代码:const importLocal = require('import-local'); if (importLocal(__filename)) { require('npmlog').info('cli','正在使用roy-cli-dev本地版本') } else { require('../lib')(process.argv.slice(2)); } import-local作用是当全局node_modules和本地node_modules存在相同的库，优先加载本地的,npmlog为日志打印 检查版本开发core/cli/lib/index.jsconst pkg = require('../package.json'); function checkPkgVersion(){ log.info('cli',pkg.version); } 这样我们就可以获取到package.json里面的版本号，那么我们想一想为什么require加载资源的方式有那些？ require可以加载资源文件有.js,.json,'.node',加载其他的文件require会默认把他当做js来执行 加载.js时需要我们必须在js文件中，使用module.exports或者exports= 加载.json时会使用JSON.parse进行转换编译从而得到一个json对象 .node是一个C++插件 检查Node版本core/cli/lib/index.js function checkNodeVersion() { //第一步，获取当前Node版本号 const currentVersion = process.version; const lastVersion = constants.LOWEST_NODE_VERSION; //第二步，对比最低版本号 if (!semver.gte(currentVersion, lastVersion)) { throw new Error(colors.red(`roy-cli-dev 需要安装v${lastVersion}以上版本的Node.js`)); } } 为什么我们要检查Node版本? 因为我们可能用到一些Node API在低版本是不支持的，所以我们要设置一个最低的版本号。 检查root启动 function checkRoot() { //使用后，检查到root账户启动，会进行降级为用户账户 const rootCheck = require('root-check'); rootCheck(); } 检查用户主目录 const userHome = require('user-home');//获取当前用户主目录 const pathExists = require('path-exists').sync;//判断目录是否存在 function checkUserHone(){ if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登录用户主目录不存在!!!')); } } 检查入参和debug模式开发 ```js function checkInputArgs(){ const minimist = require('minimist');//获取入口参数 const args = minimist(process.argv.slice(2)); checkArgs(args); } function checkArgs(args){ if (args.debug) { process.env.LOG_LEVEL = 'verbose'; } else { process.env.LOG_LEVEL = 'info'; } log.level = process.env.LOG_LEVEL; } 10. 检查环境变量 ```js unction checkEnv() { const dotenv = require('dotenv');//获取环境变量 const dotenvPath = path.resolve(userHome,'.env'); if (pathExists(dotenvPath)) { config = dotenv.config({ path:dotenvPath }); } createDefaultConfig(); } function createDefaultConfig(){ const cliConfig = { home:userHome } if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome,process.env.CLI_HOME); } else { cliConfig['cliHome'] = path.join(userHome,constants.DEFAULT_CLI_HOME); } process.env.CLI_HOME_PATH = cliConfig.cliHome; } 检查当前版本是否是最新版本 使用lerna创建get-npm-info模块lerna create ./utils/get-npm-info，在utils/get-npm-info里面编写代码: const axios = require('axios'); const urlJoin = require('url-join'); const semver = require('semver'); function getNpmInfo(npmName,registry) { if (!npmName) { return null; } const registryUrl = registry || getDefaultRegistry(); const npmInfoUrl = urlJoin(registryUrl,npmName); return axios.get(npmInfoUrl).then(response => { if (response.status === 200) { return response.data; } return null; }).catch(err => { return Promise.reject(err); }) } function getDefaultRegistry(isOriginal = false) { return isOriginal ? \"https://registry.npmjs.org/\" : \"https://registry.npm.taobao.org/\"; } async function getNpmVersions(npmName,registry) { const data = await getNpmInfo(npmName,registry); if (data) { return Object.keys(data.versions); } else { return []; } } function getSemverVersions(baseVersion,versions) { return versions.filter(version => semver.satisfies(version,`^${baseVersion}`) ).sort((a,b)=> semver.gt(b,a)); } async function getNpmSemverVersion(baseVersion,npmName,registry) { const versions = await getNpmVersions(npmName, registry); const newVersions = getSemverVersions(baseVersion, versions); if (newVersions && newVersions.length > 0) { return newVersions[0]; } } module.exports = { getNpmInfo, getNpmVersions, getSemverVersions, getNpmSemverVersion }; 在core/cli/package.json里面添加链接库\"@roy-cli-dev/get-npm-info\": \"file:../../utils/get-npm-info\",core/cli/lib/index.js代码如下: async function checkGlobalUpdate() { //1.获取当前版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; //2.调用npm API,获取所有版本号 const {getNpmSemverVersion} = require('@roy-cli-dev/get-npm-info'); //3.提取所有版本号，比对哪些版本号是大于当前版本号 const lastVersion = await getNpmSemverVersion(currentVersion,npmName); if (lastVersion && semver.gt(lastVersion,currentVersion)) { //4.获取最新的版本号，提示用户更新到该版本 log.warn(colors.yellow(`请手动更新${npmName},当前版本:${currentVersion},最新版本:${lastVersion} 更新命令:npm install -g ${npmName}`)) } } 检查是否需要更新的步骤为以上四步。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/07-week07-笔记.html":{"url":"pages/GreedyCat/07-week07-笔记.html","title":"Week07 笔记","keywords":"","body":"B段项目需求分析和架构设计 需求初步分析 首页 导航条:未登录和已登录 未登录:显示登录按钮 已登录:显示创建设计，我的作品还有下拉菜单(个人设置和登出) 展示列表 图片 标题 作者信息和使用人数 Hover显示创建按钮 搜索 搜索以后有清空按钮 点击更多展示列表(每页展示8条) 我的作品(展示四条，右侧到我的作品页面) 登录 发送验证码 登录 表单验证 模板详情页 展示图片、二维码、标题、作者 使用该模板创建 下载图片 我的作品 作品或者模板列表 编辑 统计 删除 转赠 下载图片 搜索 翻页 编辑器 左边:组件面板 - 可以添加到编辑器中的组件类型 文本 图形 形状 中间:编辑器区域 - 从左侧添加的组件都会呈现到编辑器中 点击选中 拖动改变位置 拖动改变大小 快捷键 右侧菜单 右侧:属性编辑面板 - 可以编辑中间组件的属性以及其他功能 元素属性 图层面板，隐藏显示，锁定解锁，拖动排序 背景设置 顶部:保存、发布、预览和设置 点击保存 点击预览、弹框 左侧显示预览 右侧设置标题，描述和头图 发布、弹框 左侧显示截图 右侧显示默认渠道，并且可以进行编辑 其他:不属于界面上的一些功能(定时保存，退出前提示等等) 难点分析 发现核心问题: 编辑器和h5页面其实整个就就是一系列元素构成的 ，这些元素的自然应该抽象成组件，这些组件的属性应该怎样设计，在不同的项目中怎样做到统一的用法。 在不同的项目中怎样做到统一的使用？ 编辑器页面做的核心功能其实就是对一系列组件增删改的操作。所以怎么设计编辑器的整体状态 组件有多种，它的属性也有多种，1 怎样将这些属性渲染成不同的表单组件(也有可能不仅仅是表单组件) 2 在表单组件中，属性做出修改以后，怎样实时将值反射到组件中去 组件的可扩展性，虽然在需求中我们只要求了三种组件，但是最初的设计是否能够具有良好的可扩展性 编辑器有很多的交互:拖动移动位置，拖动改变大小，快捷键，右键菜单，缩放，重做/回滚等等功能。它们都是在核心问题之外的交互，那么很自然，我们是否能将这些功能进行解耦? 业务组件库难点解决方案 第一个问题: 在不同的项目中重用这些组件，所以把这些组件自然而然的抽取成一个代码库。降低和任何一个项目的耦合性，单独代码库让业务组件有独立的标准开发流程: 编码 测试 打包生成通用JS模块 发布至NPM CI/CD - 自动发布 第二个问题，组件属性设计 从需求可以得知，需求地址 组件的属性和这些可以编辑的属性很自然的一一对应的结果。对于每一个组件，它们需求中的属性其实可以分为两大类。 // 方案一，将 css 作为一个统一的对象传入 // 内部实现比较简单 // 方案二，将 所有属性全部平铺传入 // 内部实现会复杂一点 const styles = stylePick(props) // 方案一内部实现简单，但是保存的时候要多一层结构，并且更新数据的时候要知道是样式还是其他属性 // 方案二 内部实现稍微复杂一点，但是保存简单，更新数据不需要再做辨别 所以我觉得第二种解决方案是更好的，当然你也可能总结出更好的方案，就看大家自己怎样分析这个问题了。 这些组件目前有一些公有的属性，称之为公共属性。提到公共属性我们就要注意代码重用的问题 // 比如 在 Ltext 和 LImage 中都点击跳转的功能，属于公共属性的行为 // 抽象出一些通用的函数，在组件中完成通用的功能 import useClick from 'useClick' useClick(props) //这里只是分析可能遇到的问题，并不会写具体的代码，都用伪代码代替。 第三个问题:组件扩展性的问题 组件扩展性正在业务组件库中不存在什么问题，因为每个组件都是独立的个体，它们的实现方案相对独立，那么这里的扩展性是指在编辑器中是否能对它进行适配，包括展示和编辑的适配 编辑器难点解决方案 编辑器页面主要有三个部分，为左中右结构，左侧为组件模板库，中间为画布，右侧是设置面板 左侧是预设各种组件模板并进行添加 中间是使用交互的手段更新元素的值 右侧是使用表单的手段更新元素的值 第一个问题:整体状态设计 不难看出我们的编辑器其实就是围绕着中间画布的元素来进行一些列操作，那么自然而然是一系列的元素组成的，我们应把它抽象成一系列拥有特定数据结构的数组 export interface EditorStore { // 供中间编辑器渲染的数组 components: ComponentData[]; // 一系列和其他状态相关的信息，应该有很多 // 当前编辑的是哪个元素，uuid currentElement: string; } interface ComponentData { // 每个元素 props 所有属性 // 我们上节课已经分析过了，是 css 属性和其他属性的混合体 // 并且我们会把这些属性完全平铺开来，其实在编辑器分析过后，你就能更感受到平铺的一个好处 props: { [key: string]: any }; // id，uuid v4 生成 id: string; // 业务组件库名称 l-text，l-image 等等 name: string; } 场景设计 将元素渲染到画布 使用store中componentsd当中的数据，循环渲染 compoents.map(component => ） 渲染左侧预设组件模板 原理和上面一样的，只不过数据是预设好的，这个可以写死在本地，也可以从服务端获取。他们和中间元素不一样的是，这些组件都有一个点击事件，我们可以添加一层wrapper来解决这个问题。这样也可以和内部lego components做到隔离，互不影响。 compoents.map(component => ） 添加和删除组件 非常简单的逻辑，向store中添加和删除组件即可 // 添加 components.push({type: '', props: {} }) // 删除 components = components.filter((component) => component.id !== id) 将属性映射到表单 我们用一张图来表述应用的整个流程: 现在我们完成了数据到画布渲染这第一步，接下来要到点击画布中的某个组件需要将该元素的属性以不同表单的形式展示到右侧 一个很容易想到的是直接将这些表单组件写死到页面中去。 const currentComponentProps = { text: '123', color: '#fff' } ... 缺点: - 代码冗长 - 对不同类型业务组都要判断 - 可扩展性很差 看到界面展示，应该想到另一个纬度，界面UI其实就是数据的抽象，所以我们自然想到的就是使用特定的数据结构将它渲染成界面。 const textComponentProps = { text: 'hello', fontFamily: 'HeiTi', color: '#fff' } const propsMap = { text: { component: 'input' }, fontFamily: { component: 'dropdown', }, color: { component: 'color-picker' } } // 这里我们还是循环所有属性，在每个属性中渲染对应处理这个属性的组件 map(textComponentProps, (key, value) => { }) 当遇到没有类似的Form组件的时候，我们可以进行二次开发，只要这个组件有value的对应属性 这在一定程度上还满足了可扩展性这个命题，组件的属性可以扩展，对于color这个属性，我们自己开发一个取色器或者二次封装一个取色器组件，只要传入value属性即可 组件更新 我们的数据流始终保持自上而下的顺序，也就是说表单更新最终要反射回到总体的store当中去。这个时候我们在对应的组件当中发射出一个事件，change，当change发生的时候，我们能够知道是哪个元素的哪个属性，以及新的值是什么，我们就用这些信息更新这个值，这样store完成更新，元素的props发生更新，那么整个数据流动就完成了。 map(textComponentProps, (key, value) => { const handleChange = (propKey, newValue, id) => { const updatedComponent = store.components.find(component.id === id) updatedComponent.props[propKey] = newValue } } 除了表单的更新，还要说一下画布中的交互更新，其实画布中的更新也是采用发射事件的方式对store的某些值进行更新，比如说拖动改变位置，最终拖动的过程中也是触发对应的change事件去用相同饿逻辑对值进行更新，这里也有注意，我们需要在业务组件外层，添加Wrapper，各个事件都是放在这个Wrapper上面的，比如支持拖动，改变位置后发送change事件。 对于复杂的组件也是如此，不管你内部的逻辑有多复杂，添加上传图片，删除，逻辑，最终发送出来的事件里面的值，就是对这个pictures的值的变换，比如多加了一张照片，那就是数组中的值变成了三项。 画布操作的插件化 比如快捷键，他只写成普通的可重用的函数即可，提供回调即可，在回调中，我们可以对全局store进行一系列的改写，而快捷键这个功能和编辑器是没有任何关系的 总体架构 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/09-week09-笔记.html":{"url":"pages/GreedyCat/09-week09-笔记.html","title":"Week09 笔记","keywords":"","body":"项目整体搭建 前端工具链 前端的飞速发展:带来了更复杂的项目 项目的常见需求 - 依赖管理，预编译，构建打包，压缩合并等 随着项目越来越复杂 - 诞生了 前端工程化 随着工程化的产生 - 产生了对应的 前端工具栏链 静态类型语言 动态语言的弊端 typescript flow 代码风格检查Linter 多人协作的弊端，风格各异，维护和扩展的困难 eslint 包管理器 npm yarn - 兼容 npm registry 开发服务器 live reload HMR 打包工具Bundler 将源代码转换成符合生成环境的代码 Webpack - Loader，Plugin，大而全的功能 Rollup - 专注于打包 输出多种格式 Parcel - 零配置 任务管理工具Task Runner 自动执行项目所需的重复任务 CSS预处理 优化图片 合并压缩JavaScript 文件处理(拷贝，删除) 文件监听变化 Gulp - 流式管道写法组合多个任务 Webpack - 通过插件的方式 npm scripts 或者 Shell脚本 脚手架 Scaffolding tools 将工具链聚合在一个工具内 简单，快速，零配置 Vue - Vue CLI，Vite React - createa-react-app Angular - Angular CLI Vue CLI 和 Vite 对比 Vue CLI的功能 工程脚手架 开发服务器 插件系统 用户UI界面 Vue CLI构建是基于Webpack的。主要耗时都在Webpack的性能上。 Vite 与Vue CLI类似，Vite也是一个提供基本项目脚手架和开发服务器的构建工具 然后，Vite并不是基于Webpack的，它有自己的开发服务器，利用浏览器中的原生ES模块。这种架构使得Vite比Webpack的开发服务器快了好几个数量级。Vite采用Rollup进行构建，速度也更快。 Vite目前还处于测试阶段，看来Vite项目的目的并不是像Vue CLI那样的一体化工具，而是专注于提供一个快速的开发服务器和基本的构建工具。 对比 Vite的缺点 测试阶段 只支持新版支持ES modules的浏览器 第三方库也需要都支持ES modules CommandJS支持有限 开发构建属于两套系统，可能导致生产和开发的不一致 Git Flow规范 所有的这些规范都是针对特定的 多人 设定的，意在让多人协作的过程更顺畅，更简单，减少不必要的冲突和时间的浪费。 预设两个分支 master只能用来包括产品代码。你不能直接工作在这个master分支上 develop是你进行任何新的开发的基础分支 这两个分支被称之为长期分支 功能开发feature 整合回到develop 等待更全面的测试 等待和develop一起进行发布 管理release 新功能已经添加，bug已经修复 代码已经被测试 release分支使用版本号命名的 bug修复hotfix 针对master分支 优点:清晰可控 缺点:相对复杂，不合适持续发布 Github Flow Github Flow 官方文档 根据需求，从master拉出分支 激烈的开发阶段，提交commit 开发完毕，发起PR(pull request) 代码评审 部署，并且测试 没问题，merge到master Github Flow的最大有点就是简单，对于\"持续发布\"的产品，可以说是最合适的流程。 两大规则 branch命名 feature开头代表功能开发 hotfix开头代码bug修复 commit信息，必须言之有物，杜绝update, fix bug这类废话 SPA应用路由的基本原理 SPA和普通网页应用的区别 普通网页 跳转到新网页，每次冲洗加载所有资源 HTML内容是后端直接渲染的 SPA应用 不跳转，JS拦截器，修改URL JS动态渲染DOM内容 SPA路由的实现方式 History API pushState文档地址 codesanbox演示地址 URL Hash SPA优点 速度快 体验好 为前后端分离提供了实践场所 什么是状态管理工具 首先搞清楚，是否 真的 需要状态管理工具。 它随着SPA的出现，而浮出水面。客户端需要处理复杂的状态数据。 多个组件需要共享的一系列数据，称之为 全局数据 解决方案 方案一:单向数据流，从父组件传递到子组件 缺点 多层传递非常反锁 中间传递层有可能根本不需要这个数据 根组件压力太大，逻辑代码会非常繁杂 方案二 使用全局对象 缺点 数据非响应式 修改无法追踪 直接从组件获取数据是一种反模式 状态管理工具三杰 Vuex Redux Mobx 状态管理工具的特点 store，神奇的全局数据结构:single source of truth 不能随意修改，调用特殊的方法来实现数据修改 变化可追溯，可预测(predictable) Vuex Vue的数据流 const Counter = { // state data () { return { count: 0 } }, // view template: ` {{ count }} `, // actions methods: { increment () { this.count++ } } } 出现问题:多组件共享状态 根组件多层传递的困境 多组件同步数据的繁琐 Vuex的解决方案 Vuex的特点 核心就是一个store Vuex的状态是响应式的 不能直接改变store中state的值，需要显式的提交Mutation const store = createStore({ state: { count: 0 }, mutations: { add (state) { state.count++ } } }) store.commit('add') console.log(store.state.count) Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/10-week10-笔记.html":{"url":"pages/GreedyCat/10-week10-笔记.html","title":"Week10 笔记","keywords":"","body":"B端编辑器技术实现方案 编辑器页面主要有三部分，为左中右结构，左侧为组件模板库，中间为画布，右侧设置面板。 左侧是预设各种组件模板并进行添加 中间是使用交互得手段更新元素的值 右侧是使用表单的手段更新元素的值 总体状态结构 整个编辑器使用一个store来实现具体功能，总体设计如下 export interface EditorProps { // 供中间编辑器渲染的数组 components: ComponentData[]; // 当前编辑的是哪个元素，uuid currentElement: string; // 当然最后保存的时候还有有一些项目信息，这里并没有写出，等做到的时候再补充 } export interface ComponentData { // 这个元素的 属性，属性请详见下面 props: {[key: string]: any}; // id，uuid v4 生成 id: string; // 业务组件库名称 l-text，l-image 等等 name: string; } 业务组件库实现方案 编辑器和h5页面其实整个就是一系列元素构成的， 这些元素的自然应该抽象成组件。 单独代码库 在不同的项目中重用这些组件，所以把这些组件自然而然抽取成一个代码库。降低和任何一个项目的耦合性没单独代码库让业务组件有独立的标准开发流程: 编码 测试 打包生成通用JS模块 发布至NPM CI/CD - 自动发布 原则 业务组件库大多数都是展示型组件，其实就是把对应的template加上属性(大部分是CSS属性)展示出来，会有少量行为，比如点击跳转等，而且这些组件会在多个不同的端进行展示，所以业务组件库就是从简的原则，必须避免和编辑器编辑流程的耦合。 组件命名 使用一个字母(L表示)加组件的名称:比如LText或者l-text 组件属性设计 从需求可以得知，需求地址 组件的属性和这些可以编辑的属性很自然的一一对应的结果。对于每一个组件，它们需求中的属性其实可以分为两大类。 公共属性处理 import { mapValues, without } from 'lodash-es' //组件公共属性 export interface CommonComponentProps { // actions actionType: string; url: string; // size height: string; width: string; paddingLeft: string; paddingRight: string; paddingTop: string; paddingBottom: string; // border type borderStyle: string; borderColor: string; borderWidth: string; borderRadius: string; // shadow and opacity boxShadow: string; opacity: string; // position and x,y position: string; left: string; top: string; right: string; } //设置默认属性值 export const commonDefaultProps: CommonComponentProps = { // actions actionType: '', url: '', // size height: '', width: '373px', paddingLeft: '0px', paddingRight: '0px', paddingTop: '0px', paddingBottom: '0px', // border type borderStyle: 'none', borderColor: '#000', borderWidth: '0', borderRadius: '0', // shadow and opacity boxShadow: '0 0 0 #000000', opacity: '1', // position and x,y position: 'absolute', left: '0', top: '0', right: '0' } //文本组件属性 export interface TextComponentProps extends CommonComponentProps { text: string; fontSize: string; fontFamily: string; fontWeight: string; fontStyle: string; textDecoration: string; lineHeight: string; textAlign: string; color: string; backgroundColor: string; } export interface ImageComponentProps extends CommonComponentProps { src: string; } //文本属性设置默认参数 export const textDefaultProps: TextComponentProps = { // basic props - font styles text: '正文内容', fontSize: '14px', fontFamily: '', fontWeight: 'normal', fontStyle: 'normal', textDecoration: 'none', lineHeight: '1', textAlign: 'left', color: '#000000', backgroundColor: '', ...commonDefaultProps } export const imageDefaultProps: ImageComponentProps = { src: 'test.url', ...commonDefaultProps } //剔除文本中其他的属性 export const textStylePropNames = without(Object.keys(textDefaultProps), 'actionType', 'url', 'text') //剔除图片中其他的属性 export const imageStylePropsNames = without(Object.keys(imageDefaultProps), 'src') export const transformToComponentProps = (props: T) => { // 创建一个对象，对象的key相同，值是通过 iteratee 产生的 return mapValues(props, (item) => { return { type: (item as any).constructor as StringConstructor, default: item } }) } 抽离页面样式和点击事件的处理 const useComponentCommon =(props: Readonly>, picks: string[]) => { const styleProps = computed(() => pick(props, picks)) const handleClick = () => { if (props.actionType === 'url' && props.url) { window.location.href = props.url } } return { styleProps, handleClick } } export default useComponentCommon 场景设计 渲染左侧预设组件模板 数据都是预设好的，这个可以写死本地，也可以从服务端获取。他们和中间元素不一样的是，这些组件都有一个点击事件，我们可以添加一层wrapper来解决这个问题。这样也可以和内部的lego components做到隔离，互不影响。 components.map(component => ) 左侧写死数据如下: export const defaultTextTemplates = [ { text: '大标题', fontSize: '30px', fontWeight: 'bold', tag: 'h2' }, { text: '正文内容', tag: 'p' }, { text: '链接内容', color: '#1890ff', textDecoration: 'underline', tag: 'p' }, { text: '按钮内容', color: '#ffffff', backgroundColor: '#1890ff', borderWidth: '1px', borderColor: '#1890ff', borderStyle: 'solid', borderRadius: '2px', paddingLeft: '10px', paddingRight: '10px', paddingTop: '5px', paddingBottom: '5px', width: '100px', tag: 'button', textAlign: 'center' } ] 添加和删除组件 非常简单的逻辑，向store中添加和删除组件即可 //添加 components.push({type:'',props:{}}) 更新属性的过程 点击某一个组件，选中 将它的属性以不同类型的表单呈现在右侧 编辑表单中的值，在值更新的同时将数据更新至页面 type handleChange = (newValue:any) => void 支持属性展示和编辑的组件 必须提供一个属性传入需要编辑的值，默认为value 必须提供一个事件发射出编辑后新的值，默认为change 难点 编辑组件 看到页面展示，应该想到另一个纬度，界面UI其实就是数据的抽象，所以我们自然想到的就是使用特定的数据结构将它渲染成界面。 对应关系 export interface PropToForm { component: string; subComponent?: string; extraProps?: { [key: string]: any }; text?: string; options?: { text: string | VNode; value: any }[]; initalTransform?: (v: any) => any; afterTransform?: (v: any) => any; valueProp?: string; eventName?: string; } export type PropsToForms = { [p in keyof TextComponentProps]?: PropToForm; } const fontFamilyArr = [ { text: '宋体', value: '\"SimSun\",\"STSong\"' }, { text: '黑体', value: '\"SimHei\",\"STHeiti\"' }, { text: '楷体', value: '\"KaiTi\",\"STKaiti\"' }, { text: '仿宋', value: '\"FangSong\",\"STFangsong\"' }, ]; const fontFamilyOptions = fontFamilyArr.map(font => { return { value: font.value, text: {font.text} as VNode } }) export const mapPropsToForms: PropsToForms = { text: { text: '文本', component: 'a-textarea', extraProps: { rows: 3 }, afterTransform: (e: any) => e.target.value, }, fontSize: { text: '字号', component: 'a-input-number', initalTransform: (v: string) => parseInt(v), afterTransform: (e: number) => e ? `${e}px` : '', }, lineHeight: { text: '行高', component: 'a-slider', extraProps: { min: 0, max: 3, step: 0.1 }, initalTransform: (v: string) => parseFloat(v), afterTransform: (e: number) => e.toString() }, textAlign: { component: 'a-radio-group', subComponent: 'a-radio-button', text: '对齐', options: [ { value: 'left', text: '左' }, { value: 'center', text: '中' }, { value: 'right', text: '右' } ], afterTransform: (e: any) => e.target.value, }, fontFamily: { component: 'a-select', subComponent: 'a-select-option', text: '字体', options: [ { value: '', text: '无' }, ...fontFamilyOptions ] }, // width: { // text: '宽度', // ...pxToNumberHandler // }, color: { component: 'color-picker', text: '字体颜色' } } 更新表单将数据更新到属性 我们的数据流始终保持自上而下的顺序，也就是说表单更新最终要反射回到总体的store当中去。这个时候我们在对应的组件当中发射出一个事件，change，当change发生的时候，我们能够知道是哪个元素的哪个属性，以及新的值是什么，我们就用这些信息更新这个值，这样store完成更新，元素的props发生更新，那么整个数据流动就完成了。 map(textComponentProps,(key,value) => { const handleChange = (propKey,newValue,id) => { const updatedComponent = store.components.find(component.id === id) updatedComponent.props[propKey] = newValue } }) 优化方案 下拉菜单支持更丰富的类型 组件由虚拟DOM构成，整个应用就是一棵虚拟DOM树 组件怎样转换成虚拟DOM的呢? //Hello.tsx createVNode('h1',null,[props.msg]) //App.vue {name:'App',render:() => {},...} //https://v3.vuejs.org/guide/render-function.html createVNode(_router_view) 组件是虚拟DOM的映射 h函数 //type 元素的类型 //propsOrChildren 数据对象，这里主要表示(props,attrs,dom props,class和style) //children 子节点 h('div',{'class':'div-test'},'hello there') 使用JSX JSX动态组件名称 import {Button} from 'button' const Name = Button; 展开属性 事件的写法 v-on:click => onClick PropsTable.tsx实现 import { computed, defineComponent, PropType, VNode } from 'vue' import { reduce } from 'lodash' import { PropsToForms, mapPropsToForms } from '../propsMap' import { TextComponentProps } from '../defaultProps' import { Input, InputNumber, Slider, Radio, Select } from 'ant-design-vue' const mapToComponent = { 'a-textarea': Input.TextArea, 'a-input-number': InputNumber, 'a-slider': Slider, 'a-radio-group': Radio.Group, 'a-radio-button': Radio.Button, 'a-select': Select, 'a-select-option': Select.Option } as any interface FormProps { component: string; subComponent?: string; value: string; extraProps?: { [key: string]: any }; text?: string; options?: { text: string | VNode; value: any }[]; valueProp: string; eventName: string; events: { [key: string]: (e: any) => void }; } function capitalizeFirstLetter(string: string) { return string.charAt(0).toUpperCase() + string.slice(1) } export default defineComponent({ name: 'props-table', props: { props: { type: Object as PropType, required: true } }, emits: ['change'], setup(props, context) { const finalProps = computed(() => { return reduce(props.props, (result, value, key) => { const newKey = key as keyof TextComponentProps const item = mapPropsToForms[newKey] if (item) { const { valueProp = 'value', eventName = 'change', initalTransform, afterTransform } = item const newItem: FormProps = { ...item, value: initalTransform ? initalTransform(value) : value, valueProp, eventName, events: { ['on' + capitalizeFirstLetter(eventName)]: (e: any) => { context.emit('change', { key, value: afterTransform ? afterTransform(e) : e }); } } } result[newKey] = newItem } return result }, {} as { [key: string]: FormProps }) }) return () => { Object.keys(finalProps.value).map(key => { const value = finalProps.value[key]; const ComponentName = mapToComponent[value.component]; const SubComponent = value.subComponent ? mapToComponent[value.subComponent] : null; const props = { [value.valueProp]: value.value, ...value.extraProps, ...value.events } return ( { value.text && {value.text}} { value.options && value.options.map(option => { return ( {option.text} ) }) } ) }) } } }) Vue组件的三种形式 SFC单文件组件(混合三种标签，返回vue的template) 函数组件Function Component(函数形式，使用JSX或者h函数) function Title(props){ return } render function(对象形式，使用对象上的render方法返回，使用JSX或者h函数) return defineComponent({ render() { return {{this.title}} } }) return defineComponent({ setup(props) { return () => { {{props.title}} } } }) template语法 优点 有非常多的指令，可以快速完成某些任务 基于DOM结构，更容易理解 基于template分析做了很多优化 缺点 不够灵活 JSX或者h函数 优点 灵活，可以利用js来表达各种逻辑 缺点 可读性差 编辑优化 结论: 优先选择template，当template写起来费劲时用jsx Vue推荐在绝大多数情况下使用模板来创建你的HTML。然而在一些场景种，你真的需要JavaScript的完全编程的能力。 右侧最终实现 //RenderVnode.ts import { defineComponent } from 'vue' const RenderVnode = defineComponent({ props: { vNode: { type: [Object, String], required: true } }, render() { return this.vNode } }) export default RenderVnode //PropsTable.vue {{value.text}} import { TextComponentProps } from \"@/defaultProps\"; import { reduce } from \"lodash\"; import { defineComponent, PropType, computed, VNode } from \"vue\"; import { mapPropsToForms, PropsToForms } from \"../propsMap\"; import RenderVnode from './RenderVnode' import ColorPicker from \"./ColorPicker.vue\" interface FormProps { component: string; subComponent?: string; value: string; extraProps?: { [key: string]: any }; text?: string; options?: { text: string | VNode; value: any }[]; valueProp: string; eventName: string; events: { [key: string]: (e: any) => void }; } export default defineComponent({ name: \"props-table\", props: { props: { type: Object as PropType, }, }, components: { RenderVnode, ColorPicker }, setup(props,context) { const finalProps = computed(() => { return reduce( props.props, (result, value, key) => { const newKey = key as keyof TextComponentProps; const item = mapPropsToForms[newKey]; if (item) { const { valueProp = 'value', eventName = 'change', initalTransform, afterTransform } = item; const newItem: FormProps = { ...item, value:initalTransform ? initalTransform(value) : value, valueProp, eventName, events: { [eventName]: (e: any) => { context.emit('change',{key, value: afterTransform ? afterTransform(e) : e}); } } } result[newKey] = newItem; } return result; }, {} as {[key: string]: FormProps} ); }); return { finalProps } }, }); .prop-item { display: flex; margin-bottom: 10px; align-items: center; } .label { width: 28%; } .prop-component { width: 70%; } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/13-week13-笔记.html":{"url":"pages/GreedyCat/13-week13-笔记.html","title":"Week13 笔记","keywords":"","body":"业务组件库打包、发布、添加CI/CD JavaScript模块发展史 模块(modules)是什么? 模块通常是指编程语言所提供的代码组织机制，利用次机制可将程序拆解为独立且同样的代码单元。所谓模块化主要是解决代码分割、作用域隔离、模块之间的依赖管理以及发布到生成环境时的自动大包与处理等多个方面。 模块化的优点 可维护性。因为模块时独立的，一个设计良好的模块会让外面的代码对自己的依赖越少越好，这样自己就可以独立去更新和改进。 命名空间。在js里面，如果一个变量在最顶级的函数之外声明，它就直接变成全局可用。因此，常常不小心出现命名冲突的情况。使用模块化来开发封装变量，可以避免武软全局环境。 重用代码。我们有时候会喜欢之前写过的项目种拷贝代码到新的项目，这没有问题，但是更好的办法是，通过模块引用的方式，来避免重复的代码库。 ES6之前没有模块的年代 // 使用 backbone.js 的方法 全局变量 + 命名空间(namespace) // IIFE 自执行函数，创建一个封闭的作用域，赋值给一个全局变量 var namesCollection = (function() { // private members var objects = []; // Public Method function addObject(object) { objects.push(object); printMessage(object); } // Private Method function printMessage(object) { console.log(\"Object successfully added:\", object); } // public members, exposed with return statement return { addName: addObject, }; })(); namesCollection.addName('roy') 缺点 依赖全局变量，污染全局作用域，不安全 依赖约定命名空间来避免冲突，可靠性不高 需要手动管理依赖并控制执行顺序，容易出错 需要在最终上线前手动合并所有用到的模块 Common.js const bar = require('./bar') module.exports = function() { } 没法在浏览器理直接运行 AMD - (Asnychronous module definition) 采用异步方式加载模块 仅仅需要在全局环境定义require和define，不需要其他的全局变量 通过文件路径或模块自己声明的模块名定位模块 提供了打包工具自动分析依赖并合并 配合特定的AMD加载器使用，RequireJS 同时还诞生了很多类似的模块标准CMD define(function(require) { // 通过相对路径获取依赖模块 const bar = require('./bar') // 模块产出 return function () { } }) ES6 modules // 通过相对路径获取依赖模块 import bar from './bar' // 模块产出 export default function () { } 引入和暴露的方式更加多样 支持复杂的静态分析 Bundler是什么？ 诞生原因 使用import export这种同步加载的方式在大多数浏览器中无法使用。 Bundler - 打包工具 将浏览器不支持的模块进行编译，转换，合并最后生成的代码可以在浏览器良好的运行的工具 Webpack 对于web应用来说:一般采用单JavaScript文件入口 https://webpack.js.org/ npx webpack main.js Rollup 地址 npx rollup main.js --file dist/bundle.js --format iife Webpack与Rollup对比 Webpack 大型SPA项目的模块化构建，也就是web应用。 通过各种Loader处理各种各样的静态资源 通过各种插件Plugins对整体文件进行一些处理 Code splitting将公共模块进行提取 提供一个webpack-dev-server，进行本地开发 支出HMR模块热体换 Rollup Rollup设计之初就是面向ES module的，构建出结构扁平，性能出众的类库。 ES module的规则 import只能作为模块顶层的语句出现，不能出现在function里面或是if 里面 ES import的模块名只能是字符串常量 不管import的语句出现的位置在哪里，在模块初始化的时候所有的import都必须已经导入完成。 使用工具静态分析的过程 Tree shaking机制 - 摇树 目的就是es modules打包生成特定的JS模块文件，并减小它的体积 Webpack与Rollup对比 通过以上的对比可以得出，构建App应用时，webpack比较合适，如果是类库(纯js项目),rollup更加合适。 webpack的优势 强大的生态插件 面向开发应用的特性支持HMR，按需加载，公共模块提取 简化Web开发的环节，图片自动转base64，资源的缓存(添加chunkid) Rollup的优势 构建高性能的模块文件，这正式类库所需要的 编译出来的代码可读性好，内容更小，执行效率更高 配置比较简单 打包什么类型的文件 Commonjs,es6 modules - 需要特殊的module bundler支持 AMD已经有点过时了 - 需要使用特殊的Loader - require.js 浏览器中直接使用 - UMD(Universal Module Definition) 通用的一种JavaScript格式 兼容common.js，AMD，浏览器 https://github.com/umdjs/umd Vue和React都提供了这样的格式 不是一种推荐的格式，太大了。不支持tree shaking (function (root, factory) { if (typeof define === 'function' && define.amd) { // AMD. Register as an anonymous module. define(['b'], factory); } else if (typeof module === 'object' && module.exports) { // Node. Does not work with strict CommonJS, but // only CommonJS-like environments that support module.exports, // like Node. module.exports = factory(require('b')); } else { // Browser globals (root is window) root.returnExports = factory(root.b); } }(typeof self !== 'undefined' ? self : this, function (b) { return {}; })); 结论 首要格式 - ES modules，并且提供支持typescropt的type文件 备选方案 - UMD Snowpack Bundler的问题 当资源越来越多的时候，打包速度越来越慢 大中型项目，启动时间可能达到好几分钟 Snowpack https://www.snowpack.dev/ 利用新版浏览器支持es module的特性 不会被打包 每个文件编译一次，永久呗缓存 当一个文件修改的时候，只需要重新build那一个文件 处理Node_modules中的模块 它扫描node_modules中的模块。找到使用的模块 将每个模块都分别转换成单个js文件 这些单个文件都是esm模块，可以被最新的浏览器直接使用 node_modules/react/**/* -> http://localhost:3000/web_modules/react.js node_modules/react-dom/**/* -> http://localhost:3000/web_modules/react-dom.js 为生成环境Build代码 默认情况下，和开发环境生成的代码是几乎一致的。 提供了插件，生成bundle以后全浏览器兼容的代码。 Vue3的插件系统 一段代码给vue应用实例添加全局功能。它的格式是一个object暴露出一个install()方法，或者一个function 它没有严格的限制，一般有一下几种功能 添加全局方法或者属性 添加全局资源:指令，过滤器等 通过全局混入来添加一些一些组件选项 通过config.globalProperties来添加app实例方法 import { App } from 'vue' import HelloWorld from './HelloWorld' const plugins = { install:(app:App) => { //注册全局属性 app.config.globalProperties.$echo = () => { console.log('a plugin') } //注册全局组件 app.component('hello-world',HelloWorld); app.provide('test',{message:'from plugin'}) } } export default plugins //main.ts import TextPlugin from './TextPlugin' app.use(TextPlugin) // App.vue setup里面 onMounted(() => { console.log(inject('test')) getCurrentInstance()?.appContext.config.globalProperties.$echo(); }) //输出 // {message:'from plugin'} //a plugin 组件库入口文件的设计 所有组件一次性全部导入并且作为插件使用 import LegoComponents from 'lego-components' app.use(LegoComponents) 建立一个入口文件index.ts 将所有组件导入，作为一个数组，创建一个install函数，循环调用app.component 默认导出一个插件(这个install函数) import { App } from 'vue' import LText from './components/LText' import LImage from './components/LImage' import LShape from './components/LShape' const components = [ LText, LImage, LShape ] const install = (app: App) => { components.forEach(component => { app.component(component.name, component) }) } export { LText, LImage, LShape, install } export default { install } 单个组件导入并且作为插件使用 import { LText } from 'lego-components' app.use(LText) // 或者 app.component(LText.name, LText) 每个组件新建一个文件夹，并且创建一个单独的index.ts文件 每个组件设计成一个插件(一个object拥有install方法) 在全局入口文件导出 import { App } from 'vue' import LText from './LText.vue' LText.install = (app: App) => { app.component(LText.name, LText) } export default LText Rollup Typescript处理插件 Typescript处理 TSconfig文档地址 处理node_modules插件 npm依赖的分类 dependencies 运行项目业务逻辑需要依赖的第三方库 npm install '模块名'的时候都会呗解析，下载 devDependencies 开发模式工作流下依赖的第三方库 单元测试，语法转换，lint工具，程序构建，本地开发 等等 peerDependencies 需要核心依赖库，不能脱离依赖库单独使用 //rollup.config.js import vue from 'rollup-plugin-vue' import css from 'rollup-plugin-css-only' import typescript from 'rollup-plugin-typescript2' import { nodeResolve } from '@rollup/plugin-node-resolve' import { name } from '../package.json' const file = type => `dist/${name}.${type}.js` const overrides = { compilerOptions: { declaration: true }, exclude: [\"tests/**/*.ts\", \"tests/**/*.tsx\"] } export { name, file } export default { input: 'src/index.ts', output: { name, file: file('esm'), format: 'es' }, plugins: [ nodeResolve(), typescript({ tsconfigOverride: overrides }), vue(), css({ output: 'bundle.css' }) ], //告诉rollup不要将此打包，而作为外部依赖 external: ['vue', 'lodash-es'] } NPM简介以及package.json的信息更新 NPM的主要功能 从npm服务器下载别人编写的第三方包到本地，比如vue 从npm服务器下载并安装别人编写的命令行程序到本地使用，比如vue-cli 允许用户将自己编写的包或命令行程序上传到npm服务器供别人使用 语义化 - semver 说明网址:https://semver.org/lang/zh-CN/ 版本格式:主版本号.次版本号.修订号(1.0.0)，版本号递增规则如下: 主版本号:当你做了不兼容的API修改 次版本号:当你做了向下兼容的功能性新增 修订号:当你做了向下兼容的问题修正 npm files字段 默认忽略掉gitingore中的内容 直视npm publish的时候需要上传的内容 package.json/README.md/CHANGLOG.md/LICENSE都会包含在其中 CI/CD的概念 业务组件库的开发和发布是随着一系列任务进化的 本地commit钩子韩山虎完成commit验证 代码push到远端以后 跑特定的test(不仅仅是本机的unit test，也可能有时间很长的E2E test) test通过以后检查是否有新的tag，假如有就自动publish一个新的版本 甚至还有更多，自动部署文档站点等等 CI(Continuous integration) - 持续继承 持续继承指的是，频繁的(一天多次)将代码集成到主干。一旦开发人员对应用所做的更改被合并，系统就会通过自动构建应用并运行不同级别的自动化测试(通常是单元测试和集成测试)来验证这些更改，确保这些更改没有对应用造成破坏 快速发现错误 防止分支大幅度偏离主干 持续继承的目的，就是让产品可以快速迭代，同时还能保持高质量 CD(Continuous Delivery) - 持续交付 持续交付指的是，频繁的将软件的新版本，交付给质量团队或者用户，以供评审 CD(Continuous Deployment) - 持续部署 持续部署是持续交付的下一步，指的是代码通过评审以后，自动部署到生成环境。 两大服务 Github Actions Travis Travis使用 配置需要的文档列表 nodejs yml配置文件设置详情 travis deplyment支持的providers列表 travis自动发布npm文档 travis命令行工具生成加密串 travis encrypt --pro 你要加密的内容 --add deploy.api_key // 后面为你要加密的字段名称 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/GreedyCat/15-week15-笔记.html":{"url":"pages/GreedyCat/15-week15-笔记.html","title":"Week15 笔记","keywords":"","body":"Github actions 中文文档 代码在项目的.github/workflows目录下，.yml格式文件。 应用场景 master分支，自动化测试 dev分支，自动部署到测试机 v*.*.*格式的tag，自动上线(支持回滚) 代码演示 触发条件on push branches paths 任务jobs 步骤steps，可自定义，也可使用第三方 # 直接使用 uses 第三方 - uses: actions/checkout@v2 #git pull # 使用 name 和 uses 第三方 - name: Use Node.js uses: actions/setup-node@v1 with: node-version: 14 # 使用 name 和 run - name: lint and test run: | npm i npm run lint npm run test # 直接使用 run - run: npm i - run: npm run lint - run: npm run test 操作 新建workflow 新建deno.yml name: Deno on: push: branches: #分支 - main paths: #触发条件 - '.github/workflows/**' # - '__test__/**' # dev 不需要立即测试 - 'src/**' jobs: test: runs-on: ${{ matrix.os }} # runs a test on Ubuntu, Windows and macOS strategy: matrix: deno: [\"v1.x\", \"nightly\"] os: [macOS-latest, windows-latest, ubuntu-latest] steps: - uses: actions/checkout@v2 - name: print node version run: | #执行自定义命令 node -v npm -v 当我们执行git push的时候，推送到github，在Actions里面我们可以看到我们推送的内容，这时候状态未未执行，有个黄色小圆点，当正在执行的时候是一个loading的小圆点，执行成功为对勾，失败为红色叉。 如果失败，请查看失败说明。 Docker 介绍 Docker就是一种虚拟机技术，比传统虚拟机(如vmware,virtualbox)要更加简单，轻量 启动快 资源占用少 体积小 安装 文档 安装完记得镜像加速 安装完，运行docker version可查看版本 基本概念 使用vmware、virtualbox时，步骤如下 下载一个centos.iso文件 使用vmwaire安装一个系统A 使用vmwaire安装一个系统B ...... 此处的centos.iso文件就是一个image镜像，安装出来的系统就是一个一个的container容器。 docker的所有image都可以在https://hub.docker.com/搜索并下载，还可以自定义image上传到这个仓库 常用命令 如果没有安装，可以在play with docker体验一下。 image镜像 下载镜像docker pull : 查看所有镜像docker images 删除镜像docker rmi 上传镜像docker push /:,要先注册https://hub.docker.com/ 如果docker images出现REPOSITORY是的情况，可以运行docker image prune删除。 container 启动容器docker run -p xxxx:xxxx -v=hostPath:containerPath -d --name -p端口映射 -v数据卷，文件映射 -d后台运行 --name定义容器名称 查看所有容器docker ps，加-a显示隐藏的容器 停止容器docker stop 删除容器docker rm ，加-f是强制删除 查看容器信息，如IP地址docker inspect 查看容器日志docker logs 进入容器控制台docker exec -it /bin/sh 功能演示 以nginx为例 docker run -p 81:80 -d --name nginx1 nginx docker ps # 访问 localhost:81 ，并查看 log docker exec -it /bin/sh cd /usr/share/nginx/html echo hello docker world index.html exit # 重新访问 localhost:81 ，强制刷新 docker stop docker rm 单独演示一下-v数据卷。 # 1. 新建 /Users/wfp/html/index.html ，内容自定义即可 # 2. 运行 docker run -p 81:80 -v=/Users/wfp/html:/usr/share/nginx/html -d --name nginx1 nginx # 3. 访问 重新访问 localhost:81 ，看是否你创建的页面？ Dockerfile 一个简单的配置文件，描述如何构建一个新的image镜像 注意:必须是Dockerfile这个文件名，必须在项目的根目录 # node环境 FROM node:14 WORKDIR /app COPY . /app # 构建镜像时，一般用于做一些系统配置，安装必备的软件。可有多个 RUN RUN xxx RUN xxx RUN xxx # 启动容器时，只能有一个 CMD CMD xxx # 环境变量 ENV K1=v1 ENV K2=v2 构建 文件根目录执行 docker build -t . # 最后的 `.` 指 Dockerfile 在当前目录下。 docker images 代码演示 .dockerignore文件忽略 .git node_modules logs .docker-volumes Dockerfile文件 # Dockerfile FROM node:14 WORKDIR /app COPY . /app # 设置时区 RUN ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && echo 'Asia/Shanghai' >/etc/timezone # 安装 RUN npm set registry https://registry.npm.taobao.org RUN npm install RUN npm install pm2 -g # 启动 CMD echo $SERVER_NAME && echo $AUTHOR_NAME &&npm run server && npx pm2 log #一定要是阻塞控制台的程序 # 环境变量 ENV SERVER_NAME=\"tanchidemao\" ENV AUTHOR_NAME=\"roy\" 本地安装pm2 npm i pm2 --save-dev，或者Dockerfile中全局安装pm2 测试过程: docker build -t editor-server . # 构建 image docker images docker run -p 8081:3000 -d --name server1 editor-server # 创建容器，注意端口映射 docker ps docker logs # 需等待构建完成 # 访问 localhost:8081 ，查看 docker logs docker stop docker rm docker rmi Docker-compose 软件设计和开发，有单一职责原则。Docker也一样，每个容器都只负责一个服务。 如果开发环境需要多个服务(nodejs mysql mongodb redis),就需要启动多个Docker容器。 要连同这多个Docker容器，就需要Docker-compose。 配置文件 新建docker-compose.yml文件。先以redis为例，演示多个容器如何关联。 version: '3' services: editor-server: # service name build: context: . # 当前目录 dockerfile: Dockerfile # 基于 Dockerfile 构建 image: editor-server # 依赖于当前 Dockerfile 创建出来的镜像 container_name: editor-server ports: - 8081:3000 # 宿主机通过 8081 访问 editor-redis: # service name，重要！ image: redis # 引用官网 redis 镜像 container_name: editor-redis ports: # 宿主机，可以用 127.0.0.1:6378 即可连接容器中的数据库 `redis-cli -h 127.0.0.1 -p 6378` # 但是，其他 docker 容器不能，因为此时 127.0.0.1 是 docker 容器本身，而不是宿主机 - 6378:6379 environment: - TZ=Asia/Shanghai # 设置时区 命令 构建容器docker-compose build 启动所有服务器docker-compose up -d，后台启动 停止所有服务docker-compose down 查看服务docker-compose ps docker-compose build editor-server # 配置文件的 service name docker-compose up -d docker-compose ps # 访问 localhost:8081 ，查看 docker logs docker-compose down 链接Mysql和Mongodb 成功连接redis之后，要继续连接mysql和mongodb 区别 redis无数据看，而mysql和mongodb需要创建数据库 redis是缓存，无序数据持久化，而mysql和mongodb需要 代码修改 修改docker-compose.yml,代码如下 version: '3' services: editor-server: # service name build: context: . # 当前目录 dockerfile: Dockerfile # 基于 Dockerfile 构建 image: editor-server # 依赖于当前 Dockerfile 创建出来的镜像 container_name: editor-server ports: - 8081:3000 # 宿主机通过 8081 访问 editor-redis: # service name，重要！ image: redis # 引用官网 redis 镜像 container_name: editor-redis ports: # 宿主机，可以用 127.0.0.1:6378 即可连接容器中的数据库 `redis-cli -h 127.0.0.1 -p 6378` # 但是，其他 docker 容器不能，因为此时 127.0.0.1 是 docker 容器本身，而不是宿主机 - 6378:6379 environment: - TZ=Asia/Shanghai # 设置时区 editor-mysql: image: mysql # 引用官网 mysql 镜像 container_name: editor-mysql restart: always # 出错则重启 privileged: true # 高权限，执行下面的 mysql/init command: --default-authentication-plugin=mysql_native_password # 远程访问 ports: - 3305:3306 # 宿主机可以用 127.0.0.1:3305 即可连接容器中的数据库，和 redis 一样 volumes: - .docker-volumes/mysql/log:/var/log/mysql # 记录日志 - .docker-volumes/mysql/data:/var/lib/mysql # 数据持久化 - ./mysql/init:/docker-entrypoint-initdb.d/ # 初始化 sql environment: - MYSQL_DATABASE=imooc_lego_course # 初始化容器时创建数据库 - MYSQL_ROOT_PASSWORD=Mysql_2019 - TZ=Asia/Shanghai # 设置时区 editor-mongo: image: mongo # 引用官网 mongo 镜像 container_name: editor-mongo restart: always volumes: - '.docker-volumes/mongo/data:/data/db' # 数据持久化 environment: - MONGO_INITDB_DATABASE=imooc_lego_course - TZ=Asia/Shanghai # 设置时区 ports: - '27016:27017' # 宿主机可以用 127.0.0.1:27016 即可连接容器中的数据库 增加mysql/init/init.sql，初始化mysql -- docker-compose 启动 mysql 时的初始化代码 select \"init start...\"; -- 设置 root 用户可外网访问 use mysql; SET SQL_SAFE_UPDATES=0; -- 解除安全模式，测试环境，没关系 update user set host='%' where user='root'; flush privileges; ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'Mysql_2019'; -- 密码参考 docker-compose.yml flush privileges; select \"init end...\"; 修改config/envs/prd-dev.js，增加mysql和mongodb的配置 const devConf = require('./dev'); //修改redis连接配置 Object.assign(devConf.redisConf, { //和docker-compose中配置的service名字一致 //【注意】端口依然是6379，而不是6378，后者是宿主机的端口 host: 'editor-redis' }); //修改mongodb连接配置 Object.assign(devConf.mongodbConf,{ host: 'editor-mongo',//和docler-compose中配置的service名字一致 }); //修改mysql连接配置 Object.assign(devConf.mysqlConf,{ host: 'editor-mysql',//和docler-compose中配置的service名字一致 }); 修改.gitignore文件，增加一行.docker-volumes 演示 docker-compose build editor-server # 配置文件的 service name docker-compose up -d docker-compose ps # 访问 localhost:8081 ，查看 docker logs docker-compose down 配置测试机 创建work账号 处于安全考虑，日常不会用root账号登录，权限太高了。 用root登录，创建work账号 adduser work passwd work 添加work的sudo权限 whereis sudoers # 找到文件位置 /etc/sudoers chmod u+w /etc/sudoers # 修改权限， u 表示所有者， w 表示写权限 + 表示添加 vim /etc/sudoers # 编辑该文件 # 找到 `root ALL=(ALL) ALL` # 再加一行 `work ALL=(ALL) ALL` chmod u-w /etc/sudoers 然后使用work登录机器。输入su，在输入root账号的密码，即可拥有超级权限。 登录信任 使用work登录机器，创建~/.ssh/authorized_keys文件。 # 修改文件夹权限 chmod 700 ~/.ssh chmod 600 ~/.ssh/authorized_keys 将本机的id_rsa.pub内容粘贴进来。 退出重新用work登录，将不用在输入密码。 安装必备软件 以下都需要su权限 git yum -y install git git --version docker 安装docker docker镜像加速 安装docker-compose docker version docker-compose --version 开放端口 开放需要的端口，否则外网无法访问该端口 B端 FE - 80 B端 server - 8081 C端 - 8082 统计服务，收集日志 - 8083 统计服务 OpenAPI - 8080 admin FE - 8085 admin server - 8084 发布到测试机 梳理思路 使用github actions监听dev分支push 登录测试机，获取最新dev分支代码 重新构建镜像docker-compose build editor-server 重启所有容器docker-compose up -d 代码演示 新建deploy-dev.yml内容如下: name: deploy for dev on: push: branches: - 'dev' # 只针对 dev 分支 paths: - '.github/workflows/*' # - '__test__/**' # dev 不需要立即测试 - 'src/**' - 'Dockerfile' - 'docker-compose.yml' - 'bin/*' jobs: deploy-dev: runs-on: ubuntu-latest steps: - uses: actions/checkout@v2 - name: set ssh key # 临时设置 ssh key run: | mkdir -p ~/.ssh/ # secrets.WFP_ID_RSA github里面设置的 echo \"${{secrets.WFP_ID_RSA}}\" > ~/.ssh/id_rsa chmod 600 ~/.ssh/id_rsa ssh-keyscan \"182.92.xxx.xxx\" >> ~/.ssh/known_hosts - name: deploy # 部署 run: | ssh work@182.92.xxx.xxx \" # 【注意】用 work 账号登录，手动创建 /home/work/imooc-lego 目录 # 然后 git clone https://username:password@github.com/imooc-lego/biz-editor-server.git -b dev （私有仓库，使用 github 用户名和密码） # 记得删除 origin ，否则会暴露 github 密码 cd /home/work/imooc-lego/biz-editor-server; git remote add origin https://wangfupeng1988:${{secrets.WFP_PASSWORD}}@github.com/imooc-lego/biz-editor-server.git; git checkout dev; git pull origin dev; # 重新下载最新代码 git remote remove origin; # 删除 origin ，否则会暴露 github 密码 # 启动 docker docker-compose build editor-server; # 和 docker-compose.yml service 名字一致 docker-compose up -d; \" - name: delete ssh key # 删除 ssh key run: rm -rf ~/.ssh/id_rsa 远程接口测试 待测试机部署完成，即可进行远程接口测试npm run test:remote,即test.yml的内容 注意，一定要等待测试机部署完成，否则测试不通过 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Jayson71/":{"url":"pages/Jayson71/","title":"Jayson71","keywords":"","body":"Jayson71 - 笔记与作业 1.第一周作业：整体架构计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Jayson71/01-整体架构计文档.html":{"url":"pages/Jayson71/01-整体架构计文档.html","title":"整体架构计文档","keywords":"","body":"需求分析 用户类型 功能 图片创作者 注册，登陆，使用模板，保存，保存为模板，作品增删改，作品统计 管理员 用户增删改，作品增删改，作品统计，用户统计，流量统计，设置热门作品 运维人员 作品封禁，数据统计，作品管理，用户管理，模板管理 范围 整体设计，架构设计 模块设计 项目范围 项目 B端 前端、后端 C端 SSR 管理端 前端、后端 开发 组件库、组件生成平台、项目生成脚手架、项目发布脚手架 数据结构 1.作品vuex store 数据结构 1.1 state { work: { title: \"作品1\", settings: {}, props: {/*页面body的设置*/}, currentComponentId: \"xxx\", components: [ { id: \"xxx\", tag: \"text\", attrs: { value: \"123\", width: 12, height: 44, position: { x: 1, y: 1 } }, children: [ \"文本1\" ] }, { id: \"xxx\", tag: \"img\", attrs: { src: \"url\", width: 12, height: 44, position: { x: 1, y: 1 } }, children: null } ] } } 1.2 getter { layers:(state) => { state.work.components.map(item =>({ id: item.id, name: item.name })) } } 2.数据流转 扩展性保证 编辑器组件类型的扩展编辑器功能的扩展 开发提效 1.开发脚手架快速实现项目的创建与发布2.开发组件平台生成编辑器组件 运维保障 线上服务和运维服务安全监控和报警服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Joker_Yao/":{"url":"pages/Joker_Yao/","title":"Joker Yao","keywords":"","body":" 慕课网 Web 前端架构师课程学习笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Joker_Yao/01-需求分析和架构设计.html":{"url":"pages/Joker_Yao/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":" 课程标题名称——需求分析和架构设计：做什么，如何做？ 作业打卡 暂无内容 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Q小白/":{"url":"pages/Q小白/","title":"Q小白","keywords":"","body":"作业 第一周作业：技术方案设计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Q小白/01-第一周需求分析.html":{"url":"pages/Q小白/01-第一周需求分析.html","title":"第一周需求分析","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） https://www/yuque.com/imooc-lego/zlz87z 范围 使用角色分析 模版作品创建者 普通用户查看者 平台管理员 普通用户使用的看到的 H5 页面 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 H5 SSR渲染 模版作品创建者们使用的 B 端 使用者和用途：模版作品创建者可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 由 editor-fe(作品管理端) + editor-server(作品管理API服务) 构成。 平台管理员使用的管理系统（后台管理系统） 使用者和用途：慕课乐高平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计、分析、监控整个项目的线上运行状况。 由 admin-fe(慕课乐高管理运营平台) + admin-server(运营平台API服务) 构成。 模块设计 模块拆分和关系图 如下图所示（画的不好，还请老师指点） 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范(保持标准化格式，提升数据扩展性)。 用数组来组织数据，有序。 尽量使用引用关系，不要保存多份数据。 数据结构示例 { page: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本组件', data: { on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { }, attrs: { // 元素绑定的属性 title: '134' } }, contorl: { // 扩展 控制组件多种条件行为 isShow: true }, text: '文本1', tag: 'text', children: [ { id: '1-1', name: '图片组件', data: { attrs: { // 元素绑定的属性 href: '134.png' }, on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { } }, contorl: { isShow: true }, text: '图片1', tag: 'image', children: null } ] }, id: '2', name: '图片组件', data: { attrs: { // 元素绑定的属性 href: '222' }, on: { // 元素绑定的事件 click: function () {}, onMouseMove: function () {} }, style: { } }, contorl: { isShow: true }, text: '图片1', tag: 'image', children: null } ] } } 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 研发提效 脚手架：快速项目创建、项目快速便捷发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件,全平台输出 多处可用 运维保障 线上服务和运维服务: 接入成熟服务 阿里云 腾讯云 安全: 接入成熟服务 阿里云 腾讯云 监控和报警: 技术埋点和错误收集系统 对接邮件 做到线上问题 发送报警邮件 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Q小白/02-第二周笔记.html":{"url":"pages/Q小白/02-第二周笔记.html","title":"第二周笔记","keywords":"","body":"脚手架架构 光坚持这件事情就可以打败99%的人学习方法 架构三部曲: 掌握原理-> 独立思考 -> 总结反思 深度剖析优秀开源项目,由表及里，由浅入深 视角切换：多切换到架构师视角，从全局思考问题 注意事项 整体难度不高,坚持 优秀的程序员不仅仅能够实现功能，更能读懂别人的代码，读懂别人的想法 学会从优秀的开源项目吸取养分 什么是脚手架？ 脚手架实现原理 脚手架开发流程 站在前端研发的视角，分析开发脚手架的必要性 抽取重复部分 自动化 脚手架核心价值 将研发流程： 自动化：项目重复代码拷贝/git操作/发布流程上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化,数据化，使得研发过程可量化 和自动化构建工具的区别 问题：jenkins,travis等自动化工具已经比较成熟了，为什么还需要自研脚手架？ 不满足需求：jenkins,travis通常在githooks中触发，需要在服务器执行,无法覆盖研发人员本地的功能,如：创建项目自动化,本地git操作自动化等 定制复杂：jenkins,travis定制过程需要开发插件，其过程较为复杂，需要java语言,对前端同学不太友好。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/":{"url":"pages/Sunshine/","title":"Sunshine","keywords":"","body":"Sunshine - 课程学习 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/01-第一周笔记和作业.html":{"url":"pages/Sunshine/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） 背景链接 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 平台 使用者 开发方式 用途 H5(前台) 普通用户 前后端分离(editor-fe + editor-server) 对作品进行查看、分享 编辑器(中台) 作品创作者 SSR 可以自己创建或者根据模板生成作品，对作品进行创建、分布、管理 管理系统(后台) 管理员 前后端分离(admin-fe + admin-server) 可以对作品进行管理，包括用户管理、模板管理、模板使用统计、作品上下线、作品审核等 模块设计 如下图所示 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据关系流转 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件（丰富组件功能，比如加入一些动画组件） 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/02-第二周作业和笔记.html":{"url":"pages/Sunshine/02-第二周作业和笔记.html","title":"第二周作业和笔记","keywords":"","body":"脚手架架构设计和框架搭建 脚手架的作用 开发脚手架的核心目标是：提升前端研发效能 脚手架的核心价值 自动化：项目重复代码拷贝/git 操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 和自动化构建工具的区别 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动挡化、本地 git 操作自动化等 定制负责：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语音，对前端开发不够友好 入门 脚手架本质上来说，是一个操作系统的客户端。它通过命令行执行： vue create vue-test-app 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置 去在全局的bin目录下(/usr/local/bin)，创建一个软连接，链接到全局的node_modules目录下 @vue对应的执行文件(../lib/node_modules/@vue/cli/bin/vue.js), 软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value，value 指向的文件中需要设置 #! /usr/bin/env node 来标识文件需要用node来执行 基于 lerna 搭建自己的脚手架并且发布到 npm 安装方法 npm install -g @sunshine-cli/core 执行命令 sunshine-cli 进阶 理解 yargs 常用 API 和 开发流程 #!/usr/bin/env node const yargs = require('yargs/yargs') const dedent = require('dedent') const log = require(\"npmlog\") const { hideBin } = require('yargs/helpers') const pkg = require(\"../package.json\"); const context = { lernaVersion: pkg.version, }; const argv = process.argv.slice(2) const listCommand = { command: 'list', describe: 'list local packsges', aliases: [\"ls\", \"la\", \"ll\"], builder: yargs => { return yargs }, handler: argv => { console.log(argv) } } const cli = yargs() yargs() .usage(\"Usage: $0 [options]\") // 配置脚手架的用法 .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") // 配置最少需要参数的个数 .recommendCommands() // 当输入的命令不对时，会根据算法去匹配最接近的正确命令的提示 .strict() // 无法识别的信息错误提示 .command(listCommand) // 向脚手架注入命令 .options({ init: { describe: 'init scaffold', type: 'string', alias: 'i' } }) .fail((msg, err) => { // certain yargs validations throw strings :P const actual = err || new Error(msg); // ValidationErrors are already logged, as are package errors if (actual.name !== \"ValidationError\" && !actual.pkg) { // the recommendCommands() message is too terse if (/Did you mean/.test(actual.message)) { console.log(cli.parsed, 'argv') log.error(\"lerna\", `Unknown command `); } log.error(\"lerna\", actual.message); } // exit non-zero so the CLI can be usefully chained cli.exit(actual.code > 0 ? actual.code : 1, actual); }) .group(['help', 'version'], \"Global Options:\") .alias(\"h\", \"help\") .alias(\"v\", \"version\") .wrap(cli.terminalWidth()).epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `) .parse(argv, context) 理解 lerna 实现原理 lerna 是基于git和npm的包管理工具 实现原理 通过import-local判断当前工程中是否存在lerna包，有的话优先调用当前目录下的 通过yargs生成脚手架，主要包括globalOptions的创建、command注入、参数解析等等；command最主要的两个回调是builder和handler方法 ，分别的作用是builder用于构架命令是可以执行的参数、改命令用法的例子等，handler用于实现该命令的功能，比较重要 lerna在本地开发时可以配置本地依赖，而不需要npm link的方式只需要在package.json中配置\"@lerna/add\": \"file:../../commands/add\", 即可，在代码发布时(lerna publish)会自动替换该路径 import-local 实现原理，理解 require.resolve 实现原理 import-local主要作用是查找本地项目中是否存在该package,有的话会优先用本地的，这样的好处是可以解除全局和本地版本冲突的问题 实现原理 重要实现 fs.realPathSync该方法当找到路劲中存在软连接时，会重头开发在查找一遍，这样做的目的是为了防止软连接中还有软连接 遍历过程中生成的子路径会缓存到knownHard和cache中，这样的好处是提高查询效率； 遍历完成后得到的真实路径也会添加到缓存中，key为原始路径origin,下次就可以直接从缓存中拿到结果 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/03-第五周笔记和作业.html":{"url":"pages/Sunshine/03-第五周笔记和作业.html","title":"第五周笔记和作业","keywords":"","body":"实现自己的readline功能 function readline(callback) { function onkeypress(s) { output.write(s) line += s; switch (s) { case '\\r': input.pause(); callback(line) break; } } const input = process.stdin; const output = process.stdout; let line = '' emitKeypressEvents(input); input.on('keypress', onkeypress); input.setRawMode(true); input.resume(); } function emitKeypressEvents(stream) { function onData(s) { keys.next(s.toString()) } const keys = emitKeys(stream) keys.next(); stream.on('data', onData) } function* emitKeys(stream) { while (true) { let ch = yield; let s = ch; stream.emit('keypress', s) } } readline(function (answer) { console.log('answer:', answer) }) readline 源码分析 初始化流程 通过createInterface方法初始化命令行输入，该方法返回Interface方法，这个方法首先强制将函数转化为构造函数； 为构造函数添加事件行为，通过 EventEmitter.call(this); 参数处理，对于用户输入的参数进行处理； 获取监听键盘事件的能力，入口为emitKeypressEvents(input, this); 从emitKeypressEvents 中通过generator函数(emitKeys(stream))获取到键盘的输入信息，并对结果做了判断处理后，提交键盘输入事件 stream.emit('keypress', escaped ? undefined : s, key); 完成一系列事件监听包括命令行输入事件```if (stream.listenerCount('keypress') > 0) { stream.on('data', onData); } else { stream.on('newListener', onNewListener); }``` 键盘事件监听input.on('keypress', onkeypress);，在键盘监听事件中，如果有newListener事件，会触发该事件执行该事件的回调来初始化命令行输入事件，代码如下if (event === 'keypress') { stream.on('data', onData); stream.removeListener('newListener', onNewListener); } 设置命令行监测逐字输入：this._setRawMode(true); 执行流程 当用户输入字符时，命令行监听事件先执行回调函数onData,主要是为了触发emitKeys函数，通过代码stream[ESCAPE_DECODER].next(r[i]); 然后执行emitKeys函数对字符进行判断后触发keypress函数stream.emit('keypress', s, key);，最后执行keypress函数的回调函数 function onkeypress(s, key) { self._ttyWrite(s, key); if (key && key.sequence) { // If the key.sequence is half of a surrogate pair // (>= 0xd800 and = 0xd800 && ch 判断时候结束，结束后执行相关的后续结束处理 手写命令行交互列表，类似于inqurer ```javascript const EventEmitter = require('events'); // 事件库 const MuteStream = require('mute-stream'); // 包装输入输出流 const readline = require('readline'); // 命令行输入监听 const { fromEvent } = require('rxjs'); const ansiEscapes = require('ansi-escapes'); // 清屏 const option = { type: 'list', name: 'name', message: 'select name:', choices: [ { name: 'sunshine', value: 'sunshine' }, { name: 'curry', value: 'curry' }, { name: 'james', value: 'james' } ] } function prompt(option) { return new Promise((resolve, reject) => { try { const list = new List(option); list.render() list.on('exit', function (answers) { resolve(answers) }) } catch (e) { reject(e) } }) } class List extends EventEmitter { constructor(option) { super(); this.name = option.name; this.message = option.message; this.choices = option.choices; this.input = process.stdin; const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; this.selected = 0; // 默认选择list的第一位 this.height = this.choices.length + 1; // 命令行的默认高度，为了清空命令行用的 this.readline = readline.createInterface({ input: this.input, output: this.output }); this.keypress = fromEvent(this.readline.input, 'keypress').forEach(this.onKeypress); this.hasSelected = false } render() { this.output.unmute(); this.clear(); this.output.write(this.getContext()); this.output.mute(); } // 监听键盘输入事件 onKeypress = (res) => { const key = res[1]; if (key.name === 'up') { this.selected--; if (this.selected { if (index === this.selected) { title += '\\x1B[36m❯ ' + choice.name + '\\x1B[39m ' title += index === this.choices.length - 1 ? '' : '\\n' } else { title += ` ${choice.name} `; title += index === this.choices.length - 1 ? '' : '\\n' } }) return title } else { const name = this.choices[this.selected].name; let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; return title } } // 清空命令行 clear() { const lines = ansiEscapes.eraseLines(this.height); this.output.write(lines) } // 关闭命令行交互、退出程序 close() { this.output.unmute(); this.readline.output.end(); // 输出流结束 this.readline.pause(); // readline 停止监听 this.readline.close(); // readline 关闭 } } prompt(option).then(answer => { console.log('answers:',answer) }) ``` Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/04-第六周ejs源码分析.html":{"url":"pages/Sunshine/04-第六周ejs源码分析.html","title":"第六周Ejs源码分析","keywords":"","body":"ejs源码分析 ejs是高效的嵌入式 JavaScript 模板引擎，可以在运行时将模板字符串替换成用户传入的值;以代码let template = ejs.compile(str, options); template(data);为例，分析整个ejs源码执行流程；参数解析：str：传入的模板字符串；options： 参数对象，主要包括如下参数： cache 缓存编译后的函数，需要指定 filename filename 被 cache 参数用做键值，同时也用于 include 语句 context 函数执行时的上下文环境 compileDebug 当值为 false 时不编译调试语句 client 返回独立的编译后的函数 delimiter 放在角括号中的字符，用于标记标签的开与闭 debug 将生成的函数体输出 _with 是否使用 with() {} 结构。如果值为 false，所有局部数据将存储在 locals 对象上。 localsName 如果不使用 with ，localsName 将作为存储局部变量的对象的名称。默认名称是 locals rmWhitespace 删除所有可安全删除的空白字符，包括开始与结尾处的空格。对于所有标签来说，它提供了一个更安全版本的 -%> 标签（在一行的中间并不会剔除标签后面的换行符)。 escape 为 outputFunctionName 设置为代表函数名的字符串（例如 'echo' 或 'print'）时，将输出脚本标签之间应该输出的内容。 async 当值为 true 时，EJS 将使用异步函数进行渲染。（依赖于 JS 运行环境对 async/await 是否支持）data: 传入的真实数据，替换模板字符串中的占位内容； 源码执行流程 templ = new Template(template, opts); 生成一个Template对象，在这个过程中主要执行如下操作： 对传入的options进行处理，比如delimiter 是否是用户自定义的还是默认的； 生成一个正则表达式，主要是用作在编译时对模板字符串进行解析；默认情况下返回值是：/(||-%>|_%>)/ 对生成的Template对象templ进行编译并将结果返回：templ.compile(),执行如下操作： 执行this.generateSource()函数，核心是为了解析模板字符串this.parseTemplateText()；该方法的核心是用之前生成的正则表达式循环调用exec方法去得到一个数组返回 ```javascript var result = pat.exec(str); var arr = []; var firstPos; while (result) { firstPos = result.index; if (firstPos !== 0) { arr.push(str.substring(0, firstPos)); str = str.slice(firstPos); } arr.push(result[0]); str = str.slice(result[0].length); result = pat.exec(str); } if (str) { arr.push(str); } return arr 比如将模板字符串`` 转为数组`[‌,,,,]` > + 执行`self.scanLine(line);`将数组中的每个元素传入。经过一系列的规则匹配后，生成字符串；再根据条件加上一些prepend字符串后生成一个函数字符串如下： ```var __output = \"\"; function __append(s) { if (s !== undefined && s !== null) __output += s } with (locals || {}) { ; ; ; __append(\"\") ; __append(escapeFn( user.name )) ; __append(\"\") } return __output; 最后用Function函数将字符串变为可执行的函数fn = new Function(opts.localsName + ', escapeFn, include, rethrow', src);返回 最后执行该函数template(data)，传入data数据就可以得到结果sunshine Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Sunshine/04-第六周require源码分析.html":{"url":"pages/Sunshine/04-第六周require源码分析.html","title":"第六周Require源码分析","keywords":"","body":"require源码分析 require语句用来加载模块，返回该模块的exports对象，执行逻辑大致如下： 首先查询缓存中是否存在该文件，如果有的话直接返回 如果该文件是内部模块，查到后就直接返回； 如果是node_modules模块，根据所在的父模块，确定该文件可能的安装目录。依次在每个目录中，查找该文件，找到后就直接返回； 如果是本地文件，确定文件的决定路径，找到文件后返回; 支持加载的文件类型： .js类型 .json类型 .node类型 .mjs类型(node 15以下的版本不支持会直接抛出异常) 其他文件类型(会统一转化为js类型) 源码执行流程 入口文件：mod.require(path);，调用module对象的require方法; 调用Module._load(id, this, /* isMain */ false); 来对模块进行解析，第三个参数是判断是否为主文件 3.const filename = relativeResolveCache[relResolveCacheIdentifier]; if (filename !== undefined) { const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) { updateChildren(parent, cachedModule, true); return cachedModule.exports; } delete relativeResolveCache[relResolveCacheIdentifier]; } 判断该文件是否在缓存中，如果有的话直接返回module.exports对象.4. 寻找文件的真实路径：const filename = Module._resolveFilename(request, parent, isMain);,关键步骤如下: 根据当前路径，查询所有可能的路径 paths = Module._resolveLookupPaths(request, parent); 如果该文件是node_modules 中的文件，会返回所有可能的路径:[‌/Users/niechengyang/Desktop/ejs_test/node_modules,/Users/niechengyang/Desktop/node_modules,/Users/niechengyang/node_modules,/Users/node_modules,/node_modules,/Users/niechengyang/.node_modules,/Users/niechengyang/.node_libraries,/usr/local/lib/node]， 如果是本地文件，会返回父模块所有的目录parentDir = [path.dirname(parent.filename)]比如：['/Users/niechengyang/Desktop/ejs_test'] 根据所有可能的路径去查找真实路径const filename = Module._findPath(request, paths, isMain, false);找到后返回文件真实路径 /Users/niechengyang/Desktop/ejs_test/node_modules/ejs/lib/ejs.js，并将该路径缓存起来； .5. 判断该模块是否为内置模块，如果是的话直接返回const mod = loadNativeModule(filename, request, experimentalModules);如果不是的话 生成一个新的Module对象来存储该文件const module = new Module(filename, parent),并将该模块缓存下来Module._cache[filename] = module;， module对象属性如下： id：源码文件路径，如：/Users/sam/Desktop/vue-test/imooc-test/bin/ejs/index.js path：源码文件对应的文件夹，通过path.dirname(id) 生成 exports：模块输出的内容，默认为 {} parent：父模块信息 filename：源码文件路径 loaded：是否已经加载完毕 children：子模块对象集合 paths：模块查询范围 .6. 加载模块module.load(filename);，详细过程如下： 获取到文件的后缀名const extension = findLongestRegisteredExtension(filename); 获取到执行该后缀名文件对应的函数Module._extensions[extension](this, filename); Module._extensions['.js'] = function(module, filename) { if (filename.endsWith('.js')) { const pkg = readPackageScope(filename); // Function require shouldn't be used in ES modules. if (pkg && pkg.data && pkg.data.type === 'module') { const parentPath = module.parent && module.parent.filename; const packageJsonPath = path.resolve(pkg.path, 'package.json'); throw new ERR_REQUIRE_ESM(filename, parentPath, packageJsonPath); } } const content = fs.readFileSync(filename, 'utf8'); module._compile(content, filename); 读取文件后，对文件进行编译module._compile(content, filename);将模板代码生成可执行的函数const compiledWrapper = wrapSafe(filename, content, this); 并且生成执行函数所需要的参数，包括 exports, require, module, filename, dirname 将生成的函数执行起来result = compiledWrapper.call(thisValue, exports, require, module, filename, dirname); 返回module.exports Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Wu/":{"url":"pages/Wu/","title":"Wu","keywords":"","body":"Wu - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Wu/01-技术方案设计文档.html":{"url":"pages/Wu/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":" 需求背景 B端需求 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf/selz6t 编辑器需求 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf/wsaqd4 业务组件需求 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf/whhax9 管理后台需求 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf/mf2k5u UI设计图 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf/mbxh1z 模块设计 核心数据结构 vuex store ​ ps:每个组件尽量符合vnode规范 { // 当前作品-也就是主要展示的H5 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } Vuex getter { layers() => { sotre.work.components.map( c => { return { id:c.id, name:c.name } }) } } 扩展性保证 组件扩展 编辑器的图层，复制，添加自定义图片等功能扩展 扩展页面信息，比如多语言 扩展其他功能，比如图形图表等大数组展示 提升开发效率，测试效率 前端脚手架的搭建，比如webpack 测试框架的使用，比如jest 公共组件平台的搭建 以往ui设计的统一规范或者选定成熟的ui框架，避免重复造轮子 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 （备注：虽然写完了技术文档，但是基本还是跟着老师的思路走，运维保障部分也基本空白，提醒自己学完课程要回来重写技术文档） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/Wu/02-xx.html":{"url":"pages/Wu/02-xx.html","title":"Xx","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/apple/":{"url":"pages/apple/","title":"Apple","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/apple/01-week1.html":{"url":"pages/apple/01-week1.html","title":"Week1","keywords":"","body":" Q&A 1、fork 源码执行npm run dev报错 原因：当前node版本是最新版解决： nodejs版本降级到12版本以下 nvm install 12.15.0 nvm use 12.15.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/apple/02-week2-脚手架.html":{"url":"pages/apple/02-week2-脚手架.html","title":"Week2 脚手架","keywords":"","body":" 脚手架 脚手架核心价值 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，研发过程可量化 组成 脚手架本质是一个操作系统的客户端 主命令：vue command：create command的param：vue-test-app vue create vue-test-app // 强制覆盖某个已存在的文件夹 vue create vue-test-app --force // 发布npm包 npm login npm publish 脚手架本地link标准流程 链接本地脚手架 cd your-cli-dir npm link 链接本地库文件 cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件 cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib Q&A windows一些常用命令 # windows里cmd查看所有文件及目录命令 dir # 返回上一级目录 cd .. # 删除某个文件夹 # 如node_modules文件夹 rmdir /s/q node_modules 关于markdown vscode编写markdown使用到的插件 Markdown All in One Markdown Preview Enhanced markdownlint Markdown Preview Mermaid Support Markdown Preview Github Styling chrome浏览器如何预览markdown文档 chrome浏览器的网址栏输入chrome://extensions/ 应用商店安装Markdown Viewer 查看已经下载的扩展程序，然后找到Markdown Viewer 点击详细信息，将允许访问文件网址勾选。 感想 脚手架进大厂必备然鹅我不会，然鹅我不想进大厂 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/apple/03-week2-lerna.html":{"url":"pages/apple/03-week2-lerna.html","title":"Week2 Lerna","keywords":"","body":" Lerna 简介 Lerna是一个优化基于git+npm的多package项目的项目管理工具 多package管理：减少重复操作 版本一致性：操作标准化 架构优化的产物——项目复杂度提升后，架构优化的主要 目标是效能为核心的。 lerna开发脚手架流程 练级[https://github.com/lerna/lerna] Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/":{"url":"pages/clqyfe/","title":"Clqyfe","keywords":"","body":"灿烂千阳FE - 课程打卡作业笔记 Week01 需求分析和整体架构设计 Week01-作业-整体架构设计 V1.0 Week02 脚手架架构设计和框架搭建 理解脚手架 基于原生开发脚手架 基于lerna开发脚手架 yargs使用 lerna源码分析 Week03 脚手架核心流程开发 Week03-作业 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/01-Week01-作业.html":{"url":"pages/clqyfe/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 需求 需求文档 慕课乐高体验地址 模块设计 模块拆分: B端和编辑器（前端，后端） H5（ssr） 管理后台（前端，后端） 第三方组件库：为了保证 编辑器和 h5 组件渲染的一致性 自研统计模块：为了满足项目个性化的统计需求 模块的关系图，关键功能及职责： 作品的数据结构 核心数据结构： 组件数据结构尽量复合 VNode 规范 用数组来组织数据，有序 尽量使用引用关系，避免冗余 { // 作品 work: { title: '作品标题', setting: { /* 拓展配置： 如配置渠道 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图： B端将创建好的作品存入数据库；C端从数据库中读取创建的作品，渲染页面；管理后台可以管控作品的显示。 扩展性保证 数据结构层面 页面级别的配置参数，如全局样式配置 项目级别的配置参数，如提供分渠道统计的参数配置项 编辑器层面 组件的扩展性，如组件隐藏，锁定及图层操作 开发提效 脚手架 提供模板创建 CI/CD 组件平台 组件库的创建，发布和预览 运维保障（待补充） 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/02-Week02-理解脚手架.html":{"url":"pages/clqyfe/02-Week02-理解脚手架.html","title":"Week02 理解脚手架","keywords":"","body":"理解脚手架 什么是脚手架？ 脚手架本质是一个操作系统的客户端，它通过执行命令来实现相应的功能。比如：vue create vue-test，表示创建一个名为 vue-test 的 vue 项目。 脚手架的必要性 开发脚手架的核心目标是：提升前端研发效率。 脚手架的核心价值是可以将研发过程自动化、标准化、数据化。 自动化：项目重复代码拷贝、git 操作、发布上线操作。 标准化：项目创建、git flow、发布流程、回滚流程。 数据化：研发过程系统化、数据化、使得研发过程可量化。 和自动化工具的区别 问题：jenkins、travis等自动化构建工具已经比较成熟了，为什么还要自研脚手架？ 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能。如：创建项目自动化，本地 git 操作自动化等。 定制复杂：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语言，对前端同学不够友好。 脚手架执行命令解析 例如： vue create vue-test 上面这条命令由 3 个部分组成： 主命令: vue command: create command 的 param: vue-test 这条命令表示创建一个 vue 项目，项目的名字叫 vue-test。 以上是最一个较为简单的脚手架命令，但实际场景往往更加复杂，比如： vue create vue-test-app --force -r https://registry.npm.taobao.org 这里的 --force，-r 都叫做 option，只不过 -r 使用的是简写形式，可以替换成 --registry。 -r https://registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param，其实 --force 可以理解为：--force true，简写为：--force。 脚手架的执行原理 执行原理如下： 在终端执行命令 vue create vue-test 终端解析 vue 命令 终端在环境变量中查找 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端使用 node 执行 vue.js 文件 vue.js 解析 command 、options vue.js 执行 command 执行完成，退出执行 脚手架实现原理 实现原理 如果你能回答以下三个问题，就掌握了脚手架实现原理。 为什么全局安装的 @vue/cli 后会添加的命令为 vue？ 全局安装 @vue/cli 时发生了什么？ 执行 vue 命令时发生了什么？为什么 vue 指向了一个 js 文件，却可以通过 vue 命令去执行它？ 问题 1： 在 @vue/cli 的 npm 包的 package.json 中设置了 bin 属性 { ... \"bin\": { \"vue\": \"bin/vue.js\" }, ... } 该属性决定了安装包后添加的命令为 vue。 问题 2： npm 会将 @vue/cli 下载到 /usr/local/lib/node_modules（全局安装的 node） 目录下 下载完成后会解析 package.json 文件 根据 package.json 中的 bin 属性，在 node 的执行目录 /usr/local/bin 下创建名为 vue 的软链接，并将 vue 链接到 bin 属性中配置的文件 bin/vue.js 问题 3： 执行 vue 命令时发生了什么？ 在环境变量中查找 vue 不存在：提示命令不存在 存在：根据 vue 命令找到实际文件 vue.js 并执行该文件 为什么 vue 指向了一个 js 文件，却可以通过 vue 命令去执行它？ 在 vue.js 文件最顶部声明了使用环境变量中的 node 来执行此文件 #!/usr/bin/env node ... 思考：以下两种方式有啥区别？ #!/usr/bin/env node #!/usr/bin/node 第二种是 node 的实际安装目录，只不过别人安装这个包时，如果 node 的目录不一致就无法运行了。 原理进阶 为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？ 如何为 node 脚手架命令创建别名？ 问题 1： 执行脚手架的时候，其实是作为操作系统上的一个可执行文件来进行执行，所以可以理解脚手架就是操作系统的一个客户端。但是这个客户端本质上并不是我们编写的文件，因为执行脚手架需要借助 node 来执行，node 才是系统的客户端，而我们编写的脚手架文件仅仅只是 node 一个参数。 脚手架和 PC 上安装的软件本质上没什么区别，只是安装的软件存在 GUI 而已，我们也可以通过 node 来调取系统的 GUI 绘制 API 来绘制窗口。 问题 2： 比如：给 vue 设置别名。 vue 在系统中的软链接如下 ll /usr/local/bin/vue # lrwxr-xr-x 1 zhoujiawei wheel 39B 12 26 14:35 /usr/local/bin/vue -> ../lib/node_modules/@vue/cli/bin/vue.js 配置别名为 vue2 cd /usr/local/bin/ ln -s ./vue vue2 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/03-Week02-基于原生开发脚手架.html":{"url":"pages/clqyfe/03-Week02-基于原生开发脚手架.html","title":"Week02 基于原生开发脚手架","keywords":"","body":"基于原生开发脚手架 脚手架开发流程 创建 npm 项目 创建脚手架入口文件，最上方添加：#!/usr/bin/env node 配置 package.json，添加 bin 属性，设置脚手架命令执行该入口文件 编写脚手架代码 将脚手架发布到 npm 注意：如果执行 npm i 命令所在的目录是脚手架的父级目录，安装后 lib/node_modules 中的包会指向本地的脚手架。也就是说本地更改代码后，指向命令其结果也会改变，方便本地调试。如果不想这样，执行安装命令时请更改目录。 脚手架的本地调试方法 除了上述方法，还可以使用 npm link 的方式进行本地 npm 包开发。 进入本地 npm 包所在目录，运行命令 npm link，就会在 /usr/local/lib/node_modules 目录下加入本地包，并且在 /usr/local/bin 目录中创建软链接。 cd zjw-test npm link ll /usr/local/bin/zjw-test # lrwxr-xr-x 1 zhoujiawei wheel 41B 12 26 19:15 /usr/local/bin/zjw-test -> ../lib/node_modules/zjw-test/bin/index.js ll /usr/local/lib/node_modules # lrwxr-xr-x 1 zhoujiawei wheel 44B 12 27 00:20 zjw-test -> /Users/zhoujiawei/Desktop/脚手架/zjw-test 如果本地 npm 包开发过程中还依赖本地另外一个 npm 包，又该怎么处理呢？ 假设两个包为： zjw-test、zjw-test-lib，zjw-test 依赖 zjw-test-lib。 进入 zjw-test 目录，执行 npm link 进入 zjw-test-lib 目录，执行 npm link 此时，两个包都别加入到 lib/node_modules 中了，再在 zjw-test 中执行 npm link zjw-test-lib，相当于安装了依赖包 zjw-test-lib 在 package.json 中，更改版本号，删除 node_modules，执行 npm i，重新安装依赖包。 cd zjw-test-lib && npm link cd zjw-test && npm link && npm link zjw-test-lib && rm -rf node_modules && npm i 如果先在 zjw-test-lib 中执行 npm unlink，再在 zjw-test 执行 npm unlink zjw-test-lib 会报文件不存在的错误。 当 zjw-test-lib 开发完成后需要发布，操作如下： 进入 zjw-test 目录，执行 npm unlink zjw-test-lib 进入 zjw-test-lib 目录，执行 npm unlink，修改 version，执行 npm publish 进入 zjw-test 目录，执行 rm -rf node_module，重新安装依赖，执行 npm publish 发布成功后重新安装全局 zjw-test 总结 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件： cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件： cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解 npm link： npm link：将当前项目链接到 node 全局 node_modules 中作为一个库文件，并解析 bin 配置创建可执行文件 npm link your-lib：将当前项目中 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件 理解 npm unlink： npm unlink：将当前项目从 node 全局 node_modules 中移除 npm unlink your-lib：将当前项目中的库文件依赖移除 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/04-Week02-基于lerna开发脚手架.html":{"url":"pages/clqyfe/04-Week02-基于lerna开发脚手架.html","title":"Week02 基于Lerna开发脚手架","keywords":"","body":"基于lerna开发脚手架 脚手架开发难点 分包：将复杂的系统拆分成若干个模块 命令注册（vue create、vue add、vue invoke） 参数解析： options全称：--version、--help options简写：-V、-h 带 params 的 options：--path /User/zjw/Desktop/vue-test 示例： vue command [options] 帮助文档： global help Usage Options Commands 示例：vue 的帮助信息： Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. command help Usage Options vue create 的帮助信息： Usage: create [options] create a new project powered by vue-cli-service Options: -p, --preset Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset Skip prompts and use inline JSON string as preset -m, --packageManager Use specified npm client when installing dependencies -r, --registry Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists --merge Merge target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions --skipGetStarted Skip displaying \"Get started\" instructions -h, --help output usage information 还有很多，比如： 命令行交互 日志打印 命令行文字变色 网络通信：HTTP/WebSocket 文件处理 等等...... lerna 介绍 原生脚手架开发痛点分析： 痛点一：重复操作 多Package本地link 多Package依赖安装 多Package单元测试 多Package代码提交 多Package代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互依赖版本升级 package越多，管理复杂度越高 lerna 简介: lerna 是一个优化基于git+npm的多package项目的管理工具。 使用 lerna 开发脚手架优势： 大幅减少重复操作 提升操作的标准化 lerna 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 lerna官网 lerna 开发脚手架流程（重点） 基于 lerna 开发脚手架： 安装 lerna npm install -g lerna 创建项目 git init zjw-cli-dev && zjw-cli-dev 初始化 Lerna 项目 lerna init 创建 Package lerna create core 安装依赖 # 安装到所有 package 的 dependencies lerna add mocha # 安装到所有 package 的 devDependencies lerna add mocha --dev # 安装到某个 package 的 devDependencies 下，如果之前已经安装过了，请先把 package.json 中的依赖删除 lerna add mocha package/core --dev 删除依赖 lerna clean 重新安装依赖 lerna bootstrap 执行单元测试 # test 命令是在 package.json 配置的 script 命令 lerna run test 执行特定包的单元测试 # 安装依赖提供的时文件夹名称，而执行命令使用包名称 lerna run --scope @zjw-cli-dev/core test link 项目 lerna link 发布项目 lerna publish 使用细节： lerna init 会自动完成 git 初始化，但不会创建 .gitignore，这个必须要手动添加，否则会将 node_modules 目录都上传到 git，如果 node_modules 已经加入 git stage，可使用： git reset HEAD 执行 unstage 操作，如果文件已经被 git 监听到变更，可使用： git checkout -- 将变更作废，记得在执行操作之前将文件加入 .gitignore # gitignore .vscode .idea .DS_Store node_modules packages/**/node_modules lerna-debug.log lerna create 在创建 package 时，为了防止重名在输入 package name 时一般都是创建在某个组织内，如：@zjw-cli-dev/core。在 @ 和 /之间就是组织名称。 声明在组织内的 package 需要 npm 上创建对应的 组织，否则发布不了。(Add Organization ---> 输入名称，点击 create ---> 点击 skip) // package.json { ... \"name\": \"@zjw-cli-dev/core\", ... } lerna add 第一个参数：添加 npm 包名 第二个参数：本地 package 的路径 选项：--dev：将依赖安装到 devDependencies，不加时安装到 dependencies lerna add [loc] --dev lerna link 如果未发布上线，需要手动将依赖添加到 package.json 再执行 lerna link // 如：在 @zjw-cli-dev/core 的 package.json 中 dependencies 添加 @zjw-cli-dev/utils 依赖 { ... dependencies: { \"@zjw-cli-dev/utils\": \"^1.0.0\" } ... } lerna clean 只会删除 node_modules，不会删除 package.json 中的依赖 lerna exec 和 lerna run --scope 属性后添加的是包名，而不是 package 的路径，这点和 lerna add 用法不同 lerna publish 发布时会自动执行：git add package-lock.json，所以 package-lock.json 不要加入 .gitignore 先创建远程仓库，并且同步一次 master 分支 执行 lerna publish 前先完成 npm login 如果发布的 npm 包名为：@xxx/yyy 的格式，需要先在 npm 注册名为：xxx 的 organization，否则可能会提交不成功 发布到 npm organization(group) 时默认为 private，所以我们需要手动在 package.json 中添加如下配置： \"publishConfig\": { \"access\": \"public\" } lerna 是如何引用本地 lib 库的？ package.json 中引用本地依赖 \"dependencies\": { \"lerna\": \"file:core/lerna\" } 官方文档 lerna publish 发布时会将 file: 进行替换 resolveLocalDependencyLinks() { // resolve relative file: links to their actual version range const updatesWithLocalLinks = this.updates.filter(node => Array.from(node.localDependencies.values()).some(resolved => resolved.type === \"directory\") ); return pMap(updatesWithLocalLinks, node => { for (const [depName, resolved] of node.localDependencies) { // regardless of where the version comes from, we can't publish \"file:../sibling-pkg\" specs const depVersion = this.updatesVersions.get(depName) || this.packageGraph.get(depName).pkg.version; // it no longer matters if we mutate the shared Package instance node.pkg.updateLocalDependency(resolved, depVersion, this.savePrefix); } // writing changes to disk handled in serializeChanges() }); } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/05-Week02-yargs使用.html":{"url":"pages/clqyfe/05-Week02-yargs使用.html","title":"Week02 Yargs使用","keywords":"","body":"yargs 使用 #!/usr/bin/env node const dedent = require('dedent'); const yargs = require('yargs/yargs'); const { hideBin } = require('yargs/helpers'); const pkg = require('../package.json'); const context = { cliVersion: pkg.version } // console.log(hideBin(process.argv)) // [ '--help', '*', ... ] // const argv = yargs(hideBin(process.argv)).argv; const cli = yargs(hideBin(process.argv)) cli // 使用提示, $0: argv 中 $0，即脚手架软链接名称 zjw-cli-test .usage('Usage: $0 [options]') // 输入不存在命令会给报误 .strict() // 最少需要一个 command .demandCommand(1, 'A command is required. Pass --help to see all available commands and options.') // 当输入一个不存在的命令时会给出最接近的命令 .recommendCommands() // 发生错误时执行的方法，不写 fail，输入错误指令会给出 --help 结果 .fail((msg, err) => { console.log('msg: ', msg) }) // 设置 help 别名为 h .alias('h', 'help') .alias('v', 'version') // 将容器宽度设置为终端的宽度 .wrap(cli.terminalWidth()) // 在最后面输出的信息 .epilogue(dedent` Your own log `) // 可配置 1 个以上的 option .options({ 'debug': { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) // 配置单个 option .option('registry', { type: 'string', describe: 'Define global registry: npm, yarn', alias: 'r' }) // 将 option 分组 .group(['debug'], 'Debug Options:') .group(['r'], 'Repository Options:') // 注册命令 .command( 'init [name]', 'do init project', // builder: 配置该命令专属 option yargs => { yargs.option('name', { type: 'string', describe: 'Name of project', alias: 'n' }) }, // handler: 处理命令的业务逻辑 argv => { console.log(argv) } ) // 注册命令的第二种方式 .command({ command: 'list', aliases: ['ll', 'la', 'ls'], describe: \"List local packages\", builder: yargs => {}, handler: argv => { console.log(argv) } }) // 解析参数 .argv // 处理使用 .argv 的方式来完成参数解析外，还可以调用 yargs.parse 来完成命令行参数解析 // .parse(argv, context) // hideBin(process.argv) 等价于 process.argv.slice(2)。parse 会将两个对象合并成一个新的对象作为命令行参数。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/06-Week02-lerna源码分析.html":{"url":"pages/clqyfe/06-Week02-lerna源码分析.html","title":"Week02 Lerna源码分析","keywords":"","body":"lerna源码分析 lerna实现原理 通过 import-local 库优先调用本地的 lerna 命令。巧妙的利用异步的方式先输出提示信息，再完成命令的执行。 通过 yargs 生成脚手架，先注册全局属性，在注册命令，最后通过 parse 方法解析命令行参数。 注册命令时需要传入 builder 和 handler 两个方法。builder 用来配置命令的专属 option，handler 用来处理命令的业务逻辑，同时命令行参数作为函数参数方式传入函数。 lerna 通过其自有的方式来引用本地依赖，而不是通过 npm link 的方式。具体写法：在 package.json 的依赖项中写入，在执行 lerna publish 时会自动将该依赖替换。 // package.json { \"dependencies\": { \"lerna\": \"file:core/lerna\" } } import-local 源码分析 TODO: 学完脚手架内容再来啃这部分内容 node 的 module 模块分析 TODO: 学完脚手架内容再来啃这部分内容 vscode 源码调试技巧 vscode 调试技巧 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/clqyfe/07-Week03-脚手架核心流程开发.html":{"url":"pages/clqyfe/07-Week03-脚手架核心流程开发.html","title":"Week03 脚手架核心流程开发","keywords":"","body":"脚手架核心流程开发 绘制 imooc-cli 脚手架架构设计图 实现 imooc-cli 脚手架准备过程代码 准备阶段分为以下步骤 检测脚手架版本号 检测 node 版本号 检查 root 账户和降级权限 检查用户主目录 入参检查及debug模式开发 检查环境变量 检查新版本及提示更新 检测脚手架版本号 const log = require('@zjw-cli/log'); const pkg = require('../package.json'); function core() { checkVersion(); } function checkVersion() { log.notice('cli', pkg.version); } module.exports = core; 检测 node 版本号 node 版本号可以通过 process.version 获取 const semver = require('semver'); const colors = require('colors/safe'); const constant = require('./const'); function core() { try { ... checkNodeVersion(); } catch (error) { log.error(error.message) } } function checkNodeVersion() { const currentVersion = process.version; const lowestVersion = constant.LOWEST_NODE_VERSION; if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`当前 node 版本：${currentVersion}，最低 node 版本：${lowestVersion}，请升级 node`)) } } 检查 root 账户和降级权限 当使用 root 账号创建的文件，别的账号是无法删除修改的，日常开发特别注意这一点。 使用 process.geteuid() 来获取账号权限 普通账号（macOS）：501 root账号：0（通过 sudo 来执行） 使用 root-check 来自动完成账号降级 function checkRoot() { const rootCheck = require('root-check'); rootCheck() console.log(process.geteuid()) // 501 } // 经过 root-check 处理后，在使用 sudo 执行，结果就是 501 // 原理：通过 process.setuid 、 process.setgid 来动态修改了用户及其分组的权限 检查用户主目录 function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error('当前登录用户主目录不存在') } } 入参检查及debug模式开发 function core() { try { ... checkInputArgs(); log.verbose('debug', 'test debug modal'); } catch (error) { log.error(error.message) } } /** * @description 检查入参 */ function checkInputArgs() { const args = require('minimist')(process.argv.slice(2)); checkArgs(args) } /** * @description 更加入参动态修改 log level，开启 debug 模式 * @param {Object} args */ function checkArgs(args) { log.level = args.debug ? 'verbose' : 'info'; } 检查环境变量 可以在环境变量中存储用户信息，配置信息等数据。 通过 dotenv 这个库实现，dotenv默认获取的是当前项目根目录中的 .env 文件。可以通过 path 属性来修改。 .env 文件中存储的数据格式是 key=value 这种格式的，获取到 .env 文件后会将里面的数据挂载到 process.env 上。 function checkEnv() { const dotenvPath = path.resolve(userHome, '.env') // 读取 .env 文件中的数据，并配置到环境变量中 require('dotenv').config({ path: dotenvPath }); createDefaultConfig(); log.verbose('环境变量缓存文件路径', process.env.CLI_HOME_PATH) } /** * @description 创建环境变量缓存文件路径 */ function createDefaultConfig() { const cliConfig = {}; cliConfig.cliHomePath = process.env.CLI_HOME ? path.join(userHome, process.env.CLI_HOME) : path.join(userHome, constant.DEFAULT_CLI_HOME); process.env.CLI_HOME_PATH = cliConfig.cliHomePath; } 检查新版本 获取npm 上所有的版本号 比较当前版本和 npm 上最新的版本 存在新版本提示更新 // core/cli/lib/index.js async function checkGlobalUpdate() { const { getNpmSemverVersion } = require('@zjw-cli/get-npm-info'); const lastVersion = await getNpmSemverVersion(pkg.version, pkg.name); if (lastVersion && semver.gt(lastVersion, pkg.version)) { throw new Error(colors.red(`请升级版本，最新版本：${lastVersion}，升级命令：npm i ${pkg.name} -g`)); } } // utils/get-npm-info/lib/index.js 'use strict'; const axios = require('axios'); const urlJoin = require('url-join'); const semver = require('semver'); // 优先调用淘宝源 function getRegistry(isOriginal = false) { return isOriginal ? 'https://registry.npmjs.org/' : 'https://registry.npm.taobao.org/'; } function getNpmInfo(npmName, registry) { if (!npmName) return null; const targetRegistry = registry || getRegistry(); const url = urlJoin(targetRegistry, npmName); return axios.get(url).then(res => { if (res.status === 200) { return res.data; } else { return {} } }).catch(err => Promise.reject(err)) } async function getVersions(npmName, registry) { const data = await getNpmInfo(npmName, registry); return data.versions ? Object.keys(data.versions) : [] } function getSemverVersions(baseVersion, versions) { return versions .filter(version => semver.satisfies(version, `>${baseVersion}`)) .sort((a, b) => semver.gt(b, a) ? 1 : -1); } async function getNpmSemverVersion(baseVersion, npmName, registry) { const versions = await getVersions(npmName, registry); const newVersions = getSemverVersions(baseVersion, versions); return newVersions[0]; } module.exports = { getNpmInfo, getVersions, getSemverVersions, getNpmSemverVersion }; 通过 commander 框架实现一个脚手架，包含自定义 option 和 command 功能 #!/usr/bin/env node const commander = require('commander'); const program = new commander.Command(); const pkg = require('../package.json'); // 配置全局属性 program // 在 Commander 7 以前，选项的值是作为属性存储在 command 对象上的。 // 这种处理方式便于实现，但缺点在于，选项可能会与Command的已有属性相冲突。 // 通过使用.storeOptionsAsProperties()，可以恢复到这种旧的处理方式，并可以不加改动的继续运行遗留代码。 // Commander 7之后所有的属性都要通过 opts() 获取 .storeOptionsAsProperties() // .name 和 .usage 用来修改帮助信息的首行提示。name 属性也可以从参数自动推导出来。 .name(Object.keys(pkg.bin)[0]) .usage(' [option]') .version(pkg.version) // 配置 option 并设置默认值 .option('-d, --debug', '开启调试模式', false) // 配置 option，指定参数 .option('-e, --envName ', '输出环境变量名称'); // command 注册命令，注意：调用 command 方法返回的时命令对象而不是脚手架对象 const clone = program.command('clone [destination]'); clone .description('clone a repository') .option('-f, --force', '是否强制克隆') .action((source, destination, cmdObj) => { console.log('clone command called', source, destination, cmdObj.force); }); // addCommand 注册子命令 const service = new commander.Command('service'); service .command('start [port]') .description('service start at same port') .action((port) => { console.log('service starting at ', port); }); service .command('stop') .description('stop service') .action(() => { console.log('service stop'); }); program.addCommand(service); /** * @description 独立执行的命令 * 当.command()带有描述参数时，就意味着使用独立的可执行文件作为子命令。 * Commander 将会执行一个新的命令。新的命令为： 脚手架命令-注册的命令，如下例中未配置 executableFile 前执行的是 'zjw-cli-test-install'。 * 通过配置选项 executableFile 可以自定义名字。 * 这种方式可以实现脚手架之间的嵌套调用 */ program .command('install [name]', 'install package', { executableFile: 'zjw-cli', // 由原先的 zjw-cli-test-install 改为执行 zjw-cli // isDefault: true, // 默认执行该命令，即执行 zjw-cli-test 就是执行 zjw-cli-test install hidden: true // 在帮助文档中隐藏该命令 }) .alias('i') // arguments 可以为最顶层命令指定命令参数。如下例：表示配置一个必选命令 username 和一个可选命令 password。 // arguments 指定的命令参数是泛指，只要不是 command 和 addCommand 注册的命令都会被捕获到。 // zjw-cli-test abc => username 就是 abc // 可以向.description()方法传递第二个参数，从而在帮助中展示命令参数的信息。该参数是一个包含了 “命令参数名称：命令参数描述” 键值对的对象。 program .arguments(' [password]') .description('test command', { username: 'user to login', password: 'password for user, if required' }) .action((username, password) => { console.log(username, password); }); /** * @description 自定义 help 信息 * 方法一： 步骤一：重写 helpInformation，返回值是啥 help 信息就是啥；。 * 方法二： 步骤一：重写 helpInformation，返回值空字符串； 步骤二： 调用 on 方法监听 --help，在回调函数中输出 help 信息。 * 方法三： 步骤一：重写 helpInformation，返回值空字符串； 步骤二： 调用 addHelpText 方法 * * 如果你不想清除内建的帮助信息， * 方法一：不重新 helpInformation，只监听 --help； * 方法二： 调用 addHelpText 方法（建议这种） */ program.helpInformation = function() { return 'output your help information\\n'; } /** * @description 实现 debug 模式 * 方法一： 调用 on 方法监听 --debug * 方法二： 调用 on 方法监听 option:debug */ program.on('option:debug', () => { console.log('debug: ', program.debug) process.env.LOG_LEVEL = 'verbose' }) /** * @description 监听未知的命令 */ program.on('command:*', (obj) => { console.log(obj); console.error('未知的命令：', obj[0]); // 获取所有已注册的命令 const availableCommands = program.commands.map(cmd => cmd.name()); console.log('可用命令：', availableCommands.join(', ')) }) // 解析参数 program.parse(process.argv); 实现 node 对 ES Module 的支持 通过 webpack 来实现对 ES Module 支持，并且通过配置 loader，使用 babel 对 js 进行编译，来兼容低版本的 node。 将js文件后缀名为 .mjs，导入 .mjs。node 版本小于 14 需要加上 --experimental-modules 来对 mjs 进行支持。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/coderzlh/":{"url":"pages/coderzlh/","title":"Coderzlh","keywords":"","body":"coderzlh - 学习分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/coderzlh/01-week01-note.html":{"url":"pages/coderzlh/01-week01-note.html","title":"Week01 Note","keywords":"","body":"第一周笔记 体验地址: 慕课乐高 项目架构 使用技术栈 架构设计做什么 如何做 架构师的核心价值 : 通过技术手段保证技术增长,对业务精准理解 需求指导设计,设计指导开发 技术永远是为业务服务的,技术是实现业务增长的工具 整体分析时不需要注意细节 判断可行性,需要适当调研 考虑复杂度,不过度设计 脱离业务的设计就是耍流氓 需求即业务,无业务不架构 需求闭环 业务闭环 前段开发流程 需求关系图 技术方案设计文档 模块设计 h5端: 提供作品展示与分享的功能 编辑器前端: 提供作品编辑 制作与发布功能 编辑器服务端: 支持编辑器前端的功能 并将作品持久化到数据库 后台管理前端: 供管理员使用 用于管理作品与模板 快速下线违规作品 查看运营统计数据 后台管理服务端: 为后台管理提供接口服务 组件库: 为h5与编辑器端提供组件服务 并可以通过脚手架工具快速创建和发布组件 自研统计: 用于统计自定义事件的pv uv等指标 三方服务: 短信服务: 用于注册 登陆以及密码找回等操作需要验证用户身份时使用 oss文件存储: 存储静态文件 埋点统计: 用于统计pv uv等常见运营指标 微信sdk: 用于微信分享 便于传播 核心数据结构 每个组件尽量符合vnode规范 使用数据来组织数据 有序 尽量使用引用关系 不要冗余 { work:{ id:'xxx', title:'标题', props:{/*全局配置属性*/}, settings:{/*拓展预留*/}, components:[ { id:'xxxx', name:'文本1', tag:'text', attrs:{color:red}, children:[] } ] }, //当前被选中的组件id activeComponentId:'xx' } 拓展性 增加动画,音效 甚至简单的交互功能 批量选中与批量修改 多人协作 同时编辑 研发提效 脚手架: 创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控与告警 服务拓展性: 基于云服务,可以随时拓展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/conan2008/":{"url":"pages/conan2008/","title":"Conan2008","keywords":"","body":"霓源阁 - 学习分享 第一周 01-Week01-技术设计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/conan2008/01-Week01-技术设计文档.html":{"url":"pages/conan2008/01-Week01-技术设计文档.html","title":"Week01 技术设计文档","keywords":"","body":"整体架构设计 需求 自动生成海报系统， 创作者可通过浏览器使用平台生成模板，并发布作品； 普通C端用户预览、使用、分享作品，通过H5埋点分析作品的使用情况，用可视化界面呈现埋点效果，给创作者反馈作品效果； 管理员可在后台管理系统管理作品，审核、下线、置顶优秀作品等操作。 模块设计 数据结构 组件使用vnode数据格式， 业界规范， 节约沟通、阅读成本；使用字段activeId 标记当前选中组件， 共享单一数据源； { work: { id: '', title: '', // config: '', // 基础配置项 props: '', // 页面整体配置 body components: [ { id: '12u8d', name: '图片', tag: 'image', // 组件类型 attrs: {}, // 标签属性 children: [] } ], activeId: '12u8d' // 当前激活的组件 } } 数据流转关系图 创作作品： 基于基础json模板创建 保存作品： 修改json 发布作品： 修改json一个标识属性 预览： 或者json数据 ssr渲染 下线： 修改json一个标识属性 扩展、维护 设计考虑扩展性不一定要自己都把所以都想通， 自己尽可能去思考，最后设计评审头脑风暴、集思广益，讨论补充 开发提效 组件复用第三方库脚手架等 运维保障 线上服务和运维服务安全性监控和报警服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/filway/":{"url":"pages/filway/","title":"Filway","keywords":"","body":"大家好，我的目标是年薪50万，搞钱~~~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/filway/week1.html":{"url":"pages/filway/week1.html","title":"Week1","keywords":"","body":"技术方案文档 需求 项目需求url,比如禅道链接 分析需求 浅层需求 登录 注册功能 短信验证码登录 用户信息（昵称，头像等等的修改） 作品 新建 保存草稿 发布 获取作品详情 获取作品列表 模版 模版列表 使用模版创建 深度需求 作品的管理 删除和恢复 转赠 复制 作品统计 pv/uv 自定义事件统计，分渠道统计 作品发布 url不能变 支持多渠道 H5 分享 后台管理 数据统计 作品管理，能快速下线作品，防止有违规内容 用户管理，能快速冻结用户，防止有违规用户 模版管理，能控制哪些模块展示、哪些不展示 需求总结 范围 需要哪些项目 B端和编辑器，做前后分离 biz-editor-fe biz-editor-server H5 H5-server 管理后台 admin-fe admin-server 独立的业务组件库 模块设计 组件库，独立第三方，同时用于编辑器和H5，实现所见即所得，UI一致性 统计服务自研，因为第三方服务（如百度）只能统计基本的pv/uv，自定义统计，参数级别的统计要么没有要么收费，综合考虑还是自研比较好，还能加入日志统计，日志分析 作品的数据结构 vuex store的结构 { work: { title: '作品标题'， setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面body的设置，如背景色，全局字体大小，颜色 */ }, components: [ // 用数组，有序结构 // 单个 node 要符合常见的 vnode格式 { id: 'xxx', //唯一组件id name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } vuex getter { //图层 layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 数据流转关系图 扩展性保证 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面的配置 能自动生成B端管理后台页面，比如表单组件，表格组件，分页组件，搜索组件等等 页面自适应不同平台，可以改变页面的宽高，能编辑保存发布到手机，平板，PC等等 有更多的交互，例如弹窗，tooltip，图表等等，随着业务需求的增加，持续的集成 可以考虑定期评选精选模版，给予一定奖励，首页置顶展示 加入付费功能，用户可以售卖自己的模版 seo 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/filway/week3.html":{"url":"pages/filway/week3.html","title":"Week3","keywords":"","body":"脚手架架构设计图 脚手架准备过程 //检查版本号,直接加载package.json // require支持加载的资源文件有: .js/.json/.node 3种类型的文件 // .js -> 必须要有module.exports/exports 必须输出模块 // .json -> 会执行JSON.parse // .node -> C++ 插件 (process.dlopen) // any(其它所有类型) -> 默认通过.js引擎来解析 const pkg = require('../package.json'); //检查node版本,不能低于 自定义常量LOWEST_NODE_VERSION function checkNodeVersion() { const currentVersion = process.version; const lowestVersion = constant.LOWEST_NODE_VERSION; //比对版本号 if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`filway-cli 需要安装 v${lowestVersion} 以上版本的 Node.js`)); } } //检查root启动 function checkRoot() { //root降级 const rootCheck = require('root-check'); rootCheck(); } //检查用户主目录 const userHome = require('user-home'); function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登录用户主目录不存在！')); } } //检查入参, 通过检查是否有debug参数, 来设置对应的log level function checkInputArgs() { const minimist = require('minimist'); args = minimist(process.argv.slice(2)); checkArgs(); } function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose'; } else { process.env.LOG_LEVEL = 'info'; } log.level = process.env.LOG_LEVEL; } //检查环境变量 function checkEnv() { const dotenv = require('dotenv'); const dotenvPath = path.resolve(userHome, '.env'); if (pathExists(dotenvPath)) { dotenv.config({ path: dotenvPath }); } createDefaultConfig(); } function createDefaultConfig() { const cliConfig = { home: userHome, }; if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME); } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME); } process.env.CLI_HOME_PATCH = cliConfig.cliHome; } //检查是否为最新版本,提示更新 //思路: // 1、通过npm api获取对应模块的所有高于当前版本号的版本号,然后取出最高的一个版本号(通过semver对比) // 2、再通过对比上面取出的版本号和当前版本号, 如果有大于当前版本号 就提示更新 async function checkGlobalUpdate() { // 1、获取当前版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; // 2、调用npm API，获取所有版本号 https://registry.npmjs.org/xxxxx // 3、提取所有版本号，比对哪些版本号是大于当前版本号 // 4、获取最新的版本号，提示用户更新到该版本 const { getNpmSemverVersion } = require('@filway-cli/get-npm-info') const lastVersion = await getNpmSemverVersion(currentVersion, npmName) if (lastVersion && semver.gt(lastVersion, currentVersion)) { log.warn('更新提示',colors.yellow(`请手动更新 ${npmName}, 当前版本: ${currentVersion}, 最新版本: ${lastVersion} 更新命令: npm install -g ${npmName}`)); } } commander框架 const { Command } = require('commander'); const pkg = require('../package.json'); const program = new Command(); program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false) .option('-e, --envName ', '获取环境变量名称'); // command api 注册命令 const clone = program.command('clone [destination]'); clone .description('clone a repository into a newly created directory') .option('-f, --force', '是否强制克隆') .action((source, destination, cmdObj) => { console.log('clone command called', source, destination, cmdObj.force); }); // addCommand 注册子命令 const service = new Command('service'); program.addCommand(service); service .command('start [port]') .description('start service at some port') .action((port) => { console.log('do service start '+port) }); service .command('stop') .description('stop service') .action(() => { console.log('stop service') }); program .command('install [name]', 'install package', { executableFile: 'filway-cli', // isDefault: true, hidden: true }) .alias('i') // program // .arguments(' [options]') // .description('test command', { // cmd: 'command to run', // options: 'options for command' // }) // .action( (cmd, options) => { // console.log(cmd, options); // }) // 高级定制1: 自定义help信息 // program.helpInformation = function () {return ''}; //清空原始的help信息 // program.on('--help', function () { // console.log('my help info') // }) //高级定制2: 实现debug模式 program.on('option:debug', function () { if (program.opts().debug) { process.env.LOG_LEVEL = 'verbose' } console.log(process.env.LOG_LEVEL) }) //高级定制3: 未知命令的监听 program.on('command:*', function (obj) { console.log(obj); console.error('未知的命令: ' + obj[0]); const availableCommands = program.commands.map( cmd => cmd.name()); //console.log(availableCommands); console.log('可用命令: '+availableCommands.join(',')); }) program .parse(process.argv); 如何让Node支持ES Module 通过webpack + babel 编译 node js原生支持, 需要.mjs后缀 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/ifreeOvO/":{"url":"pages/ifreeOvO/","title":"IfreeOvO","keywords":"","body":"Sam 老师 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/ifreeOvO/week01 笔记和作业.html":{"url":"pages/ifreeOvO/week01 笔记和作业.html","title":"Week01 笔记和作业","keywords":"","body":"week01 笔记和作业 为什么全局安装@vue/cli后会添加命令vue 因为决定命令名称的是package.json的bin 里面的配置，与包名无关 // package.json \"bin\": { \"vue\": \"bin/vue.js\" } 全局安装@vue-cli时发生了什么 安装后，包会被下载在全局的node_modules里，然后解析package.json的bin，接着在安装node的主目录的bin文件下创建一个软链接，指向实际执行的文件 为什么vue指向一个js文件，我们却可以直接通过vue命令直接取执行它 执行vue时，它等价于执行指向软链接对应的实际文件，系统会根据文件首行的#! /usr/bin/env node，去环境变量中找node命令，最后通过node命令执行实际文件 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jia林_286621855/":{"url":"pages/jia林_286621855/","title":"Jia林 286621855","keywords":"","body":"前端架构 整体思维、全局思维、闭环思维 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jindong/":{"url":"pages/jindong/","title":"Jindong","keywords":"","body":"jindong - 前端架构师课程学习心得 第一周 需求分析和架构设计 第二周 脚手架架构设计和框架搭建 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jindong/01-需求分析和架构设计.html":{"url":"pages/jindong/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析：架构师的思维分析项目需求（浅层需求、深度需求、需求总览） 一眼能看到的需求是浅层需求，比如说：登录，创建作品，发布 不容易一眼看到，却很重要的需求是深层需求，比如说：作品恢复、转赠、统计 对架构师而言，对业务的深层理解是很重要 流程图：分析项目需求的工具 全局思维、整体思维、闭环思维 目标不是一成不变的，必要时可以调整目标 架构师和普通程序员的区别：架构师必须精准理解业务需求，对业务完全负责 技术永远是为业务服务的，技术是实现业务增长的工具 一定要重视需求和设计的重要性 脱离业务的架构就是耍流氓。架构师必须要深入理解需求、参与需求、看透需求背后的业务本质 架构设计：确定需要创建的项目、项目范围、项目之间的关系 规划业务组件库：考虑组件的拆分和复用 注意事项： 不要关注细节，要看整体，看范围 考虑扩展性（这就需要深入理解业务，否则你也不知道未来将如何扩展） 考虑可行性，不确定的就调研一下 考虑实现成本，不要为了设计而设计，技术要永远服务于业务 —— 永远都要选择最简单的实现方案 架构设计：调项目技术研，确定第三方和自研服务 尽量使用第三方服务，如果没有合适的第三方服务，则自行研发，如：自定义事件统计 架构设计：数据结构设计和数据流转设计 数据设计基本思路： 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 绘制数据流转关系图 架构设计：编写技术方案设计文档 写代码前要写，技术方案设计文档（架构设计文档），写文档是为了整理思路，从而更好的写代码 需求背景：把需求文档贴上 范围：整体设计，没有细节 模块设计 模块拆分和关系图 各个模块的功能解释 特殊模块说明：组件库、统计服务 核心数据结构设计 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 研发提效 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 关于运维保障 做架构师，要一直有风险意识，让你的系统时刻在你的监视之内，这才靠谱。 大厂：有自己自研的运维工具和流程，要熟练使用，并知道负责的接口人 小厂：了解市面上比较靠谱的第三方服务 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jindong/02-脚手架架构设计和框架搭建.html":{"url":"pages/jindong/02-脚手架架构设计和框架搭建.html","title":"脚手架架构设计和框架搭建","keywords":"","body":"脚手架学习 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/":{"url":"pages/joge/","title":"Joge","keywords":"","body":"姜浩然-作业及打卡的地方 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-01-技术方案设计文档.html":{"url":"pages/joge/week-01-技术方案设计文档.html","title":"Week 01 技术方案设计文档","keywords":"","body":"整体架构设计V1.0 范围 拆分模块范围: 编辑器发布和预览h5, 拆分为前端和后端 管理平台管理用户和h5的上线下线, 拆分为前端和后端 展示端 H5服务端渲染html串 组件库展示端和编辑器公用的组件库 统计自研一个统计服务，H5负责收集信息，然后服务进行分析，通过openApi的方式达到展示，完成闭环 数据库编辑器和管理平台共用一套数据库 模块设计 编辑器 用于发布/预览H5, 新建及更新H5 管理平台 控制H5的上线和下线，比如紧急下线 H5 组件库 编辑器和H5都用到这个组件库 统计 在H5端收集信息，通过openApi的方式提供对外的接口自研主要是为了自定义一些事件提供统计服务业务才能闭环 整体流程及数据流转 作品的数据结构 以数据驱动为思想 维护一份数据，通过这份数据去渲染不同的组建（减少数据同步） 以数组为整体的数据结构，方便排序 单个的数据（组建）以vnode的格式存储读取eg: { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， components: [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 扩展性保证 扩展组件 数据结构层面可扩展 组件库层面扩展 扩展编译器的功能 组件隐藏、锁定、滑动翻页 扩展页面配置 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务用什么 安全 监控和报警 服务扩展性：流量大时怎么解决 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-02-cli.html":{"url":"pages/joge/week-02-cli.html","title":"Week 02 Cli","keywords":"","body":"项目脚手架 通过learn发布的npm项目理解git流理解前端自动化 核心是为了提高研发效率（心中牢记） 听完这周课程又理解了node能做的这么多 脚手架开发入门 脚手架的必要性 提升研发效能 创建项目和通用代码 git操作（自动化） 构建和发布上线 价值 自动化 拷贝重复代码/git操作/发布上线 标准化 创建项目/git flow/发布流程/回滚流程 数据化 使研发流程可量化 脚手架到底是什么 从使用的角度 到底什么是脚手架本质是操作系统的客户端，通过命令执行 vue create my-vue-object --force -r xxxx 主命令: vuecommand: create - 子命令 可以理解成发送一个请求command的param: my-vue-object - command的参数option: force r - 选项 可以理解成配置option的param: xxxx 整体执行过程输入命令后 -> 解析出命令所在的真实的位置 -> 执行真实的文件（文件顶部获取环境变量中的node）-> 通过node执行文件 -> 文件再解析命令 执行相关操作 -> 执行完毕退出 以vue create 为例子 终端会从环境变量中找到vue然后解析出vue.js vue.js解析command options vue.js执行command 执行完毕退出 怎么开发脚手架 开发一个npm项目，包含一个bin/vue.js, 发布到npm 将npm项目安装到node的lib/node_modules 在node/bin目录下配置软连接连接到lib/node_modules/@vue/cli/bin/vue.js 疑问 如何自动添加命令通过package.json里的bin字段进行设置 全局安装脚手架时发生了什么安装依赖 -> 设置软连接（bin） 执行命令为什么不用输入node就可以执行js文件的顶部设置了通过环境变量里的node来执行 实现原理 依赖node 和操作系统有关 - 环境变量 root账户 为脚手架设置别名 直接设置软连接 开发流程 npm项目 添加入口文件 最上方添加 #! /usr/bin/env node package.json添加bin属性 编写代码 发布npm包 开发难点 如何将复杂系统拆分然后再合成一个复杂系统 注册一系列命令 参数解析 编写帮助文档 参数解析 注册命令 init --version、 init --name lerna 基于git+npm 多package 解决脚手架过程中的重复操作 重复操作 解决版本一致性问题 使用lerna搭建项目 lerna源码分析 源码结构 核心执行流程 import-local yargs yargs用法 dedent把通过``里换行的部分顶格yargs .options(opts) .group(globalKeys, \"Global Options:\") .option(\"ci\", { hidden: true, type: \"boolean\", }); options: 全局方法，所有的common都可以使用 加载模块过程 Module._resolveFilename Module._resolveFilename(moudleId, { id: fromFile, // 文件路径 filename: fromFile, path: Module._nodeModulePaths(fromDir) // 所有可能的nodemodule的路径 }) // 细节未添加完 架构 效能为核心目标 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-03-cli.html":{"url":"pages/joge/week-03-cli.html","title":"Week 03 Cli","keywords":"","body":"了解流程 项目设计阶段搞清业务或者研发的痛点，然后形成需求，然后输出文档，然后技术方案设计、形成文档，然后立项、启动，排期 实施交互、视觉设计、输出设计稿，前端根据设计稿开发，后端开发，连调，测试，验收，上线 了解如何设计、拆分 开发 架构图 看了老师视频 停了一天 自己来画图的时候~ 感觉思路还是不对呀! 比如如何拆分 如何形成闭环 如何让人看明白~ 还得多多联系呀 先看第一版的图:是不是很简陋~ 没有细节!这个脚手架需要一个框架进行搭建 --> 管理模版和组件（npm的方式，需要后端提供API）--> 通过配置git流来管理开发流程 --> 配置统一的发布上线流程(需要发布服务的支持)那么来补充细节: 脚手架核心框架根据操作系统完成准备阶段，完成注册命令，标准的执行命令流程 模版/组件管理模版、组件初始化的支持，支持标准和自定义初始化同时需要服务（通过OPEN API）来支持这个模块: 查询、接入OSS API、缓存配置 发布通过websocket完成云构建、云发布、提供不同环境的支持 git管理如何创建仓库 --> 开发时如何创建分支 --> 上线后删除分支创建tag更新后的第二版图:加入了各个模块的细节还差一些依赖分析 脚手架要和本地系统的文件系统关联（本地文件系统和环境变量） 初始化体系 依赖模版库NPM包 通过一个数据库管理项目模版和组件模版 NPM包也要从数据库中获取信息 发布体系 前端OSS资源服务 CDN 前端资源加速 远程缓存体系 git远程仓库托管及相应的操作流程通过这个对结构有了大体上认识，也能理解实际项目里用的脚手架大概为了解决什么样的工作比如: 我这通过脚手架来创建项目 通过配置git仓库是为了告诉脚手架从哪读取代码，对应这里的git操作体系，还有隐藏在背后的打包发布流程 基础的流程 检查版本号 获取package.json里的版本号 reqiure加载资源的方式 - .js/.json/.node 其他的格式类型的文件默认以JS文件来解析 npmlog 添加自定义事件 判断debug模式(semver和commander两种方式) 添加自定义前缀 最低node版本要求 获取当前版本号: process.version 比对版本号 samver - 各种各样的版本号比对 root账号启动检查和自动降级功能root-check 用户主目录检查功能user-homepath-exists 入参检查和debug模式minimist - 参数解析这里解析为了设置log的等级 是否需要打印debug 环境变量检查功能将用户名密码等敏感信息保存在本地 npm API 获取当前版本号 调用npm api获取所有版本号 比对版本号url join npm全局更新功能 注册命令commander commander怎么用 commander全局注册 commander搭建脚手架正在公司自己的包管理系统上学着发布 node端处理ESmodule github上有了哈 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-04-cli.html":{"url":"pages/joge/week-04-cli.html","title":"Week 04 Cli","keywords":"","body":"动态加载init库流程 来来回回看了三遍～ 我用图表示一下～ 有不对的地方帮指正～ 代码按老师的敲了变～ node多进程源码分析 async的源码阅读暂时了解也是创建了三个管道(pipe)，里面维护了taskqueue。 更细节的需要多读几遍了，脑壳疼～ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-05-cli.html":{"url":"pages/joge/week-05-cli.html","title":"Week 05 Cli","keywords":"","body":"init阶段 通过之前的命令进入到init的npm包 业务逻辑都在这个init包里处理 准备阶段 这个阶段需要拿到开发者填写的项目模板信息步骤: 当前目录是否为空(通过交互或者命令行里的force字段来控制是否清空目录) 上面逻辑处理完 进入交互阶段获取到项目信息(requirer的链式调用，名称和版本号的校验) 项目类型是否为组件 mongodb 花了点时间弄了下数据库 可以访问了～http://www.curlyhair.cn:7001/project后来不小心删了库，觉得备份还是很重要啊弄的时候在系统和版本之间遇到一些问题，启动的时候也遇到一些问题～ 都是百度解决的～所以希望老师能讲讲基础的一些部署和规范的mongodb的操作启动遇到问题应该是mongodb操作的时候不当 命令行交互 又觉得事件监听和异步是前端的灵魂！！！源码跟着老师通看了一遍加上前面的一些源码～ 要加油才能完全看懂了～ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-06-cli.html":{"url":"pages/joge/week-06-cli.html","title":"Week 06 Cli","keywords":"","body":"脚手架 终于看完了脚手架 有不少点还没弄透，代码也是“参照”老师的。自己弄了个npm包 开始从头撸一遍。 sam老师&#x1F402;&#x1F37A;！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-07-cli.html":{"url":"pages/joge/week-07-cli.html","title":"Week 07 Cli","keywords":"","body":"B端项目需求分析和架构设计 总体收获 - 数据驱动期待一下VUE3 最近我在项目中通过JSON来渲染表单, 被提出不好维护提出不好维护后我有点想换思路，看到老师给的form-render觉得思路是可以的～代码类似: const originFormData = [ { type: 'input', key: 'code', // 对应后端的字段 title: '', rules: [], api: '', // 是否需要发送请求 fetched: false, // 是否已经发送请求 一经发送修改状态 不管结果 防止发送多次请求 dependency: 'otherKey', // 是否依赖其他字段 } ] 我这遇到的痛点是 输入框的数据是请求回来的 输入框有些是级联的 我现在渲染流程：现在还没和后端同学沟通返回的字段，所以我前端去拼数据结构状态管理是redux思路是 我通过Store(JSON)来渲染表单，表单的操作去修改Store, 触发渲染 const formData = initFormdata(originFormData); // 返回一个深度拷贝的对象 这样重置的时候方便一些 updataFormData(data) { // ... 业务代码 // 我现在有递归去设置值 必要的时候会拷贝值 dispatch(setFormData(data)); } 级联的问题想通过订阅发布来做（还没具体实施） 所以请教一下老师 关于异步请求数据和级联 有没有好一点的解决思路。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-08-技术预览.html":{"url":"pages/joge/week-08-技术预览.html","title":"Week 08 技术预览","keywords":"","body":"范型 为什么会出现范型 function echo(arg) { return arg; } const result = echo('str') // resulut: any 这样我们获取不到类型 所以范型是希望拿到类型 - 在使用中指定类型的特性 function echo(arg: T): T { return arg } const result = echo('str') // resulut: string eg: 异步请求 通过不通的URL返回不同的数据 function withAPI(url: string) { return fetch(url).then(res => res.json()): } withAPI('xxx').then(res => res); // res: any interface xxxRes { name: string; count: number; } interface yyyRes: { code: string; key: string; } function withAPI(url: string): Promise { return fetch(url).then(res => res.json()): } withAPI('xxx').then(res => res); // res: xxxRes withAPI('xxx').then(res => res); // res: yyyRes interface 不用把JS中的数据结构和interface套在一起，interface另一个名称 duck typing～ 描述一个函数 interface RandomMap { [prpName: string]: string } const test: RandomMap { a: 'hello' } react中的函数组件的声明 interface FunctionComponent { // 范型的默认值 (props: PropsWithChildren, context?:any): ReactElement | null; propsTypes?: WeekValidationMap; defaultProps?: Partial; // Partial内置类型 把传入的类型变成可选的 } 可以把interface理解成声明任何你想要的数据结构 interface来约束类 interface CLockInterface { cuttentTime: number; alert(): void; } interface GameInterface { play(): void } interface ClockStatic { new (h: number, m: number): void; // 函数类型 time: number; } const Clock: ClockStatic = class Clock implements ClockInterface { constructor(h: number, m: number) { } static time = 123; currentTime: number = 123; alert() { } } class Clock implements ClockInterface, GameInterface { currentTime: number = 123; alert() { } } 可以减少无用的继承，通过约束来使用 范型和接口 const Test = (props) => { return ( <> {props.title} {props.desc} <> ) } 交叉类型和联合类型 - 类型断言 // 交叉类型 type PropsWithChildren = p & { children ?: ReactNode }; // 联合类型 let numberOrString: number | string // 类型断言 xxx as number partial: type Partial = { [P in keyof T]?: T[p]; } // keyof - 类比Object.keys(Obj) 是一个联合类型 // T[p] - 可以拿到类型值 作业：属性都为readonly type PartialReadOnly = { readonly [p in keyof T]?: T[p] } interface IUser { phone: number, age: number } type optional = PartialReadOnly; 范型约束 extends 定义文件 .d.ts - 声明文件 第三方库 一般都帮我们声明好了 命名一般以@type/xxxx开头 Definitely开源库 VUE3 向后兼容 新特性 breaking change 性能提升 typescript Composition API 为什么需要 后期业务组件复杂后难以维护 - 把各个功能理解成函数，一个函数代表一个功能，方便调用和维护 setup() { const count = ref(0) // ref - 定义成响应式数据 const addCount = () => { count.value++; } return { count } } 响应式编程 保存effect 监测值的改变 - proxy 执行effect 纯函数和副作用 纯函数 相同的输入，永远得到相同的输出 没有副作用 副作用 函数外部环境发生的交互 网络请求 DOM操作 订阅数据来源 写入文件系统 获取用户输入 react - useEffect vue - watchEffect 自动跟踪函数体内的值 watchEffect 自动收集依赖并触发 自动销毁effect - watchEffect返回一个函数 执行后就销毁了 使副作用失效 副作用的执行顺序 watch 自定义hooks 将相关的feature组合在一起 容易重用 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-09-doc/编码规范.html":{"url":"pages/joge/week-09-doc/编码规范.html","title":"编码规范","keywords":"","body":"编码规范 一份统一的编码规范可以大大降低阅读代码的成本 ESLint 在我们开发和提交代码的过程中帮我们规范好代码格式通过plugin可以自定义自己的规范通过babel可以帮助我们提交前就做好监测，保证代码质量 可以参考其他的规范定义自己的规范，和组内成员商量即可 Git 工作流结合自己的开发方式选择和组内成员定义一下提交规范，比如设置一些勾子函数来约束。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-09-doc/项目结构规范.html":{"url":"pages/joge/week-09-doc/项目结构规范.html","title":"项目结构规范","keywords":"","body":"项目结构规范 文件夹结构 避免多层嵌套不要过度思考参考React书里的建议:采用混合方式划分文件结构 采用类型划分的优势 添加功能划分的特点 src/ |----app.js // 整个应用的入口 |----app.css |----views // 应用中某个路由的文件 一般为路由组件 | |----Home.js | |----Home.css | |----HomeRedux.js // home页面中所有与redux相关的汇总 |----components // 所有应用的组件 | |----Home // 在view中有一个名为Home的view 在这就有一个名为Home的子文件夹 | | |----Table.js // home中的一个列表组件 | | |----Table.css | | |----TableRedux.js | | |----Table // 另一种方式 如果组件很多 文件夹打开会很长 | | | |----Index.js | | | |----Index.css | | | |----IndexRedux.js | |----shared // 不归属于任何view的组件 比如公共组件 |----container | |----DevTool.js // 配置DevTool | |----Root.js // 一般被app.js依赖 |----layout // 布局相关的组件 如菜单 侧边栏 |----redux | |----reducers.js // |----routes // 路由相关的配置 |----utils // 工具函数常量等 |----styles // 全局公共样式 单文件组件文件的大小写 单文件组件的文件名应该要么始终是单词大写开头 (PascalCase)，要么始终是横线连接 (kebab-case)。单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。然而，混用文件命名方式有的时候会导致大小写不敏感的文件系统的问题，这也是横线连接命名同样完全可取的原因。 components |---- MyComponent.vue 或者 components |---- my-component.vue 基础组件命名 应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V components |---- BaseButton.vue |---- BaseTable.vue |---- BaseIcon.vue components |---- AppButton.vue |---- AppTable.vue |---- AppIcon.vue components |---- VButton.vue |---- VTable.vue |---- VIcon.vue 单例组件命名 只应该拥有单个活跃实例的组件应该以 The 前缀命名，以示其唯一性。 components |---- TheHeading.vue |---- TheSidebar.vue 紧密耦合的组件名 components |---- TodoList.vue |---- TodoListItem.vue |---- TodoListItemButton.vue 组件名的单词顺序 组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 components |---- ClearSearchButton.vue |---- ExcludeFromSearchInput.vue |---- LaunchOnStartupCheckbox.vue |---- RunSearchButton.vue |---- SearchInput.vue |---- TermsCheckbox.vue components |---- SearchButtonClear.vue |---- SearchButtonRun.vue |---- SearchInputExcludeGlob.vue |---- SearchInputQuery.vue |---- SettingsCheckboxLaunchOnStartup.vue |---- SettingsCheckboxTerms.vue 模版中的组件名大小写 对于绝大多数项目来说，在单文件组件和字符串模板中组件名应该总是 PascalCase 的——但是在 DOM 模板中总是 kebab-case 的。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/joge/week-09-项目预览.html":{"url":"pages/joge/week-09-项目预览.html","title":"Week 09 项目预览","keywords":"","body":"最近项目中要处理不少状态 疯狂reset update init 中～ Imooc CLI 通过脚手架建立项目模版 ESLint module.exports = { extends: [ // 可以拿其他公司的规范合集 ] } 可以通过配置每次保存的时候自动ESLint 使用Prettier自动格式化代码 项目结构规范 react的项目推荐标准 按照路由或者功能来组织 避免多层嵌套 不要过度思考 命名选择: 帕斯卡规范 作业：文档 // 文件夹一律小写 /components -- ColorPicker.vue (组件使用Pascal命名方式) /hooks -- userURLLoader.ts (use开头，使用驼峰命名方式) /plugins -- hotKeys.ts (使用驼峰命名方式) Git Flow 不同分支的方式 release - 开发分支 测试结束后合如dev hostfix - 线上BUG分支 master - 长期维护 dev - 长期维护 pull request方式 PR - 适合持续交付、和大佬有交流 作业：文档 分支名称 新功能分支 feature开头 修改bug分支 hotfix开头 提交时 fix: [bug号] 修改什么什么问题 xxx docs: 只改动了文档相关的内容 style: 不影响代码含义的改动，例如去掉空格、改变缩进、增删分号 build: 构造工具的或者外部依赖的改动，例如webpack，npm refactor: 代码重构时使用 revert: 执行git revert打印的message UI库 ant-design-vue vue-router 作业: hash模式 hash模式是获取url里的hash值，兼容性比较好，h5那个是通过H5的API来实现的。 基础都是通过监听事件来触发组件渲染。 理解router帮我们把URL里的参数改造成props通过props来判断当前需要渲染哪个组件。 vuex 全局store创建和vue结合 通过钩子函数拿到全局状态 通过全局类型进行自动补全 通过module分割store Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jolly_chen/":{"url":"pages/jolly_chen/","title":"Jolly Chen","keywords":"","body":"Jolly_chen - 作业打卡 请直接看下级目录 感谢各位同学的笔记，让我获得很多提示，并模仿完成我的笔记！ 第一周笔记 第二周笔记 第三周笔记 脚手架核心流程开发笔记 commander使用 Node支持ES Module 第四周笔记 脚手架命令注册和执行过程开发 Node多进程入门 child_process异步源码解析 child_process同步源码解析 cluster深入浅出 第五周笔记 脚手架创建项目流程设计和开发 egg.js + 云MongoDB快速入门 readline 深入浅出 ansi-escapes 和 rxjs readline 深入浅出 第六周笔记 脚手架创建项目和组件初始化开发 glob使用 node require 加载模块 第七周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jolly_chen/01-技术方案设计文档.html":{"url":"pages/jolly_chen/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":"整体架构设计V1.0 需求背景 需求文档语雀链接 创建作品、发布作品、管理作品 范围 整体设计、架构设计 包括B端和编辑器、H5端、管理后台、独立组件库、自研统计服务，pv/uv统计，使用第三方统计服务（免费的）。 模块设计 模块拆分 B端和编辑器，比较复杂，前后端分离 H5端，考虑性能，使用SSR，只需要服务端 管理后台也前后端分离，分管理前端和管理后端 组件库分为业务组件库和组件平台 业务组件库渲染B端画布和H5页面，保证B端编辑器和H5内容和样式，即B端编辑器和H5的组件和渲染逻辑一致。组件平台创建、发布组件，支持业务组件库，方便组件扩展。 自研统计服务 模块关系图及各模块职责简要说明 自研统计服务 负责pv/uv之外的统计，pv/uv只是域名级别的访问统计，自研统计服务实现参数级别的统计。具备的功能 支持自定义事件统计，接受埋点统计请求（日志收集） 分析统计结果（日志分析） 提供Open API给使用方 为何自研：调研发现，第三方统计服务，若要满足上述功能，费用很贵。但统计服务是整个业务的输入环节，供公司运营使用，提供决策依据，比如从什么渠道投放广告达到收益和费用的平衡等 。有输入有输出，项目才能闭环，不能砍掉，所以只能自研。 核心数据结构 一个“作品”的数据结构 { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， components: [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 使用vuex store的缓存数据，方便页面上各组件读写。 图层 使用 vuex getter计算得出，这个的getter和vue computed类似 { layers () => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 数据结构设计的解释 使用vnode规范存储组件数据，vue本身也实现了VNode，使用VNode也符合vue特点。其方便组件扩展，增强页面dom节点的表述，增加数据结构的合理性并降低学习成本 使用数组存储组件，方便画布中的组件排序 不单独存储图层数据，规避图层和组件状态同步问题。这里的图层是若干组件的一个索引或者是给组件排序的一个列表，应该使用computed计算出图层的索引，满足较少数据源原则 activeComponentId是画布和属性面板同步更新的重点，组件变了，图层就发生改变 重复一遍，尽量使用索引，避免数据冗余 问题（这个不属于技术方案设计文档的内容）：如何保证画布和属性面板是同步更新的？ ​ 如果要扩展一个图层面板，数据结构该怎么设计？ 数据流转关系图 扩展性保证 扩展组件，当前数据结构层面可扩展，组件库层面扩展 组件库是独立的，按照已有组件规范方便扩展 数据结构上，也可以保证组件扩展 扩展编译器的功能，例如：组件隐藏、锁定、滑动翻页等，前两者在VNode中添加属性即可 扩展页面配置，vuex store setting 开发提效 脚手架 组件平台 运维保障 （后续补充） 线上服务和运维服务用什么 安全 监控和报警 服务扩展性：流量大时怎么解决 大厂自研，小厂使用第三方云服务，后续补充第三方云服务使用 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jolly_chen/02-脚手架架构设计和框架搭建笔记.html":{"url":"pages/jolly_chen/02-脚手架架构设计和框架搭建笔记.html","title":"脚手架架构设计和框架搭建笔记","keywords":"","body":"站在前端研发视角，分析开发脚手架的必要性 架构师视角：开发脚手架的目标是什么，能带来什么价值 开发脚手架的核心目标是： 提升前端研发效能 开发过程的共有操作 创建项目 创建项目一般都会有通用代码 git操作 创建仓库、处理代码冲突、同步远程分支、创建版本、发布后的tag等，耗时耗力 构建和发布上线 本地构建、资源发布到静态资源服务器、同步CDN、域名绑定、区分正式和测试服务器，人为操作耗时多 解决上述问题，即可提效。突出脚手架的核心价值 脚手架的核心价值 将研发过程： 自动化 从创建项目到git操作，到发布上线的自动化，减少人工的耗时 标准化 交给脚手架完成共有操作，可以统一代码风格，规避git flow混乱：杂乱无章的commit。统一发布和回滚流程 数据化 统计脚手架创建项目、git操作、构建和发布的时间，可以对研发过程进行优化。可以把研发过程保存下来 和自动化工具的区别 不满足需求。jenkins/travis通常需要在git hooks中触发，负责云构建，不能覆盖开发人员本地功能 定制复杂。jenkins、travis定制过程需要开发插件，开发过程复杂，且使用java语言，对前端开发人员不够友好 从使用的角度理解什么是脚手架 脚手架简介 脚手架是操作系统的客户端。只不过它是通过命令执行： vue create vue-test-app 上面命令由3部分组成： 主命令：vue command：create command 的 param：vue-test-app 命令表示创建一个vue项目，项目名为vue-test-app vue create vue-test-app --force 创建项目并覆盖已有同名目录。--force 称为option。用来辅助脚手架确认在特定场景下，用户的选择。 vue create vue-test-app --fore -r https://registry.npm.taobao.org 这里-r 也是option，--registry的简写。-r https://registry.npm.taobao.org 后面的https://registry.npm.taobao.org 是-r 的param. --force简写是 -f 。 --force 也有param：--force -f 是 --force true 的缩写。 脚手架执行原理 vue create vue-test-app 命令干了些啥？ 终端在环境变量中找到vue指令，which vue 指令寻找（mac系统下）本机运行which vue的到结果： /usr/local/bin/vue 进入node路径，图1，关注bin和lib文件夹(本机是进入/usr/local/ )，进入bin路径后，ls -la得到vue信息：lrwxr-xr-x 1 root wheel 39 9 19 15:15 vue -> ../lib/node_modules/@vue/cli/bin/vue.js 得到vue是一个指向/usr/local/lib/node_modules/@vue/cli/bin/vue.js 的软连接 图1：bin文件夹中是软链接。lib中是软链接指向的全局文件（npm包） 以上，实际执行的是/usr/local/lib/node_modules/@vue/cli/bin/vue.js 文件。解析command后调用相应方法(create)执行。 执行过程图解： 终端中输入 vue create vue-test-app 终端解析出vue 命令 终端在环境中找到vue 命令（使用which vue指令） 终端根据vue 命令链接到实际文件vue.js 终端利用node 执行vue.js vue.js解析command /opiton vue.js执行command (对应的方法) 执行完毕，退出执行 开发脚手架的步骤 以 vue-cli 为例 创建npm项目mkdir vue-cli && cd vue-cli && npm init -y 项目中包含bin/vue.js 文件，package.json 配置： \"bin\": { \"vue\": \"bin/vue.js\" } 最后，把项目发布到npm。 将 vue-cli 安装到 node 的 lib/node_modules 中：npm i -g @vue/cli 在 node 的 bin 目录下配置 vue 软链到 lib/node_modules/@vue/cli/bin/vue.js 。这一步，npm安装时自动完成。 unix 系统 只配置一个软链文件 vue windows 中会生成两个文件： vue.cmd 和 vue ，前者在 cmd, PowerShell 等 windows 环境的命令行工具中执行；后者在 Git 等 unix 模拟环境的命令行工具中执行。使用记事本编辑 vue.cmd 中追加： @echo off echo 'cmd' vue 中追加： echo 'unix' 分别在 cmd, powershell, Git 命令行工具中运行，可看出区别。 windows 下的 bin 配置 vue.cmd @IF EXIST \"%~dp0\\node.exe\" ( \"%~dp0\\node.exe\" \"%~dp0\\node_modules\\@vue\\cli\\bin\\vue.js\" %* // 猜测使用当前目录(%~dp0)的 node.exe 执行后面的 js 文件 ) ELSE ( @SETLOCAL @SET PATHEXT=%PATHEXT:;.JS;=;% node \"%~dp0\\node_modules\\@vue\\cli\\bin\\vue.js\" %* // 使用 node 命令执行，后面的 js 文件 ) vue #!/bin/sh // 执行 sh 文件，sh 是链接到 bash 的 basedir=$(dirname \"$(echo \"$0\" | sed -e 's,\\\\,/,g')\") case `uname` in *CYGWIN*) basedir=`cygpath -w \"$basedir\"`;; // CYGWIN 一种 unix 模拟环境 esac if [ -x \"$basedir/node\" ]; then \"$basedir/node\" \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" // 猜测使用当前目录(%~dp0)的 node.exe 执行后面的 js 文件 ret=$? else node \"$basedir/node_modules/@vue/cli/bin/vue.js\" \"$@\" // 使用 node 命令执行，后面的 js 文件 ret=$? // return fi exit $ret 尚不清楚，windows 下，是怎么查找这两个文件的，但是，这俩个文件中，明确的标出了 vue.js 的位置，和执行方式。 需要解决的问题 为什么全局安装 @vue/cli 后会添加的命令为vue？ package.json 中bin 配置了key vue，npm 全局安装时，会根据这个配置生成软链接。 全局安装@vue/cli 时发生了什么？ 全局安装@vue/cli时 下载npm包到全局的node_modules文件夹下 按package.json 中bin 的配置，生成软链接 为什么vue 指向一个js 文件，我们却可以通过vue 命令直接执行它？ vue.js 文件第一行添加#!/usr/bin/env node 告诉操作系统，在直接打开文件时，从环境变量中找寻node 命令，使用 node 执行文件。/usr/bin/env 在终端中打印出来的是环境变量。 windows 中，使用 set 命令打印环境变量；set path 打印环境变量 path npm 按照package.json 中bin 的配置，生成了软链接vue 指向了vue.js 。所以输入vue 就可以执vue,js 。 涉及到的bash命令 chmod 777 filename 可以将文件改为可执行文件 drwxr-xr-x 最后一个x 表示这是一个可执行文件 echo $PATH 打印环境变量 手动创建软连接 创建软连接指向js：在node bin目录下，运行命令 ln -s js路径 name。之后可以在任何位置，执行name 命令 脚手架原理进阶 为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？ 因为node是操作系统的客户端，不是编写的对应脚手架js文件是客户端。区别是没有gui，node是通过命令行方式，传入参数执行 如何为node脚手架命令创建别名？ 相当于为现有的vue 这个命令在添加个别名：新建软连接指向他就好了。在node/bin 下执行：ln -s /vue vue2 即可使用vue2 指向vue 。windows 系统是通过新建快捷方式创建 描述脚手架命令执行的全过程： 脚手架的开发流程 开发流程 创建npm 项目 创建脚手架入口文件，最上方添加： #!/usr/bin/env node 配置package.json ，添加bin 属性 编写脚手架代码 将脚手架发布到npm 安装使用 作业1 安装 npm i -g jolly-test 使用 $ jolly-test -V 1.0.1 $ jolly-test --version 1.0.1 $ jolly-test init test --option 执行init流程 test --option 脚手架开发难点 分包：将复杂的系统拆分成若干个模块 命令注册，使用若干命令实现对应功能 vue create vue add vue invoke 参数解析 vue command [options] 主命令、command、带params的options等 options有全称 --version 有简写-v -h 怎么实现 帮助文档 Global help (针对主命令) Usage Options Commands jolly@JollydeMacBook-Pro % vue -h Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. 还有 交互式命令行 日志打印 命令行文字颜色变化 网络通信：HTTP/WebSocket 文件处理 ...... 脚手架本地调试 没有分包的本地调试 假定在开发jolly-test脚手架，要本地调试jolly-test命令 在package.json 所在目录下npm link 此时会按照 package.json 中bin 配置在/usr/local/bin 中生成软链jolly-test（bin 配置的） 先指向/usr/local/lib/node_modules/jolly-test，这也是一个软连接 /node_modules/jolly-test 指向项目的本地实际路径 在package.json 所在目录的上级npm i -g 文件夹名 也可以实现npm link 的效果。唯一的区别在于node_modules 中软链指向的地址写法：npm link node_modules 中软链指向的地址是绝对路径： lrwxr-xr-x 1 jolly wheel 37 1 10 20:42 jolly-test -> /Users/jolly/Desktop/imooc/jolly-test 而npm i -g jolly-test node_modules 中软链指向的地址是相对路径： lrwxr-xr-x 1 jolly wheel 48 1 10 16:24 jolly-test -> ../../../../Users/jolly/Desktop/imooc/jolly-test 分包的本地调试 假定开发jolly-cli，和jolly-utils位于jolly-cli-dev文件夹下。jolly-cli引入依赖jolly-utils 首先在jolly-utils中npm link 放到全局node_modules 文件夹下， 然后在jolly-cli 运行指令npm link jolly-utils，并在 package.json 中手动配置依赖。 npm package 的形式之一，就是本地的某个文件夹。所以npm 提过如下写法，支持本地包的引入（jolly-cli引入依赖jolly-utils） \"dependencies\": { \"@jolly-cli/utils\": \"file:../utils\" }, ​ 配置之后，需要 npm install（存在一个现象，自用mac上， npm link 也能更新依赖，包括安装非本地依赖。之后验证吧），但发布时需要具备像lerna publish 将本地连接解析成线上连接的功能对依赖进行处理。 本地调试后发布上线 使用npm link 的要先npm unlink，然后 没有本地分包调试的，可以直接发布了 有本地分包的，如开发jolly-cli ，应先在 jolly-cli 中npm unlink jolly-utils , 这时package.json 中对应依赖会被移除。然后回到 jolly-utils 中 npm unlink 并先对 jolly-utils 进行发布。发布成功之后，在 jolly-cli 运行 npm i -S jolly-utils 安装依赖，再对 jolly-cli 进行发布。 通过 \"file:../utils\" 引入依赖的，要使用 lerna publish 进行发布。 npm link & npm unlink npm link npm link 将当前项目链接到 node 全局 node_modules 中作为一个库文件，并解析 bin 配置创建可执行文件 npm link your-lib 将当前项目中 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件 npm unlink npm unlink 将当前项目从 node 全局 node_modules 中移除 npm unlink your-lib 将当前项目中的库文件依赖移除 脚手架命令注册和参数解析 不使用第三方库进行解析 使用 node process 模块。process 是 node 的进程事件，process.argv 属性会返回一个数组，其中包含当 Node.js 进程被启动时传入的命令行参数。第一个元素是 process.execPath（启动 Node.js 进程的可执行文件的绝对路径名）。 第二个元素是正被执行的 JavaScript 文件的路径。 其余的元素是任何额外的命令行参数。 下图是输入 imooc-test init 后的 process.argv 使用lerna进行脚手架开发 lerna 是一个优化基于 git + npm 的多 package 项目的管理工具 lerna解决的问题 大型项目、多 packages 的重复操作 本地分包之间的link 依赖安装 单元测试 代码提交 所有 package 提交到一个仓库 代码发布 每一个 package 都要发布成独立的 npm 包，version 升级 大型项目、多 packages 的版本一致性 发布时版本一致性 packages 之间版本一致，只需保证一个版本下的 packages 可以协同工作即可，不必考虑向下兼容 发布后相互依赖的版本升级 一个包升级后，依赖这个包的其他包，也要进行升级 leran 提升操作的标准化 标准的发布流程：发布前的 bump version，检查代码是否提交了，生成仓库的 tag 标签等，最后进行 npm 发布 lerna与架构 lerna 是一个架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 标椎化带来的好处是减少出错，减少排查错误的成本。 lerna 开发脚手架流程 紫色为常用命令 创建 npm Organazition pakage.json 中 name 以 @ 开头，说明是个 group ，需要先注册一个 group ，否则后面没法发布和获取 添加 Organization 点击 add Organization 创建 group 创建后，在packages中查看 创建 lerna repo npm i -g lerna mkdir lerna-test && lerna-test npm init -y lerna init npm i lerna 命令解释 lerna init 直接运行，没有参数。创建一个lerna仓库(lerna repo)，生成 lerna.josn 并且在 package.json 中写入开发依赖 \"devDependencies\": { \"lerna\": \"^3.22.1\" } lerna create packageName [location] 创建新的 package 并根据交互命令行输入生成 package.json；可以指定路径。 lerna create get-npm-info ./utils/get-npm-info lerna add lerna add [@version] [--dev] [--exact] [--peer] 向packages添加依赖，不传package，表示向所有package添加依赖。 是路径，不是包名 lerna add axios utils/get-npm-info 一次只能添加一个包，使用 npm 安装多包的写法，只会安装第一个 npm link 后的包，在 lerna add 后，要重新 npm link，不然会报错。这是坑 lerna link 将相互依赖的本地包进行链接 lerna exec 对每个package执行任意 shell 命令，上下文在package文件夹中 lerna exec -- rm -rf ./node_modules lerna exec --scope @imooc-cli-dev/core（包名） -- ls -la 通过 --scope 指定包名，对特定包执行 shell 脚本 lerna run 执行存在于每个包中的 npm script lerna run test lerna run --scope @imooc-cil-dev/utils test 通过 --scope 指定包名，对特定包执行 npm 命令 lerna clean 删除所有packages的node_modules目录，但是不会修改package.json的依赖，且始终不会删除根目录下的 node_modules 中的文件夹 lerna boorstrap 安装 lerna repo 中所有包的依赖，包括包与包的相互依赖 lerna version bump version。1.0.1 -> 1.0.2 / 1.1.0 ... lerna changed 表示自上一个版本，有哪些package做了变更 lerna diff 检查做出的修改，前提是有提交仓库或者有git commite lerna publish 发布 npm 包，登录部分，跟 npm publish 一致。 lerna项目发布问题说明 在发布之前，确保已经初始化了git仓库 lerna version leran version bump 版本号后，会提交到远程仓库，并在远程上产生一个tag。leran version 成功之后，是不能lerna publish 发布成功的，会说没有修改 lerna publish 如果要发布，不要先使用lerna version 。提交完之后，直接使用lerna publish 第一步就会 bump 版本号。 删除多余或者调试产生的tag的方法，大胆调试发布流程 先在远程上删除tag 在本地仓库根目录中，找到文件夹./git/refs/tags 中删除之前在远程上删除的tag 接下来，就可以手动修改lerna.josn中的version，使用一个没有发不过的较低的版本号 lerna publish 了 使用 group 发布的包，默认情况都是私有的，publish不了。需要在 package.json 中追加配置 \"publishConfig\": { \"access\": \"public\" } lerna publish 成功之后的日志 lerna 源码阅读 准备源码 准备工作 下载源码 安装依赖 IDE打开 准备完成的标准 找到入口文档 能够本地调试 学习目标 lerna 源码结构和执行流程 import-local 源码学到的知识点 require('.') === require('./') npm file: 接相对路径的处理 commands/publish/index.js resolveLocalDependencyLinks() 将本地连接解析成线上连接。 yargs 用法 yargs 可以用来帮助构建交互式命令行工具，解析参数、生成优雅的用户界面。 基本使用： #!/usr/bin/env node const yargs = require('yargs/yargs'); const { hideBin } = require('yargs/yargs'); // 用作参数解析 const arg = hideBin(process.argv); // 获得参数列表(Array) yargs(arg) .argv; Api解读 yargs(arg).strict() 在输入的命令找不到时，报错。默认会输出 --help 的内容及默认报错 yargs(arg).usage(msg) 展示命令的用法。可以理解成，输出msg yargs(arg).usage('Usage: $0 [option]') $0 指向的是 command 。如本地开发一个 yargs-test 命令行工具，输入 yargs-test ls argv: { _: [ 'ls' ], cliVersion: '1.0.0', '$0': 'yargs-test' } yargs(arg).demandCommand(1, '最少需要一个命令') 表示最少需要几个命令，不需要有 .strict() 的调用 yargs(arg).recommendCommands() 直接调用，输入错误时，提示最近似的命令 yargs(arg).alias('h', 'help') 为命令设置别名，为 --help 使用别名 -h yargs.wrap(yargs(arg).terminalWidth()) 设置脚手架输出的命令行宽度。yargs(arg).terminalWidth() 表示终端的宽度。整体表示占满整行 yargs(arg).epilogue('msg') 在结尾输出信息 dedent npm 包去掉行缩进或者行首空格，不会去掉空行。使用方式： dedent` 111 111` dedent(`111 111`) yargs(arg).options(obj) 增加一个全局选项，所有 command 都能访问。添加一个 --debug option yargs(arg).options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode' } }) 更多命令可以从参考 yargs github yargs(arg).option('opt', obj) 和 yargs(arg).options(obj) 作用一样，只不过一次只能添加一个全局命令 yargs(arg).group(Array, str) 为命令分组，在 --help 显示时，分组显示命令。参数是一个 option 数组，第二个参数是分组名 yargs(arg).command(cmd, desc, [builder], [handler]) 注册命令，lerna --option 中的 --option，这个方法很重要 cmd 是 command 的格式 desc 是 cmd 的描述 builder 函数，在执行命令之前执行 handler 函数，command 的行为 npm 上的例子 #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') yargs(hideBin(process.argv)) .command('serve [port]', 'start the server', (yargs) => { yargs .positional('port', { describe: 'port to bind on', default: 5000 }) }, (argv) => { if (argv.verbose) console.info(`start server on :${argv.port}`) serve(argv.port) }) .option('verbose', { alias: 'v', type: 'boolean', description: 'Run with verbose logging' }) .argv .positional() 为 command 定义参数，和 .option() 类似，但只在 builder 函数中的 yargs 实例上存在。 lerna 中 command 的对象传参 yargs(arg).commamd({ command, alias, describe, builder, handler }) 更多 yargs(arg).fail(err, msg) 处理在命令执行失败时的操作，需要先调用 .strict() yargs().parse(argv, obj) 参数解析。argv 是 process.argv.slice(2)，和直接传入个 yargs() 的argv 不同—hideBin(process.argv)， 命令行输入的 command 后面的 option ，该方法会将 argv 和 obj 进行合并，可以向 argv 中注入参数 这里有个地方要注意 let context = { otherVersion: pak.version } yargs().parse(argv, context) context 中的版本号 key 不要用 version，否则输入命令是，将始终执行 --version。总之，就是不要使用跟命令重复的 key lerna 命令的执行流程 执行 lerna ls ： 入口文件 core/lerna/cli.js 获取命令号 option argv = process.argv.slice(2) 调用 core/lerna/index.js mian(argv) 方法 在 mian(argv) 方法，根据 option ls 执行对应的.command()：commands/list/commond.js 执行 .command() 中的 handler ：commands/list/index.js factory(argv) 知识点 深拷贝，使用 npm 包 clone-deep this.constructor.name runner Promise.then 微任务执行栈 Promise.resolve 方法允许调用时不带参数，直接返回一个resolved 状态的 Promise 对象。 import-local 用途：当全局 node_modules 和 当前项目 node_modules 当中同时存在一个脚手架命令时，优先使用当前项目的脚手架。在 lerna 项目下，执行命令 lerna ls，会输出 info cli using local version of lerna jolly@JollydeMacBook-Pro lerna % lerna ls info cli using local version of lerna lerna notice cli v3.22.1 @lerna/add @lerna/bootstrap @lerna/changed @lerna/clean @lerna/create const localFile = resolveCwd.silent(path.join(pkg.name, relativePath)); 上面这句话，是 import-local 中的核心，作用是查看当前项目中有没有对应的 npm 包 path.relative(localFile, filename) 找到和本地文件 localFile 同名的全局的文件的路径。 细节 全局加载执行本地 cli.js 和执行后续 lerna 流程，都是在全局 cli.js 中 require(\"npmlog\").info(\"cli\", \"using local version of lerna\"); 代码之前，但 info cli using local version of lerna 会先打印，是因为 command 方法的 handler 中，代码执行都是通过 Promise.resolve().then() 添加到微任务中的，所以会在宏任务 `require(\"npmlog\").info() 执行之后执行。 基础知识点 __filename：当前模块(js)的文件名。 这是当前的模块文件的绝对路径（符号链接会被解析） 运行 node 代码时，默认会注入 module require __filename __dirname exports 五个变量 优秀的文件操作库 pkg-dir 找到 npm 或者 node.js 项目的根目录 findup 通过遍历父级目录查账文件或文件夹 locate-path 从多个文件中获取第一个存在的路径 path-exists 检查路径是否存在 resolve-cwd 从当前工作目录，像 require.resolve 一样解析模块路径 resolve-from 从给定路径，像 require.resolve 一样解析模块路径 涉及到的 node.js 方法 process.cwd() 返回 Node.js 进程的当前工作目录(working directory)。 path.dirname() path.resolve() 相对路径转换成真实路径 path.parse() fs.accessSync(filepath) 判断文件是否存在（能访问到），不存在会抛出异常 path.relative() path.join() Node.js 模块路径解析流程 Node.js 项目模块路径解析是通过 require.resolve 方法来实现的 require.resolve 就是通过 Module._resolveFileName 方法实现的 Module._resolveFileName 方法核心流程有 3 点： 判断是否为内置模块 NativeModule.canBeRequireByUsers() 判断是否是可以被加载的内置模块 通过 Module._resolveLookupPaths 方法生成 node_modules 可能存在的路径 如果路径为 /（根目录），直接返回 ['/node_modules'] 否则，将路径字符串从后往前遍历，查询到 / 时，拆分路径，在后面加上 node_modules，并传入一个 paths 数组，直至查询不到 通过 zModule._findPath 查询模块的真实路径 Module._findPath 核心流程有 4 点： 查询缓存（将 request 和 paths 通过 \\x00 合并成 cacheKey） 遍历 paths，将 path 与 request 组成文件路径 basePath 如果 basePath 存在则调用 fs.realPathSync 获取文件真实路径 将文件真实路径缓存到 Module._pathCache（key 就是前面生成的 cacheKey） fs.realPathSync 核心流程有 3 点： 查询缓存（缓存的 key 为 p，即 Module._findPath 中生成的文件路径） 从左往右遍历路径字符串，查询到 /时，拆分路径，判断该路径是否为软链接，如果是软链接则查询真实链接，并生成新路_径 p，然后继续往后遍历，这里有 1 个细节需要特别注意： 遍历过程中生成的子路径 base 会缓存在 knownHard 和 cache 中，避免重复查询 遍历完成得到模块对应的真实路径，此时会将原始路径 original 作为 key，真实路径作为 value，保存到缓存中 require.resolve.paths 等价于 Module._resolveLookupPaths ，该方法用于获取所有 node_modules 可能存在的路径 图中知识点列表： 通过 require 加载模块以后，会向 Module._pathCache 对象中添加该模块的路径，key：模块名称加 \\x00 路径，value：实际路径 stat(path) ：查看文件状态。-2 不存在， 0 文件，1 文件夹 realPathCache 是一个 Map 对象 linux stat 命令打印文件相关信息 dev_t 设备编号、ino_t 文件的唯一标识 fs.realPathSync 在拿到软连接指向的真实路径后，还会在遍历，查看指向的路径是否还是一个软连接 正则表达式 Modules._findPath() 中的正则 /(?:^|\\/)\\.?\\$/ 匹配 ..、/..。包含知识点 ? 匹配0到1个 (?:) 表示非匹配分组，作用是不保存括号中匹配的内容 /^/ 匹配的是个空字符串''，任意字符都能匹配成功，任意字符中都有空字符串 /[^]/ 表示非 简历和总结 简历要有“简历简介” 面试官询问细节的回答 yargs 开发脚手架 阐述脚手架命令构成 command：命令 vue option 及 param js 文件顶部 阐述脚手架初始化流程 package.json 中配置 bin 属性，npm link 本地安装，生成脚手架命令行 #! /usr/bin/env node yargs() 介绍一下常用方法 脚手架参数的解析 hideBin(process.argv) / Yargs.argv Yargs.parse(argv, options) 命令的注册 Yargs.command(command, describe, builder, handler) Yargs.command({ command, describe, builder, handler }) lerna Lerna 是基于 git+npm 的多package 项目管理工具 实现原理 通过 import-local 优先调用本地 lerna 命令 通过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数 lerna 命令注册时需要传入 builder 和 handler 两个方法，builder 方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑 lerna 通过配置 npm 本地依赖的方式来进行本地开发，具体写法是在 package.json 的依赖中写入：file:your-local-module-path ，在 lerna publish 时会自动将该路径替换 Node.js 模块路径解析流程 见上 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:41 "},"pages/jolly_chen/javascript事件循环.html":{"url":"pages/jolly_chen/javascript事件循环.html","title":"Javascript事件循环","keywords":"","body":"EventLoop 之所以称之为 事件循环，是因为它经常按照类似如下的方式来被实现： while (queue.waitForMessage()) { queue.processNextMessage(); } queue.waitForMessage() 会同步地等待消息到达(如果当前没有任何消息等待被处理)。 一个 EventLoop 中，可以有一个或多个任务队列。一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务。 文章链接 任务队列 宏任务 (macro)task (macro)task主要包含：script(整体代码)、setTimeout、setInterval、I/O、UI交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务 microtask microtask主要包含：Promise.then、MutaionObserver、process.nextTick(Node.js 环境) Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第七周 B端需求分析和架构设计学习笔记.html":{"url":"pages/jolly_chen/第七周 B端需求分析和架构设计学习笔记.html","title":"第七周 B端需求分析和架构设计学习笔记","keywords":"","body":"复杂项目的定义 从两个维度审视项目复杂度 业务交互的复杂度 交互的复杂性 数据结构和状态的复杂性 多项目互相依赖的复杂性 针对不同项目（web还是liabrary）怎样完成打包 性能优化。大型项目的要点，省的流量就是公司的真金白银 第三方库的调研，使用以及二次开发 流程的复杂度 git flow 标准的 lint 工具 单元测试 代码提交的 commit 信息 PR review - 工程师之间互相交流和学习的重要步骤 CI/CD 持续集成和部署 技术解决方案 复杂项目，在需求分析之后，是技术解决方案的编写。技术方案的编写，可以理清思路，预先解决项目中可能存在的难题。解决这些难点就是技术方案设计的归宿。分析项目中的难点继而成为架构师的必要能力。 总览的技术设计文档，要站在一定的高度，指引项目的大体流程。至于项目具体功能的具体解决方案，届时在写具体的设计文档。 技术方案的内容是，怎样实现需求中的功能，没有固定格式。 B端需求实现的难点 难点分析 实现B端功能的难点，显而易见，是在编辑器。 怎样实现组件 跨项目使用 组件的可扩展性 编辑器的整体状态 编辑器做的功能，其实就是对一系列组件增删改查操作 元素的增加和删除 元素属性的修改（核心） 属性渲染成表单 实时反馈 核心之外问题的解耦 插件化 拖动 快捷键 右键菜单 缩放 重做和回滚 项目开发要有“前戏” 对于复杂项目，在项目前期，要有像上面的一个思考的过程，并试图找出这些问题的解决方案，争取满足项目的可扩展性、功能的解耦及易维护性等，降低开发和维护成本。 组件库难点和解决方案 两个项目怎样重用组件 两个项目：pc端编辑器和H5端 单独的代码库 在不同的项目中重用组件，自然把这些组件抽象成一个代码库，降低和任何一个项目的耦合性，单独代码库让业务组件有独立的标准开发流程： 编码 测试 打包生成通用 JS 模块 发布至 NPM CI/CD - 自动发布 组件库的设计原则 业务组件库大多都是展示型组件，在不同端进行展示，会有少量的行为，如点击跳转。所以，设计原则是从简，必须避免和编辑器编辑流程的耦合 组件命名 LText 或 l-text 组件属性如何设计 业务组件属性从功能上，可以分为 样式属性 其他属性 两种实现： // 方案一 // 内部实现 // 方案二 将所有的属性全部平铺传入 // 内部实现 const styles = stylePick(props) 方案一 内部实现简单 数据要多有一层结构：class.css 保存数据时 区分样式属性和其他属性 样式属性要深入 css 对象进行处理 其他属性在外层处理 方案二 内部实现复杂 保存数据简单 数据更新容易 选择方案二。 从个性上，可分为 独有属性 文本组件独有 图片组件独有 共有属性 实现： // 用户点击 export userClick(props) 组件扩展性的保持 后续 编辑器难点和解决方案 编辑器页面结构 不包括其他功能：预览、保存、发布等 左侧组件模版库 预设各种组件模板并进行添加 中间画布 使用交互式的手段更新元素属性 右侧表单设置页面 使用表单更新元素属性 添加模板组件到画布 编辑器的核心功能，就是围绕中间画布进行一系列操作，编辑最终效果，作用在数据上：对组件数据的增删改查。 伪代码诠释实现流程 // 以下代码以后都可能修改 export interface EditorStore { components: ComponentData[] // 其他状态相关信 // 其他状态相关信关息 currentElement: string // uuid // ... } interface ComponentData { props: { [key: string]: any }; id: string; name: string } const components = [ {id:'1', type: 'l-text', props: {text: 'hello', color: 'green'}}, {id:'2', type: 'l-text', props: {text: 'world', color: 'purple'}} ] components.map(component => ); // 左侧模板 const templateComponents = [ {id:'1', type: 'l-text', props: {text: '模板一', color: 'green'}}, {id:'2', type: 'l-text', props: {text: '模板二', color: 'purple'}} ] templateComponents.map(component => ); // 添加组件 components.push({id:'3', type: 'l-text', props: {text: '!', color: 'red'}}) // 删除组件 components.filter(component => component.id !== delId); 组件属性和表单的关系 技术选型 首先要确定最上层使用什么 ，才能根据上层确定下层适配的技术 Typescript 使用 Typescript 开发大型项目 程序更容易理解 效率更高 方便代码库及定义之间的跳转（查找定义） 代码补全 接口提示 更少的错误 在运行之前，及时发现错误 很好的避免读取 undefined 上的属性或方法 良好的包容性 js 文件可以直接命名为 ts 文件运行 可以为非 ts 编写的三方库编写类型文件进行读取 Vue 和 React React 代码实现风格 将组件抽象成函数，函数型组件 组件是一个返回特定界面的函数 hook 使函数式变成，大行其道 数据更新机制 使用 immutable 方式，调用特定 useState hook函数更新界面 代码重用性 React hooks 最大的创新，它可以使用给定的 hooks 抽象成一系列的函数，在组件内部使用函数调用的方式来重用逻辑，非常符合正常的思维，也能了解重用逻辑代码的来源和返回。 import React, { useState, useEffect } from \"react\"; import \"./styles.css\"; import useMousePosition from \"./useMousePosition\"; export default function App() { const [count, /* useState hook */ setCount] = useState(0); const positions = useMousePosition(); // hooks 函数 useEffect(() => { alert(count) }, [count]) return ( Hello CodeSandbox {count} setCount(count + 1)}> Add Count {positions.x} {positions.y} ); } Vue 代码实现风格 单文件组件：模板、数据、样式三者放到一个 vue 文件中 数据更新机制 响应式数据。直接修改数据，就可以更新界面，更符合程序员思考模型 代码重用性 vue3 推出 composition api , 类似 React hooks 系统。将逻辑抽象为函数，组件内部调用函数获得结果。 Hello CodeSandbox {{ count }} Add Count {{ x }} {{ y }} import { ref } from \"vue\"; import useMousePostion from \"./useMousePosition\"; // 代码复用 export default { name: \"App\", setup() { const count = ref(0); const addCount = () => { count.value++; }; const { x, y } = useMousePostion(); return { count, addCount, x, y, }; }, }; #app { font-family: Avenir, Helvetica, Arial, sans-serif; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; text-align: center; color: #2c3e50; margin-top: 60px; } 技术选型说明 知识点 alibaba/form-render 老师用到的工具 协同工具: https://whimsical.com 代码高亮编辑器: https://carbon.now.sh/ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第三周 Node支持ES Module.html":{"url":"pages/jolly_chen/第三周 Node支持ES Module.html","title":"第三周 Node支持ES Module","keywords":"","body":"Node 支持 ES Module 的解决方案 webpack 配置 target: 'node' 时，才会引入 path 等 node 内置库 垫片 JS垫片就是，在低级环境中用高级语法时，在低级环境中手动实现该高级功能，模拟高级环境。形象的解释：垫片的作用就是，使四只脚不一样长的桌子变得平稳，为什么不平稳，因为每个脚的js语法版本不一样。 @babel/plugin-transform-runtime 的作用是，提供“垫片”，例如 regeneratorRuntime 的“垫片” -- regeneratorRuntime 的实现。以下错误是因为缺少 @babel/plugin-transform-runtime 插件。 webpack://Node_ES_Module/./core/index.js?:17 _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee() { ^ ReferenceError: regeneratorRuntime is not defined babel 的配置 还需要安装 @babel/runtime-corejs3 库 use: { loader: 'babel-loader', options: { presets: [ '@babel/preset-env' ], plugins: [ ['@babel/plugin-transform-runtime', { corejs: 3, regenerator: true, useESModules: true, helpers: true }] ] } }, Node 原生支持 将要执行的 js 文件和其依赖的 js 文件后缀改为 mjs 使用以下命令执行 node --experimental-modules index.mjs node 14 之后默认支持 ES Module，直接执行以下命令即可，不需要option --experimental-modules node index.mjs Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第三周 commander使用.html":{"url":"pages/jolly_chen/第三周 commander使用.html","title":"第三周 Commander使用","keywords":"","body":"commander 库使用 基本代码 #! /usr/bin/env node const commander = require('commander'); const pkg = require('./package.json'); // 获取 commander 单例 // const { program } = commander; // 实例化一个 Command 实例 const program = new commander.Command(); program .version(pkg.version) .parse(process.argv); // 跟 yargs 不一样的参数传入 常用方法 program.usage(' [options]') 说明脚手架命令的用法，不用像 yargs 一样获取命令名字 $0 ，这个方法自动带上脚手架命令 program.name() 指定命令的名字，会打印在usage 方法输出的信息前 program.option() 定义全局 option。参数是 option 名字、描述、默认值。yargs.option('optName', obj) program.option('-d --debug', '是否开启调试模式', true); // 直接指定了简写和全称 program.option('-e, --env ', '获取环境变量') // 配置带参数的option program.parse(process.argv) 命令行参数解析 program.arguments() 设置命令参数 注册命令的两种方式 program.command() 注册的是命令 返回新的对象：命令对象 参数说明： 第一个参数可以配置命令名称及命令参数，参数支持必选（尖括号表示）、可选（方括号表示）及变长参数（点号表示，如果使用，只能是最后一个参数） 基本用法 const clone = program.command('clone'); clone .description('clone a repository') .action(() => { console.log('do clone'); }); program.addCommand() 注册的是子命令。子命令下，又要注册新的命令。所以这个方法相当于分组 const service = new commander.Command('service'); // 子命令 service .command('start [port]') // 返回命令对象，不再是 service .description('start service at some port') .action(port => { console.log('do service start', port); }); // 回调函数接收的参数：第一个到第n个是命令的参数，n+1位是option，最后是command命令本身 program.addCommand(service); 两个命令帮助说明上，是有区别的 clone -h % comm-test clone -h Usage: comm-test clone [options] [destination] clone a repository Options: -f, --force 是否强制克隆 -h, --help display help for command service -h % comm-test service -h Usage: comm-test service [options] [command] Options: -h, --help display help for command Commands: start [port] start service at some port stop stop service help [command] display help for command 备注：program.parse(process.argv) 要放在添加命令逻辑之后 commander 厉害的功能 自动匹配所有输入的命令 使用 program.arguments() program .arguments(' [options]') // 强制输入一个命令 .description('test command', { cmd: 'command to run', options: 'options for command' }) .action((cmd, options) => { console.log(cmd, options); // 对任何命令做出行为 }); program.command() 的第二个参数：描述参数 当.command()带有描述参数时，就意味着使用独立的可执行文件作为子命令。Commander 将会尝试在入口脚本（例如 ./examples/pm）的目录中搜索 program-command 形式的可执行文件，例如 pm-install, pm-search。通过配置选项（第三个参数） executableFile 可以自定义名字。可执行文件：pm.js program-command.js program .command('install [name]', 'install package') // 使命令 install 出现在 --help 信息中 .alias('i') 输入 comm-test i comm-test i s /Users/jolly/Desktop/imooc/commander-test/node_modules/commander/index.js:925 throw new Error(executableMissing); ^ Error: 'comm-test-install' does not exist program.command() 的第三个参数：配置选项 多个脚手架之间的串行使用 program .command('install [name]', 'install package', { executableFile: 'npm', isDefault: true, hidden: true }) .alias('i') executableFile 使得 comm-test i === npm，后面输入的 option，如果 npm 有就执行 npm option: comm-test i -v === npm -v。如果npm 没有但当前脚手架有，就执行当前脚手架的 option。两者都没有，使用 executableFile 指定的命令报错，对于 npm 只是展示 npm 帮助信息，这是 npm 自己的逻辑决定的。 isDefaul: true 表示输入的 option 没有指定是，默认执行 executableFile 指定的命令 hidden: true 表示不再帮助信息中显示 高级定制 自定义help信息 program.helpInformation = function() { // return 'your help infomation\\n'; // 也可以在这里输出，不是很推荐 return ''; // 先去掉原来的help } program.on('--help', () => { console.log('your help infomation'); }) 实现debug模式 program.on('option:debug', () => { // 这里，使用 --debug 没有效果 if (program.opts().debug) { // 6.2.1 中可以用 program.debug 替换 process.env.LOG_LEVEL = 'verbose'; } }); 上述代码，会在命令执行前进行处理。 对未知命令监听 program.on('command:*', (obj) => { // 未知命令都会命中这里的监听 console.error('未知的命令：' + obj[0]); const availableCommands = program.commands.map(cmd => cmd.name()); console.log('可用命令：' + availableCommands.join(',')); }); 注意： 实现该功能，要注释掉 program.arguments() ，以及不让串行脚手架默认执行 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第三周 脚手架核心流程开发笔记.html":{"url":"pages/jolly_chen/第三周 脚手架核心流程开发笔记.html","title":"第三周 脚手架核心流程开发笔记","keywords":"","body":"前导 收获 如何做架构设计和技术方案设计 脚手架核心流程，通过 commander 完成脚手架框架搭建 如何让Node项目支持ES Module 主要内容 脚手架需求分析和架构设计 脚手架模块拆分策略和core模块技术方案 脚手架执行准备过程实现 脚手架命令注册实现（基于commander 库） 作业 绘制 imooc-cli 脚手架架构设计图 实现 imooc-cli 脚手架准备过程代码 通过 commander 框架实现一个脚手架，包括自定义 option 和 command 功能 通过 webpack 和原生两种方式实现 Node 对ES Module 的支持 注意事项 本周前半部分偏架构设计，是架构师日常工作 架构师应该把整体和局部想清楚在开始做 将代码实现细节抽象，通过系统论思想构建复杂系统： 建立子系统，关注子系统的输入和输出是什么。然后由子系统构建较复杂的系统，再由较复杂的系统构建更复杂的系统。 脚手架整体架构设计 大厂怎么做项目 设计阶段 搞清楚业务或研发过程中的痛点 -- 为什么有当前业务 由痛点形成需求 PD(产品) -> PRD文档（产品需求文档） 原型图 预期目标 PRD 评审 原型图评审 技术方案设计阶段，产生技术方案文档。确定需求在技术上的实现，及确定技术方案实现成本 技术选型 技术架构 -> 架构设计 API定义 技术调研 评估技术风险 成本可接受，项目立项 kick-off（启动） 确定项目成员：PD、PM(项目经理)、前端、后端、测试人员、设计等 项目排期（计划） 时间点 WBS 文档（工作分解结构） 实施阶段 软件类项目，交互/视觉设计，输出设计稿 开发，输出代码 前后端开发 联调 测试，输出测试报告 单元测试（开发人员） 功能测试（测试人员） 性能测试（测试人员） 交给产品或业务人员验收 微调 上线 痛点 创建项目/组件时，重复代码问题 协同开发时，git操作不规范问题 发布上线耗时，且容易出错问题 需求分析 通用的研发脚手架 通用的项目/组件创建能力 模块支持定制；定制后能快速生效 模板支持快速接入，极低的接入成本 通用的项目/组件发布能力 发布过程自动完成标准的git操作 发布成功后自动删除开发分支并创建tag 发布后自动完成云构建、OSS(静态资源服务器)上传、CDN上传、域名绑定 发布过程中支持测试/正式两种模式 大厂git操作规范 分支管理 master 不会再次基础上开发，仅用作代码同步：上线时，将 dev/0.0.1 push到master上，进行 merge 然后打上 release/0.0.1 tag dev 开发 dev/0.0.1 dev/0.0.2 release 发布 release/0.0.1 删除 dev/0.0.1 git操作流程 imooc-cli 架构图 脚手架的核心架构 脚手架初始化 完成整个执行流程 命令的执行 异常的监听 ...... 为什么需要后台 API 实现通用能力 接入外部项目 webSocket 服务 云构建 云发布 静态资源 组件构建结果 数据体系 MySQL 组件相关信息 MongoDB 项目模板 脚手架技术方案设计 脚手架拆包策略 参考 lerna 项目的拆包，根据模块的功能，将脚手架模块分为： 核心模块 -- core 命令 commands 初始化 发布 清除缓存 模型层 models Command 命令 Project 项目 Component 组件 Npm 模块 Git 仓库 支撑模块 utils Git 操作 云构建 工具方法 API 请求 Git API core 模块技术方案 实现命令的执行流程 准备阶段 检查root启动：避免权限问题。如果是root启动（mac root 用户登录），把权限降级到普通用户 检查用户主目录：要往主目录写入缓存。设计本地缓存体系中的本地文件 检查环境变量：本地缓存需要 检查是否为最新版本：检查cli版本 提示更新：更新cli 命令注册 命令执行 涉及技术点 核心库 import-local 优先执行本地脚手架 commander 实现命令注册 用到的工具库 npmlog 打印日志 fs-extra 文件操作。基于 fs 封装的 semver 版本比对。检查当前版本是否为最新版本 colors 控制终端文本颜色 user-home 获取用户主目录 dotenv 获取环境变量 root-check root 账户检查和自动降级 脚手架执行准备过程实现 require() 支持加载的资源类型 .js 必须使用 module.exports/exports 输出模块 .json 使用 JSON.parse() 方法对 json 文件进行解析，生成一个对象 .node .node 文件是 C++ 插件(C++ AddOns)，使用 process.dlopen() 打开 .any 当 .js 文件处理 使用 require() 加载一个内容为 javascript 代码的 .txt 文件，是可以执行成功的 require() 支持的路径 绝对路径 相对路径 node 内置对象 node_modules 中的包 npmlog 只能调用 log.addLevel() 添加的方法，进行日志输出 log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN') log.level 默认 level 为 info 级(2000)。低于这个级别的日志，不会被打印 // default level log.level = 'info' // …… log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb') log.verbose('test', 'msg') 默认下，本调用的也不会打印 log.heading 在 log 日志之前，添加前缀 通过 log.headingStyle 定义样式 检查root启动 process.geteuid() 返回 0， 代表超级管理员 返回501，代表登录用户 root-check 降级权限： var rootCheck = require('root-check'); rootCheck(); process.env.SUDO_GID 可以配置的登录用户分组id process.env.SUDO_UID 可以配置的用户标识id process.setgid(gid) 使用户所在的分组id process.setuid(uid) 设置用户标识id defaultUid() 返回平台的 用户标识 var DEFAULT_UIDS = { darwin: 501, // mac UNIX-like freebsd: 1000, // FreeBSD UNIX-like linux: 1000, sunos: 100 // Solaris 系统 } 检查用户主目录 path-exists 检查文件是否存在 user-home 获取用户主目录 os-homedir 源码 检查入参 在 debug 模式下，使用 log.verbose() 打印日志。但log.verbose() 打印日志，正常状态下，是不能打印的。所以这里我们需要解析参数，判断是否是 debug 模式。 minimist 库，解析参数。基本使用 const minimist = require('minimist'); const args = minimist(process.argv.slice(2)); console： args: { _: [], debug: true } 参数解析之后，要修改 log.LOG_LEVEL； 检查环境变量 dotenv 获取环境变量 在用户主目录下创建 .env 文件存储和读取环境变量 默认路径：path.resolve(process.cwd(), '.env') 当前文件夹下的 从 .env 环境中获得的值，放在了 process.env 中 const dotenvPath = path.resolve('path', '.env'); // 绝对路径 require('dotenv').config({ // 不传值表示使用默认路径读取 path: dotenvPath }) .env 文件中的配置：name=value 。没有 .env 要手动创建 DB_HOST=localhost DB_USER=root DB_PASS=s1mpl3 检查当前是否为最新版本 获取最新版本号和模块名 使用 npm API， 获取所有版本号 网址 仓库地址/npm包名 ，私有仓库也可以这样获取版本号 http://registry.npmjs.org/@jolly-cli/core http://registry.npm.taobao.org/@jolly-cli/core 使用的 chrome 插件 JSONView 提取所有版本号，比对哪些版本号是大于当前版本号 获取最新版本号，提示用户更新到该版本 有个坑 lerna create get-npm-info ./utils/get-npm-info 创建完包之后，包实际在 core 下面 lerna success create New package get-npm-info created at ./core\\get-npm-info url-join 库，将多个 url 碎片，拼接生成完整 url。 const urlJoin = require('url-join'); urlJoin('url', 'parturl'); 遇到的问题总结 npm link 报文件存在错误 File exists: D:\\nodejs\\nodejs\\jolly-cli 先 npm unlink 后，然后重新 npm link windows 系统上 cli 命令不能执行 jolly-cli : 无法加载文件 D:\\nodejs\\nodejs\\jolly-cli.ps1，因为在此系统上禁止运行脚本。 去根 nodejs 安装目录中删除 .ps1 后缀的文件，重新运行 cli 命令即可 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第五周 ansi-escapes 和 rxjs.html":{"url":"pages/jolly_chen/第五周 ansi-escapes 和 rxjs.html","title":"第五周 Ansi Escapes 和 Rxjs","keywords":"","body":"ANSI ansi-escapes 全称 ANSI-escape-code ANSI转义序列 ANSI escape sequences（ANSI转义序列）在终端中通过转义字符实现一些特殊操作的规范。特殊操作：光标上移、下移、左移，字体样式颜色改变等操作 ANSI 规则使用 console.log('\\x1B[41m\\x1B[4m%s\\x1B[0m', 'your name:'); console.log('\\x1B[2B%s', 'your name2:'); // 光标下移两行再输出 '\\x1B' \\x 表示16进制 1B 是固定写法 41 是在 ANSI-escape-code 中 'Colors' 部分查到的代码。表示红色背景 \\x1B[0m 是将显示样式还原 4m 表示下划线 m 表示 SGR，设置显示属性，见 ANSI-escape-code 中的 Terminal output sequences rxjs 响应式扩展库，实现异步。形式上跟 promise 相似 const { range } = rxjs; const { map, filter } = rxjs.operators; const pipe = range(1, 200).pipe( filter(x => x % 2 === 1), map(x => x + x) ); pipe.subscribe(x => console.log(x)); 可以将 pipe 返回给用户，让用户实现自己想要的逻辑。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第五周 egg.js + 云MongoDB快速入门.html":{"url":"pages/jolly_chen/第五周 egg.js + 云MongoDB快速入门.html","title":"第五周 Egg.Js + 云MongoDB快速入门","keywords":"","body":"为什么通过以下命令可以初始化 egg.js 项目 npm init egg --type=simple 这个有些像 \"第三周 commander使用 -> commander 厉害的功能 -> program.command() 的第二个参数：描述参数\" 中讲到的功能。 这里实际是下载并执行 create-egg 脚手架，后面的参数将传入 create-egg 脚手架 真实域名和ip端口号的映射修改 修改host文件 使用 switchHosts 软件，管理host文件 MongoDB 启动 mongod --dbpath=/Users/jolly/data/db mongodb 和 mongoose 两者都可以帮助 Node.js 进行数据库操作，但 mongoose 是在 mongodb 基础上，再次封装的。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第五周 inquirer核心理解.html":{"url":"pages/jolly_chen/第五周 inquirer核心理解.html","title":"第五周 Inquirer核心理解","keywords":"","body":"inquirer 基本使用 配置说明 https://www.npmjs.com/package/inquirer#objects 代码 const inquirer = require('inquirer'); inquirer .prompt([{ type: 'input', // 默认值为 input name: 'yourName', message: 'your name:', default: 'noname', validate: function(v) { // 验证通过才允许输入(按enter键才通过) // return v === 'jolly'; return typeof v === 'string'; }, transformer: function(v) { // 将输入的信息进行转换，然后显示给用户，不会改变输入信息 return 'name['+ v +']'; }, filter: function(v) { // 会改变最后的值 return v + ' chen'; // 输入 jolly, 返回 jolly chen } }, { type: 'number', // 会将输入转换为数子，不能转换为数子则返回 NaN name: 'num', message: 'your number' }]) .then(answers => { console.log('answers: ', answers); }) .catch(error => { if(error.isTtyError) { // Prompt couldn't be rendered in the current environment } else { // Something else when wrong } }); 运行结果 jolly@192 inquirer-test % node inidex.js ? your name: name[jolly chen] ? your number 123 answers: { yourName: 'jolly chen', num: 123 } jolly@192 inquirer-test % node inidex.js ? your name: name[jolly chen] ? your number NaN answers: { yourName: 'name[jolly]', num: NaN } type 的其他值 type: confirm 实现 y/n 询问，默认选项大写 type: list：实现选项功能 type: rawlist 和 list 差不多，只是显示和交互上有点差异 type: expand 实现简写选择，输入 h 显示帮助和全称 type: checkbox 实现列表多选，实现跟 list 几乎一致，只是 type 值不一样 type: password 密码 type: editor 打开文本编辑器 type 为 list：实现选项功能 { type: 'list', name: 'choice', message: 'your choice', default: 1, // 默认选择项索引 choices: [ { value: 1, name: 'Tom' }, { value: 2, name: 'Jolly' }, { value: 3, name: 'Oliver' } ] } 运行结果 jolly@192 inquirer-test % node inidex.js ? your choice (Use arrow keys) Tom ❯ Jolly Oliver type: expand { type: 'expand', name: 'choice', message: 'your choice', default: 'red', choices: [ { key: 'R', value: 'red' }, { key: 'G', value: 'green' }, { key: 'B', value: 'blue' } ] } 运行结果 jolly@192 inquirer-test % node inidex.js ? your choice (Rgbh) h >> Help, list all options jolly@192 inquirer-test % node inidex.js ? your choice (Rgbh) r) red g) green b) blue h) Help, list all options Answer: g jolly@192 inquirer-test % node inidex.js ? your choice green answers: { choice: 'green' } jolly@192 inquirer-test % type: checkbox { type: 'checkbox', name: 'choice', message: 'your choice', default: 1, // 默认选择项索引 choices: [ { value: 1, name: 'Tom' }, { value: 2, name: 'Jolly' }, { value: 3, name: 'Oliver' } ] } 运行结果 jolly@192 inquirer-test % node inidex.js ? your choice (Press to select, to toggle all, to invert selection) ❯◯ Tom ◯ Jolly ◯ Oliver jolly@192 inquirer-test % node inidex.js ? your choice ◯ Tom ◉ Jolly ❯◉ Oliver 空格选中当前选项 a 键全选 i 键反选：之前没有选中的选中，选中的变成未选中 type: editor 提示输入回车后打开编辑器 和 vim 一样 打开的文件是一个缓存文件，输入完后，文件会被删除 可以输入比 type: input 中，更复杂的内容 validate 中实现报错 validate: function (input) { var done = this.async(); setTimeout(function() { if (typeof input !== 'number') { done('验证未通过的提示'); return; } done(null, true); }, 0); } 命令行交互原理 对于架构师来说，不仅要能使用命令行交互，更要明白其是如何实现。 学习路径 掌握底层库：readline / events / stream / ansi-escapes / rxjs stream 输入输出流。process.stdout ansi-escapes 实现命令行特殊显示，改变颜色等 rxjs 响应式模型库 掌握命令行交互的实现原理，并实现一个可交互的列表，类似于 type: 'list' 最后，分析 inquirer 源码，掌握其中的关键实现 手写命令行交互式列表 实现原理 架构图 代码 const EventEmitter = require('events'); const readline = require('readline'); const MuteStream = require('mute-stream'); const { fromEvent } = require('rxjs'); // 处理事件监听 const ansiEscapes = require('ansi-escapes'); const options = { type: 'list', name: 'name', message: 'select your name: ', choices: [{ name: 'sam', value: 'sam' },{ name: 'shuangyue', value: 'sy', },{ name: 'zhangxuan', value: 'zx', }], }; function Prompt(options) { return new Promise((resolve, reject) => { try { const list = new List(options); list.render(); list.on('exit', function(answers){ resolve(answers); }); } catch (e) { reject(e) } }); } // 交互列表组件 class List extends EventEmitter { constructor(option) { super(); this.name = option.name; this.message = option.message; this.choices = option.choices; this.input = process.stdin; this.output = process.stdout; const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; this.rl = readline.createInterface({ input: this.input, output: this.output }); this.selected = 0; this.height = 0; // 列表高度， 有四行就是4 this.keypresss = fromEvent(this.rl.input, 'keypress').forEach(this.onKeypress); // 监听 input keypress 事件。处理函数为 this.onKeypress this.haveSelected = false; // 是否已经选择完毕 } /** * 处理按下上下键逻辑 * @param {Array} keymap 按键信息 */ onKeypress = (keymap) => { const key = keymap[1]; // 第一个元素是undefined if (key.name === 'down') { // 下键 this.selected++; if (this.selected > this.choices.length - 1) { this.selected = 0; } this.render(); } else if (key.name === 'up') { this.selected--; if (this.selected { if (!this.haveSelected) { // 32m：绿色前景；39m：默认前景；1m：字体加粗；22m：默认粗；0m：重置；2m：字体变细 let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m\\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choices, index) => { if (index === this.selected) { // 判断是否为最后一个元素，如果是，则不加 \\n if (index === this.choices.length - 1) { title += '\\x1B[36m❯ ' + choices.name + '\\x1B[39m'; } else { title += '\\x1B[36m❯ ' + choices.name + '\\x1B[39m \\n'; } } else { // 判断是否为最后一个元素，如果是，则不加 \\n if (index === this.choices.length - 1) { title += ' ' + choices.name; } else { title += ' ' + choices.name + '\\n'; } } }); this.height = this.choices.length + 1; return title; } else { // 输入结束后逻辑 const name = this.choices[this.selected].name; let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m\\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; return title; } } /** * 清屏 */ clean() { const emptyLines = ansiEscapes.eraseLines(this.height); // 生成空行 this.output.write(emptyLines); } /** * 关闭输入输出流 */ close() { this.output.mute(); // 禁止输出 this.rl.output.end(); this.rl.pause(); // 停止监听 this.rl.close(); } } Prompt(options).then(answers => { console.log('answers: ', answers); }); 和 inquirer 核心实现类似 运行结果 mute-stream 使输入输出流具有静默功能：想输出就输出，不想输出时静默。 ansi-escapes ANSI escape codes 库 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第五周 readline 深入浅出.html":{"url":"pages/jolly_chen/第五周 readline 深入浅出.html","title":"第五周 Readline 深入浅出","keywords":"","body":"readline 内置模块 提供接口，一次一行地读取可读流（例如 process.stdin ）中的数据。基本使用： const readline = require('readline'); const rl = readline.createInterface({ input: process.stdin, output: process.stdout }); rl.question('your name: ', (answer => { console.log(answer); rl.close(); })); readline 源码解读 强制将函数转为构造函数 if (!(this instanceof Interface)) { return new Interface(input, output, completer, terminal); } 获取事件驱动能力 EventEmitter.call(this); 监听键盘事件 emitKeypressEvents(input, this); // `input` usually refers to stdin input.on('keypress', onkeypress); input.on('end', ontermend); readline 核心实现原理 核心 emitKeypressEvents(input, this)，监听终端中的键盘输入 emitKeys() 是一个 Generator 函数 出现等待用户输入的核心： stream.on('data', onData) input.setRawMode(true) 参数默认是 false 表示整行进行监听，变为 true 表示逐字监听，这时每次按下键盘的输入都必须处理。 用户在命令行中输入，_stream_readable.js 中 addChunk() 函数派发事件 stream.emit('data', chunk); this.input.pause() 将输入流关闭 知识点 Number.isNaN(val) terminal = !!process.stdout.isTTY / !!process.stdin.isTTY 判断是否终端 手写 readline 核心实现 function stepRead(callback) { const input = process.stdin; const output = process.stdout; let line = ''; function onKeypress(s) { output.write(s); line += s; switch(s) { case '\\r': input.pause(); callback(line); break; } } emitKeypressEvents(input); input.on('keypress', onKeypress); input.setRawMode(true); input.resume(); } function emitKeypressEvents(stream) { function onData(chunk) { g.next(chunk.toString()); } const g = emitKeys(stream); g.next(); // 执行到第一个 yield 位置 stream.on('data', onData); } function* emitKeys(stream) { while(true) { let ch = yield; stream.emit('keypress', ch); } } stepRead(function(s) { console.log('answer: ' + s); }); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第五周 脚手架创建项目流程设计和开发.html":{"url":"pages/jolly_chen/第五周 脚手架创建项目流程设计和开发.html","title":"第五周 脚手架创建项目流程设计和开发","keywords":"","body":"本周收获 命令行交互方法 服务端框架 egg.js 的应用和API开发方法 egg.js 集成云 mongodb 主要内容 脚手架项目创建功能架构设计 通过命令行交互获取项目基本信息 egg.js + 云MongoDB的集成 开发前端项目模板 egg.js 获取项目模板 API 开发 项目模板下载功能开发 脚手架项目创建功能架构设计 设计原则 可扩展性：能够快速复用到不同团队，适应不同团队之间的差异 低成本：在不改动脚手架源码的情况下，能够新增模板，且新增模板的成本很低 高性能：控制存储空间，安装时，充分利用 Node 多进程提升安装性能。 控制存储空间的一个举例：不把模板集成在脚手架中。 架构设计图 脚手架项目创建功能架构设计图： 本周实现前面两步 prepare 部分 项目名称format：为了使不同使用者创建的项目名格式都是统一的 组件的描述信息：在组件平台中展示组件的用途 downloadTemplate 部分 把模板当 package 看待 选择项目/组件代码模板，使用 egg.js + 云 MongoDB 实现 添加模板 使用 vue-cli 创建 vue2 标准模板 修改 vue-element-admin 源码创建管理后台模板 命令行中的转动效果提示loading cli-spinner （视频中的） 比较老的npm包 代码占用空间较大：85.1k 下载人数多 var Spinner = require('cli-spinner').Spinner; (async function() { var spinner = new Spinner('processing.. %s'); spinner.setSpinnerString('|/-\\\\'); spinner.start(); await new Promise(resolve => setTimeout(resolve, 1000)); // 停止1秒 spinner.stop(true); // 停止是清除loading信息 })(); ora （自用） 新包 作者牛p 代码占用空间少：23.3k 下载人数很多 npminstall 也是使用 ora: \"^3.4.0\" 做命令行提示的 70+ loading方式 见 cli-spinners 中的 json： https://github.com/sindresorhus/cli-spinners/blob/HEAD/spinners.json const ora = require('ora'); (async function() { const spinner = ora({ text: 'Loading...', // spinner: 'dots10', // 70+ 内置样式 spinner: { // 自定义样式 interval: 80, // 时间间隔，毫秒 frames: ['|', '/', '-', '\\\\'] }, // color: 'yellow' // loading的颜色 }); spinner.start(); await new Promise(resolve => setTimeout(resolve, 1000)); // 停止1秒 spinner.succeed('成功'); // 成功信息：前面带个✅的信息 spinner.fail('失败'); // 错误信息：前面带个❌的信息 spinner.warn('警告'); // 警告信息：前面带个⚠️的信息 spinner.info('提示'); // 提示信息：前面带个i的信息 spinner.stop(); // 停止，不会留下text })(); jolly@192 child_process % node spinners.js ✔ 成功 ✖ 失败 ⚠ 警告 ℹ 提示 知识点 Array 对象的 find 方法 find() 方法返回通过测试（函数内判断）的数组的第一个元素的值。 find() 方法为数组中的每个元素都调用一次函数执行： 当数组中的元素在测试条件时返回 true 时, find() 返回符合条件的元素，之后的值不会再调用执行函数。 如果没有符合条件的元素返回 undefined 在 async 函数的 try {} catch{} 中，try 中 await 中的报错，可以被 catch 捕获。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第八周 Typescripte基础知识.html":{"url":"pages/jolly_chen/第八周 Typescripte基础知识.html","title":"第八周 Typescripte基础知识","keywords":"","body":"定义原始数据类型 null 和 undefined 是所有类型的子类型。可以复制给任何类型 let arrOfNum: number[] = [1, 2, 3, 4]; // 定义元素类型为数子的数组 tuple 元组类型 let user: [string, number] = ['jolly', 30]; // 两项，第一项类型为 string, 第二项类型为 number 函数声明 // 指定参数类型和返回值类型 function add(x: number, y: number, z?: number): number{ return x + y; } let add2 = (x: number, y: number, z?: number): number => { return x + y; } let add3: (x: number, y:number) => number = add2; Type inference 类型推断 let s = 'str'; // s 类型判定为 'string'. 不能被赋值为非 'string' 类型的值。 interface 定义对象类型及形状 interface Person { readonly id: number, name: string, age?: number } // 合法代码 let jolly: Person = { name: 'jolly', age: 30, id: 1 // id不能被修改 } 定义函数类型 interface Count { (x: number, y: number): number // 定义参数类型和返回值 } const sum: Count = (x: number, y: number) => x + y; Indexable type 可索引类型 interface Randmap { [propName: string]: string; } const map: Randmap = { a: 'a', b: 'b', c: 'c' // 合法 // d: 1 // 不合法，期望 String } LIke Array 类型 interface LikeArray { [index: number]: string } const likeArray: LikeArray = ['a', 'b', 'c']; likeArray[0]; // 只能访问，没有其他方法 duck typing 鸭子类型 // 定义一个四不像 interface FunWithProps { (x: number): number; name: string; } const a: FunWithProps = (x: number) => { // 传入类型要为 number // return 'x' // 不合法，返回类型应为 number return x } a.name = 'adf' // 类型要为 string 类和接口 public private 只在实例上可以访问，子类上不能访问 protected 只在子类上可以访问，实例上不能访问 interface 约束类，implements 实现类 interface ClockInterface { currentTime: number, alert(): void } interface GameInterface { play(): void } // 合法代码 class Cellphone implements ClockInterface, GameInterface { currentTime: number = 123; alert() { } play() { } } interface 约束构造函数 类的类型由两部分组成： 静态类型，这个类本身的类型 实例类型，使用 new 关键字创建的实例的类型 构造函数由约束静态类型，从而得到约束 // 约束静态类型 interface ClockStatic { new (h: number, m: number): void; time: number } // 约束实例类型的属性方法 interface ClockInterface { currentTime: number, alert(): void } // 约束实例类型的属性方法 interface GameInterface { play(): void } const Cellphone: ClockStatic = class Cellphone implements ClockInterface, GameInterface { constructor(h: number, m1: number){ } static time: 12 currentTime: number = 123; alert() { } play() { } } 泛型 函数和泛型 泛型解决的问题 类型推断不能延伸到函数 泛型是在定义函数和接口的时候，不预先指定类型，而在使用时指定类型的一种特性 function echo(arg: T): T { return arg; // T 是泛型的名称，可随意起名。可以理解为将来由参数类型替代 } const result = echo('str'); // result 类型为 string。T = string // 泛型可以传入多个值 function swap(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]]; } // 泛型和接口 从 react 定义文件学习 泛型和接口 安装 @types/react 使用命令 create-react-app 创建 react 项目，返现并没有 @types/react 于是手动安装 npm i -S @types/react 安装了之后，在 tsx 文件中才能 引入 FunctionComponent 接口，不然会报错 “react 没有导出 FunctionComponent” 用来学习的 ts 源码便是 FunctionComponent 接口的定义 interface FunctionComponent { (props: PropsWithChildren, context?: any): ReactElement | null; propTypes?: WeakValidationMap; contextTypes?: ValidationMap; defaultProps?: Partial; displayName?: string; } 例： import { FunctionComponent } from 'react' interface TestProps { title: string, desc: string } // 将接口 TestProps 传递到函数FunctionComponent中 const Test: FunctionComponent = (props) => { return ( {props.title} {props.desc} ) } 从 react ts 定义文件源码得知 泛型的默认值 类型别名: type type PlusType = (x: number, y: number) => number let sum: PlusType = (x: numver, y: number) => x + y // WeakValidationMap 的定义 type WeakValidationMap = { [K in keyof T]?: null extends T[K] ? Validator : undefined extends T[K] ? Validator : Validator }; 交叉类型 '&' 同时要有两个接口中的定义的数据 interface IName { name: string } type IPerson = IName & { age: number } let person: IPerson = { name: 'hello', age: 12 } // 同时要有两个接口中的定义的数据 // 源码中定义 PropsWithChildren 类型，用到了 type PropsWithChildren = P & { children?: ReactNode } 联合类型 '|' 注意，在typescript 不确定传入的类型是联合类型中的哪种时，我们只能访问两种类型共有的属性和方法。怎样判断是联合类型中的哪种类型，请看后面的 “类型断言” let numberOrString: number | string // numberOrString 为 number 或 string 类型 Partial 功能，接受一个泛型， 将其中的属性或函数变为可选。是 typescript 内置类型 interface Person { name: string, age: number } type PersonOptional = Partial /*PersonOption = interface { name?: string, age?: number }*/ // Partial 的源码 type Partial = { [P in keyof T]?: T[P]; // ? 表示可选 }; extends 在类型别名 WeakValidationMap 的赋值处，出现了 extends 操作符 type WeakValidationMap = { [K in keyof T]?: null extends T[K] ? Validator : undefined extends T[K] ? Validator : Validator }; extends 作用是判断一个类型是否满足另一个类型的约束。 进行泛型约束 interface IWithLength { length: number } function echoWithArr(arg: T): T { console.log(arg.length) // 将来传入的参数中，不一定有length。于是需要 extends 进行约束：传入的之中，必须有 length 属性 return arg; } 条件类型关键字 WeakValidationMap 中 extends 的作用便是条件类型关键字，产生一个条件类型。 type NonType = T extends null | undefined ? never : T // 假如泛型参数 T 为 null 或 undefined, 返回 never；否则返回 T // NonType 变为条件类型：是什么类型，看传入的泛型 T 的类型。 let demo1: NonType // demo1 的类型是 number let demo1: NonType // demo1 的类型是 never Partial 的实现 keyof 操作符，获取键值 in 操作符，用作循环 interface CountryResp { name: string; area: number; population: number; } // keyof type keys = keyof CountryResp // keys = 'name' | 'area' | 'population' // 在 keys 中的取值 type NameType = CountryResp['name'] type CountryOpt = { [p in Keys]?: CountryResp[p] } // CountryOpt = { // name?: string; // area?: number; // population?: number; // } // Partial 的源码 type Partial = { [P in keyof T]?: T[P]; }; 常量类型 上面注释中的代码 keys = 'name' | 'area' | 'population' 'name' 'area' 'population' 就是常量类型 注意下面的代码 const str = '123' // 用const定义常量， str 类型为 '123' 类型 let str1 = '123' // str1 类型是 string 类型断言 使用 as 操作符实现 function getLength(input: number | string) { // 使用了联合类型（ps：一般不要在 '{' 后面写注释，这里只是方便讲解） const str = input as string // 视为 string 类型 // 通过某个类型特有的属性，判断断言是否成立 if (str.length) { return str.length } else { const number = input as number // return number.toString().length } } 注意，类型断言不是类型转换，如果 as 后面是一个新的类型，将报错 // 我们将上面的代码中的任何一个 as 后面的类型换为未指定类型 const number = input as boolean // 报错：类型 \"string | number\" 到类型 \"boolean\" 的转换可能是错误的... 定义文件 用于 ts 编译时的检查，没有实现真正的代码功能 基础 定义文件命名：xx.d.ts 使用 declare declare var JQuery: (selector: string) => any; 如果 JQuery 是通过 标签引入，不是通过 import 引入，则以上声明可以使 ts 不报错 npm 包名为 @types/xx 是声明文件 @type/XX 包的创建，需要向 DefinitelyTyped 提交定义文件，需要其审批。社区 默认情况下，node_modules 下面的 @types 包都会被编译器自动加载 高级用法 编写声明文件 type HTTPMethod = 'GET' | 'POST' | 'PATCH' |'DELETE' declare function myFetch(url: string, method: HTTPMethod, data?: any): Promise declare namespace myFetch { const get: (url: string) => Promise; const post: (url: string, data: any) => Promist; } export = myFetch // 放入 node_modules 后要添加 可以放入一下文件夹中 node_modules |—— @tayps |—— myFetch |—— index.d.ts 现在，在 ts 文件中写 myFatch 方法时，就可一个获得提示了 注意： 这样做，只是为了在书写 ts 代码时获得良好的提示。实际方法的执行逻辑是没有的，在编译成 js 执行会报错 import 导入的文件，实际上是 node_modules/@types/myFetch/index 下面看看，真正使用环境下的目录 注意： ts 声明文件的文件名，应和实际的 js 文件名保持一致（.d.ts是声明文件的固定格式） 知识点总结 基本类型 类型推断 interface class 泛型 react FunctionComponent 定义文件源码 类型别名 联合类型 交叉类型 Partial keyof, in 常量类型 extends 类型断言 编写声明文件 内置类型还包括很多 Promise ... 学习方法 多看别人的定义文件，尤其是大项目的。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第八周 vue3基础知识.html":{"url":"pages/jolly_chen/第八周 vue3基础知识.html","title":"第八周 Vue3基础知识","keywords":"","body":"新特性 向后兼容 新特性 breaking change 性能提升 大小 -41% 初次渲染快 +51% 更新 +133% 内存减少 -54% typescript 支持 Composition API 为什么 随着功能的增长，复杂组件代码难以维护 Vue2 api 通过一些列的 object 组织代码，缺少一种比较干净的在多个组件之间提取和复用的机制 // vue2 的实现一个复杂功能，代码可能会很分散 export default { data { // 复杂功能1的数据 // 复杂功能2的数据 }, methods: { // 复杂功能1的实现方法 // 复杂功能2的实现方法 }, computed: { // 复杂功能1 // 复杂功能2 }, filters: { // ... } } // 修改一个功能，可能就要在文件中修改 data, methods, computed, 甚至 filter 等 使用 mixin 解决复用的问题 不知道mixin暴露的对象中的数据是什么，方法是什么、返回是什么。对象是有一定封闭性的。 mixin中同样会有 data、computed、methods等，逻辑依然会分散 命名冲突导致覆盖问题 vue2 对 Typescript 的支持有局限 解决方法，使用函数 按逻辑组织代码，一个功能对应一个函数，代码组织更集中 在普通情况下，函数使用的参数、返回值更易查找。 在 ts 的加持下，函数参数和返回值的提示更友好。 setup 不用像 vue2 那样，写 data, computed, methods 等分散的逻辑。而将这些写在 setup 方法中。setup 在props, data, computed, methods, 生命周期函数运行之前运行的，不能获得 this。 import { defineComponent } from 'vue' export default defineComponent ({ setup() { return ; } }); ref 生成响应式变量 {{ count }} add import { defineComponent, ref } from 'vue' export default defineComponent ({ setup() { const count = ref(0); const addCount = () => { count.value++; // 使用引用类型，修改一个，其他也会更新 } return { count, addCount }; } }); computed 计算属性 {{ count }} {{ double }} add import { defineComponent, ref, computed } from 'vue' export default defineComponent ({ setup() { const count = ref(0); // 返回 ref 对象 const double = computed(() => count.value * 2); // double 是 computedRef 对象 return { count, double }; } }); reactive 生成响应式对象 Name: {{ person.name }} Age: {{ person.age }} change name import { defineComponent, reactive } from 'vue' export default defineComponent ({ setup() { const person = reactive({ name: 'viking', age: 20, change() { person.name = 'maomao'; person.age = 30; } }) return { person }; } }); 注意：将 reactive 后的对象属性取出，会丧失响应性 toRefs 接受 reactive 对象，返回新的对象，但对象的每一项属性，都变成了 ref 类型实例(响应式的) Name: {{ name }} Age: {{ age }} change name import { defineComponent, reactive, toRefs } from 'vue' export default defineComponent ({ setup() { const person = reactive({ name: 'viking', age: 20, change() { person.name = 'maomao'; person.age = 30; } }); const person2 = toRefs(person); return { ...person2 }; } }); 生命周期 也是在 setup 中使用 beforeCreate 在 setup 之前运行，created 是在 setup 后运行，可以直接把 beforeCreate 和 created 中的逻辑，写在 setup 之中。所以这两个生命周期不再需要 深入响应式对象 保存未来执行修改的代码（effect） 监测值得改变 使用 proxy 对象实现 值改变后，执行 trigger effect 监测值得改变 使用 proxy 拦截对目标对象的读取： const person = { name: 'Jone' } const handler = { // 目标对象，属性名，代理对象 get(target, prop, receiver) { console.log('trigger get') return target[prop] } // 目标对象，属性名，要填入的值，代理对象 set(target, prop, value, receiver){ console.log('trigger set') traget[prop] = value return true // 告诉设置成功 } } const proxy = new Proxy(person, handler) 使用 Reflect 对象上的静态方法改写： const person = { name: 'Jone' } const handler = { get() { console.log('trigger get') return Reflect.get(...arguments) // Reflect.get() 接收的参数和 handler.get 接收的参数一样 } set(){ console.log('trigger set') return Reflect.set(...arguments) // Reflect.set() 接收的参数和 handler.set 接收的参数一样 } } const proxy = new Proxy(person, handler) 上面两种方式，执行效果一样 存储和触发effect 将所有 effect 加入特定的数据结构 创建特定的函数可以再次运行这些 effect 使用 Proxy 的 getter 和 setter，将这些函数放入对应的位置 let product = { price: 5, count: 2 } let total = 0 let dep = new Set() function track() { dep.add(effect) } function trigger() { dep.forEach(effect => effect()) } const reactive = (obj) => { const handler = { get() { let result = Reflect.get(...arguments) track() return result }, set() { let result = Reflect.set(...arguments) trigger() return result } } return new Proxy(obj, handler) } const product = reactive({ price: 5, count: 2 }) let effect = () => { total = product.price * product.count } console.log(total) product.price = 10 console.log(`total is ${total}`) 副作用 纯函数 相同的输入，永远会得到相同的输出 没有副作用 const double = x => x*2; // 给定一个 x ，输出的值永远都是一样的 Math.random(); // 不是一个纯函数 副作用 函数外部环境发生的交互 网络请求 DOM 操作 订阅数据来源 写入文件系统 获取用户输入 Vue 副作用处理 import { defineComponent, watchEffect } from 'vue' export default defineComponent { props: { msg: string } setup(props) { watchEffect(() => { console.log('props effect', props.msg); }) } } 组件第一次初始化时，会触发 watchEffect watchEffect 回调里面的值，没有发生变化，就不会触发副总用 深入 watchEffect 自动收集依赖且触发 自动销毁 effect 在 setup 或生命周期钩子函数中使用 watchEffect ，在组件销毁时，副作用也会一起销毁 可以手动清除 const stop = watchEffect(() => { console.log('props effect', props.msg); }); stop(); // 销毁 使副作用失效 watchEffect 中发送请求时，多次变化，势必多次请求 watchEffect 向回调中提供参数，以停止未完成的副作用 watchEffect((onInvalidate) => { console.log('props effect', props.msg); console.log('inner effect', count.value); const source = axios.CancelToken.source() axios.get(`https://jsonplaceholder.typicode.com/todos/${count.value}`, { cancelToken: source.token }).catch(err => { console.log(err.message); }); onInvalidate(() => { source.cancel('trigger'); }); }); 副作用执行顺序 watchEffect 都是异步执行的 watchEffect 先执行 DOM updated 再执行 change import { defineComponent, ref } from 'vue' export default defineComponent ({ props: { msg: string } setup() { const node = ref(null); watchEffect(() => { const currentText = node.value ? node.value.innerText : ''; console.log(currentText); }, { flush: 'post' // 默认是 pre：之前， }) return { node }; } }); watchEffect 提供参数 flush 改变执行顺序。post 表示，在 DOM updated 之后再执行 watchEffect React 的执行顺序不可以调整，都是在组件 updated 之后触发 watch 精准控制 effect {{msg}} {{count}} change import { ref, watch, toRefs } from 'vue' export default defineComponent ({ props: { msg: string } setup(props) { const node = ref(null); // 基本使用 watch(count, (newV, oldV) => { console.log(count.value) }); // 响应式对象的值 // watch(props.msg, (newV, oldV) => {});// props 是只读的，拿出其中的值，这个值将不再是响应式对象 // 方法 1 const { msg } = toRefs(props.msg); watch(msg, (newV, oldV) => {}); // 方法 2 watch(() => props.msg, (newV, oldV) => {}); // watch 多个值 watch([() => props.msg, count] => props.msg, (newV, oldV) => { console.log(newV.value) // [第一个值，第二个值] }); return { node }; } }); watch 的基本用法 watch(count, (newV, oldV) => { console.log(count.value) }); watch 响应式对象的单个值 使用 toRefs 使用 getter 函数 // watch(props.msg, (newV, oldV) => {});// props 是只读的，拿出其中的值，这个值将不再是响应式对象 // 方法 1 const { msg } = toRefs(props.msg); watch(msg, (newV, oldV) => {}); // 方法 2 watch(() => props.msg, (newV, oldV) => {}); watch 多个值 使用数组 // watch 多个值 watch([() => props.msg, count] => props.msg, (newV, oldV) => { console.log(newV.value) // [第一个值，第二个值] }); 和 watchEffect 对比 懒执行副作用：针对某个值执行副作用 watch 可以定义什么状态应该触发 watcher 重新运行 watch 可以访问数据变化前后的值，watchEffect 不能 自定义函数 - hooks 将相关的 feature 组合在一起 非常易于重用 界面的需求 - 转化为数据的描述 优点 以函数的形式调用，清楚的了解参数和返回的类型，更好的提示 避免命名冲突 代码逻辑脱离组件存在 示例 Loading todo {{ todo.result && todo.result.title }} import useURLLoader from '../hooks/useURLLoader' interface PostProps { userId: number, id: number, title: string, body: string } export default { props: { msg: String }, setup() { const todo = useURLLoader('url'); todo.result return { todo } } } // useURLLoader.js import { reactive } from 'vue'; // 响应式对象 import axios from 'axios'; interface DataProps { result: T | null, loading: boolean, loaded: boolean, error: any } const useURLLoader = (url: string) => { const data = reactive>({ result: null, loading: true, loaded: false, error: null }) axios.get(url).then(resp => { data.result = resp.data; data.loaded = true; }).catch(e => { data.error = e; }).finally(() => { data.loaded = false; }); return data; }; export default useURLLoader; 对比 React 的自定义 hooks 更新数据的方式 触发的时机 为什么要包裹在 useEffect 中？ 删除了会有什么问题？ 为什么 Vue3 不需要这样做也可以？ 其他自学知识点 Teleport Fragment Emits Components Options Global API 修改 语法糖 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第六周 ejs使用和源码解析.html":{"url":"pages/jolly_chen/第六周 ejs使用和源码解析.html","title":"第六周 Ejs使用和源码解析","keywords":"","body":"ejs 用法 三种基本用法 参见代码 const ejs = require('ejs'); const path = require('path'); const html = ''; const options = {}; const data = { name: 'jolly' }; // 1. ejs.compile const template = ejs.compile(html, options); // 可以反复利用，多次渲染时，效率较高 let compileTemplate = template(data); console.log('template: ', compileTemplate); // 2. ejs.render data.name = 'john'; compileTemplate = ejs.render(html, data, options); console.log('render: ', compileTemplate); // 3. ejs.renderFile // 3.1. Promise data.name = 'Tom'; const templatePromise = ejs.renderFile(path.resolve(__dirname, 'template.html'), data, options); templatePromise.then(compileTemplate => { console.log('templatePromise: ', compileTemplate); }); // 3. ejs.renderFile // 3.2. callback data.name = 'Jim'; ejs.renderFile(path.resolve(__dirname, 'template.html'), data, options, (err, compileTemplate) => { console.log('renderFile: ', compileTemplate); }); template.html 运行结果 PS D:\\myProgram\\templateCompile> node .\\ejs.js template: jolly render: john renderFile: Jim templatePromise: Tom 标签含义 控制流脚本用 输出时会有三个空行 删除其前面的空格。注意要有一个空格 删除其后面的空格。注意要有一个空格 输出非转义的数据到模板。场景一：直接输出html代码等特殊字符到模板 输出数据到模板 注释标签。不执行、不输出的内容 输出字符串 ' %%> 输出字符串 '%>' -%> 删除紧随其后的换行符。将，一般结束符标签 %> 换为 -%> 可以去掉非预期的空行 辅助功能 包含 引入另一个 ejs 模板，起到拷贝作用 path 为模板路径 data 模板需要的数据 自定义分隔符 通过配置 options 中添加 delimiter: '?' 修改分隔符为 ?。书写时，% 要变为 ? 自定义文件加载器 const fs = require('fs'); const ejs = require('ejs'); let myFileLoader = function (filePath) { return 'myFileLoader: ' + fs.readFileSync(filePath).toString(); // 在所有加载的 ejs 模板前，加上 myFileLoader 字符串 }; ejs.fileLoader = myFileLoad; // 通过 myFileLoader 去加载文件 ejs 源码 ejs 执行流程 ejs.render 和 ejs.renderFile 最后都是调用 ejs.compile 方法。 `ejs.compile 函数执行流程 (new Function('return (async function(){}).constructor;'))() 获得 async funtion(){} 的构造器 当编译模板是 '' const template = ejs.compile(html, options); // 可以反复利用，多次渲染时，效率较高 let compileTemplate = template(data); 此时 template 最终执行的是存在内存中的匿名函数 (function anonymous(locals, escapeFn, include, rethrow ) { var __line = 1 , __lines = \"\" , __filename = undefined; try { var __output = \"\"; function __append(s) { if (s !== undefined && s !== null) __output += s } with (locals || {}) { ; __append(\"\") ; __append(escapeFn(name)) ; __append(escapeFn(name)) ; __append(\"\") } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } }) template = returnedFn(data) locals 为 data escapeFn 是处理特殊字符的函数，默认处理的是 &<>'\" 五个字符， { '&': '&amp;', '': '&gt;', '\"': '&#34;', \"'\": '&#39;' }; 该函数，通过 opts.escape || opts.escapeFunction 指定 include 模板文件中有 include 引入了其他 ejs 模板时调用。此时，with 中会多出一行 ; __append( include(path, data) ) rethrow 错误信息处理函数 ejs.render 将 options 中的 delimiter, scope, context, debug, compileDebug, client, _with, rmWhitespace, strict, filename, async 配置，写到 data 中，(此时要)省的 options 也是可以的 cache 即 exports.cache，在 option.cache 设置为 true 时，将作为键值缓存 ejs.compile 得到的函数，键名为文件名 ejs.renderFile 知识点 使用 new Function() 创建匿名函数 let func = new Function ([arg1, arg2, ...argN], functionBody); let func = new Function ('arg1, arg2, ...argN', functionBody); let func = new Function ('arg1', arg2', '...' , 'argN', functionBody); 前面是匿名函数形参，最后一个参数是匿名函数体，都是字符串 ejs.renderFile 源码中用到了 Array.prototype.slice.call(arguments) 将类数组对象 arguments 转换成数组 var a = [1,2]; var b = a.slice(); // [1, 2] b === a // false 获取宿主对象 (new Function('return this;'))() 以上代码返回当前 js 执行环境的宿主对象：window / global Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第六周 glob使用.html":{"url":"pages/jolly_chen/第六周 glob使用.html","title":"第六周 Glob使用","keywords":"","body":"Glob npm i -S glob 用来做文件过滤，过滤规则跟 shell 脚本中的一样。 glob 最早是出现在类Unix系统的命令行中, 是用来匹配文件路径的。比如，lib/*/.js 匹配 lib 目录下所有的 js 文件。 匹配规则 不同语言的 glob 库支持的规则会略有不同。下面是 node-glob 的匹配规则。 * 匹配任意 0 或多个任意字符 ? 匹配任意一个字符 [...] 若字符在中括号中，则匹配。若以 ! 或 ^ 开头，若字符不在中括号中，则匹配 !(pattern|pattern|pattern) 不满足括号中的所有模式则匹配 ?(pattern|pattern|pattern) 满足 0 或 1 括号中的模式则匹配 +(pattern|pattern|pattern) 满足 1 或 更多括号中的模式则匹配 *(a|b|c) 满足 0 或 更多括号中的模式则匹配 @(pattern|pat*|pat?erN) 满足 1 个括号中的模式则匹配 ** 跨路径匹配任意字符 链接：https://www.imooc.com/article/4053 举例 获取除 node_modules、webpack.config.js 之外的所有 js 文件。 const glob = require('glob'); glob('**/*.js', { ignore: ['node_modules/**', 'webpack.config.js'] }, function(err, file) { console.log(err, file); }); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第六周 node require 加载模块.html":{"url":"pages/jolly_chen/第六周 node require 加载模块.html","title":"第六周 Node Require 加载模块","keywords":"","body":"require 的使用场景 加载模块类型 加载内置模块：require('cluster') 加载 node_modules 模块：require('ejs') 加载本地模块：require('./ejs') 支持的文件类型 加载 .js 文件 加载 .json 文件 fs.readFileSync(filename, 'utf8') 拿到文件内容，字符串 JSON.parse(stripBOM(content)) 去掉 BOM 头后解析 加载 .node 文件 return process.dlopen(module, path.toNamespacedPath(filename)) 加载 .mjs 文件 加载其类型的文件 当 .js 文件处理 require 源码阅读中的一些思考 CommonJS 加载主模块的流程 执行 internal/mian/run_main_modules.js Module._load(process.argv[1], null, true) require 为何非将 js/json/node 文件视为 js 文件加载？ require 连续加载同一个模块时，是如何进行缓存的？ 两个缓存 父 module 的 path + \\x00文件名对应的绝对路径+文件名.后缀 绝对路径+文件名.后缀，对应的 Module 对象 主模块特点 process.mainModule = module; require.main = process.mainModule = module require.main === module 可以判断模块是主模块 isMain = true parent 为 null process.mainModule 在 node v14.0.0 之后弃用 require 执行流程 Module 对象 id : 源码文件路径，如：/User/jolly/Desktop/imooc/ejs-test/ejs.js。根 Module id 为 '.' path : 源码文件所在的文件夹，通过 path.dirname(id) 生成 exports : 模块输出的内容，默认为 {} parent : 父模块信息 filename : 源码文件路径 loaded : 是否已经加载完毕 children : 子模块对象集合 paths : 模块查询范围 require 执行流程总结 relativeResolveCache[relResolveCacheIdentifier] 查询缓存路径 Module._cache[filename] 查询缓存模块 Module._resolveFilename 查询模块的只是路径 loadNativeModule 加载内置模块 new Module 实例化 Module 对象 module.load 加载模块 findLongestRegisteredExtension 获取文件后缀名 Module._extensions[extension](this, filename) 解析模块并执行模块 module._compile 编译模块代码 compileFunction 将模块代码生成可执行函数 exports, require, module, filename, dirname 生成入参 compileWrapper.call 执行模块函数 return module.exports 输出模块返回结果 扩展资料 阮一峰require源码解读：http://www.ruanyifeng.com/blog/2015/05/require.html UTF8 BOM：https://www.imooc.com/article/26166 Shebang：https://blog.csdn.net/u012294618/article/details/78427864 知识点 path.dirname(filename) 获取文件路径 path.basename(filename) 获取文件名(带后缀) 每需要一次 require requireDepth 加一，执行完require 进来的模块后，requireDepth 减一 Module._resolveFilename() 调用 Module._findPath() 之后，在返回的文件名不存在，没有模块，报错 Module._nodeModulePaths(path.dirname(filename)) 产生的 node_modules 数组，最终保存在了 Module 对象上 internal/modules/cjs/loader.js findLongestRegisteredExtension(filename) 获取 扩展名，默认返回 js path.sep 路径分隔符 Mac: '/' window: '\\' '#!' 名字是 shebang 加载内置模块和其他模块的 compileFunction 方法来源模块是不一样的 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第六周 脚手架创建项目和组件初始化开发.html":{"url":"pages/jolly_chen/第六周 脚手架创建项目和组件初始化开发.html","title":"第六周 脚手架创建项目和组件初始化开发","keywords":"","body":"收获 ejs 模板渲染 glob 文件筛选 项目标准安装和自定义安装 组件库初始化和安装 学习内容 脚手架安装模板功能架构设计 脚手架模板安装核心实现：ejs 库功能详解 脚手架项目模板安装功能开发 组件模板开发及脚手架组件初始化功能支持 脚手架自定义初始化项目模板功能开发 ejs 源码解析 Node.js require 源码解析 架构设计图 脚手架项目创建功能架构设计图： 本周实现模板安装 自定义模板，执行文件入口后，执行自定义安装过程 使用到的库 kebab-case 作用：WebkitTransform -> -webkit-transform 知识点 package.json 中的 files 配置上传到 npm 的目录或文件，是一个数组 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第四周 Node多进程入门.html":{"url":"pages/jolly_chen/第四周 Node多进程入门.html","title":"第四周 Node多进程入门","keywords":"","body":"Node 多进程开发入门 Node多进程核心是创建一个子进程，子进程依附在当前Node进程下面 核心类是 child_process 文档路径 http://nodejs.cn/api/child_process.html 子进程概念 是系统进行资源分配和调度的基本单位，是操作系统结构的基础 进程的概念只要有两点 进程是一个实体。每一个进程都有它的地址空间 进程是一个“执行中的程序”，存在嵌套关系 进程开线程，进程和线程的区别？ 查看进程（os） ps -ef 查看所有进程 Last login: Sun Feb 7 15:42:44 on ttys002 jolly@JollydeMacBook-Pro jolly-cli-dev % ps -ef UID PID PPID C STIME TTY TIME CMD 0 1 0 0 301220 ?? 14:35.92 /sbin/launchd 0 112 1 0 301220 ?? 0:56.66 /usr/sbin/syslogd 0 113 1 0 301220 ?? 2:26.60 /usr/libexec/UserEventAgent (System) 0 116 1 0 301220 ?? 0:13.29 /System/Library/PrivateFrameworks/Uninstall.framework/Resources/uninstalld 0 117 1 0 301220 ?? 0:54.79 /usr/libexec/kextd 0 118 1 0 301220 ?? 5:35.10 /System/Library/Frameworks/CoreServices.framework/Versions/A/Frameworks/FSEvents.framework/Versions/A/Support/fseventsd UID 获得权限的用户的UID PID 进程的ID ps -ef|grep PID 可帅选出对应进程 PPID 父进程的ID，体现进程的嵌套关系 vscode 启动 node 调试时的父子进程关系图。体现了进程嵌套 child_process 用法 const cp = require('child_process'); 异步 exec 执行 shell 命令 cp.exec('ls -la', function(err, stdout, stderr){ console.log('err: ', err); // 错误 console.log('stdout: ', stdout); // 正常运行输出的结果，后面会有个换行 console.log('stderr: ', stderr); // 异常输出的结果 }); jolly@JollydeMacBook-Pro child_process % node index.js err: null stdout: total 8 drwxr-xr-x 3 jolly staff 96 2 7 16:58 . drwxr-xr-x 14 jolly staff 448 2 7 16:58 .. -rw-r--r-- 1 jolly staff 189 2 7 16:59 index.js stderr: 第二个参数是一个 option 对象 cwd 设置执行的目录 timeout 设置执行命令超时的时间，默认是0(不超时) execFile 执行 shell 文件 有四个参数 如果第一个参数不是路径，而是命令，那么通过 which 命令 找到对应的文件 cp.execFile('ls', ['-la'], function(err, stdout, stderr){ console.log('err: ', err); console.log('stdout: ', stdout); console.log('stderr: ', stderr); }); 和上面 exec 执行效果一样 execFile 第二个参数是，传入文件的参数 和 exec 的区别 exec 支持更复杂的 shell 命令：ls -la|grep node_modules 但 execFile 执行 [-la|grep node_modules] 会报错，不能执行成功。因为 grep 不是 execFile 执行文件 ls 的参数 可以执行 .shell 文件：将 ls -al|grep node_modules 写在 .shell 文件中 chmod +x test.shell 添加执行权限 test.shell 文件当中的内容 ls -la|grep node_modules echo $1 $1 代表 execFile 传入的第一个参数 exec 也能执行指定文件，但是不支持传入参数 spwan 执行 shell 文件 如果第一个参数不是路径，而是命令，那么通过 which 命令 找到对应的文件 const child = cp.spawn(path.resolve(__dirname, 'test.shell'), ['-la'], { cwd: path.resolve('.') }) child.stdout.on('data', function(chunk) { console.log('stdout: ', chunk.toString()); //一次输出一个字符串 }); child.stderr.on('data', function(chunk) { console.log('stderr: ', chunk.toString()); }); child.on('error', e => { // 监听错误 process.exit(1); }); child.on('exit', e => {// 监听执行成功后的退出事件 }); option参数 stdio 选项用于配置在父进程和子进程之间建立的管道。值： pipe 默认值，在子进程和父进程之间创建一个管道。 ignore 静默执行，不会收到反馈 inherit 将相应的 stdio 流传给父进程或从父进程传入。将输入、输出、错误，绑定到父进程的 process.stdin、 process.stdout 和 process.stderr 上。直接能看到打印，还带动画（进度）信息 。 fork 使用 node 执行命令 一个参数：模块路径 和 require() 的区别 require 加载的 js 模块是在主进程中执行的。fork 测试在子进程中的执行的，执行的js文件 process.pid 会发生变化。 const child = cp.fork(path.resolve(__dirname, 'child.js')); 适合执行耗时任务。 exec、execFile、fork 底层都是调用 spawn 的 何时使用 spawn、exec、execFile spawn 适合耗时任务（比如：npm install），需要不断日志。spawn 逐条执行命令 exec/execFile：开销比较小的任务。整个执行完后返回 向子进程发送消息 const child = cp.fork(path.resolve(__dirname, 'child.js')); // 向子进程发送消息 child.send('hello child process', () => { // child.disconnect(); // 断开主、子进程直接的连接，否则，命令行将进入等待状态 }); // 接受子进程消息 child.on('mssage', msg => { console.log('msg: ', msg); child.disconnect(); }); console.log('main pid', process.pid); child.js console.log('child process'); console.log('child pid', process.pid); // 接受主进程消息 process.on('message', msg => { console.log('msg: ', msg); }); // 向主进程发送消息 process.send('hello main process'); 执行结果 jolly@JollydeMacBook-Pro child_process % node index.js main pid 61868 child process child pid 61869 msg: hello child process msg: hello main process 注意：子进程向主进程发送消息，容易造成死循环 同步 执行简单 shell 命令 execSync 执行 shell 命令 const stdout = cp.execSync('ls -la|grep node_modules'); console.log(stdout.toString()); // stdout 是个 buffer execFileSync 执行 shell 文件 const stdout = cp.execFileSync('ls', ['-la']); console.log(stdout.toString()); // stdout 是个 buffer spawnSync 执行 shell 文件 const ret = cp.spawnSync('ls', ['-la']); console.log(ret.stdout.toString()); // ret 是个 buffer windows 子进程执行 node 命令 cp.spawn('cmd', ['/c', 'node', '-e', code]); // '/c' 表示静默执行 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第四周 child_process同步源码解析.html":{"url":"pages/jolly_chen/第四周 child_process同步源码解析.html","title":"第四周 Child Process同步源码解析","keywords":"","body":"execSync、 execFileSync 和 spawnSync 执行流程 execSync 、 execFileSync 和 spawnSync 的区别 execSync 和 execFileSync 底层都是调用 spawnSync。但是 execSync 和 execFileSync 在调用 spawnSync 之前的参数规范化逻辑不一样： execSync 和 exec 都是调用 normalizeExecArgs() execFileSync 、 spawn 及 spawnSync 调用的是 normalizeSpawnArguments() spawnSync 返回的是 child_process.spawnSync(opts) 中 spawn_sync.spawn(options) (C++ 代码) 执行返回的结果 result execSync 和 execFileSync 都将 spawnSync 的执行结果做了同样的处理 有错误，直接从主进程 threw 错误 在 execFileSync('ls -la') 找不到文件时 result.error 错误日志 child_process.js:642 throw err; ^ Error: spawnSync ls -la ENOENT at Object.spawnSync (internal/child_process.js:1041:20) at spawnSync (child_process.js:607:24) at Object.execFileSync (child_process.js:634:15) at Object. (/Users/jolly/Desktop/imooc/child_process/index.js:7:19) at Module._compile (internal/modules/cjs/loader.js:959:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10) at Module.load (internal/modules/cjs/loader.js:815:32) at Function.Module._load (internal/modules/cjs/loader.js:727:14) at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10) at internal/main/run_main_module.js:17:11 { errno: 'ENOENT', code: 'ENOENT', syscall: 'spawnSync ls -la', path: 'ls -la', spawnargs: [], error: [Circular], status: null, signal: null, output: null, pid: 6262, stdout: null, stderr: null } result.stdout 和 result.stderr 中是 null 在命令本身错误时：lss -la result.error = undefined result.stdout 中的 ArrayBuffer 为空 result.stderr 中 ArrayBuffer 有值。result.stderr 中的信息，将通过 process.stderr.write(ret.stderr) 打印在主进程的日志中：/bin/sh: lss: command not found result.status !== 0，打印 result.stderr 之后，threw 错误信息 没有错误，返回执行成功的结果输出流 stdout 使用示例 const cp = require('child_process'); const path = require('path'); execSync const stdout = cp.execSync('lss -la'); console.log('stdout: ', stdout.toString()); // 有异常不会执行 execFileSync const stdout = cp.execFileSync(path.resolve(__dirname, 'test.shell')); console.log('stdout: ', stdout.toString()); // 有异常不会执行 spawnSync const result = cp.spawnSync(path.resolve(__dirname, 'test.shell')); if (result.status === 0) { // 没有异常 console.log(result.stdout.toString()) } else { console.log(result) } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第四周 child_process异步源码解析.html":{"url":"pages/jolly_chen/第四周 child_process异步源码解析.html","title":"第四周 Child Process异步源码解析","keywords":"","body":"源码解读解决的问题 exec 和 execFile 到底有什么区别 为什么 exec / execFile / fork 都是通过 spawn 实现的，spawn 的作用到底是什么？ 为什么 spawn 调用后没有回调，而 exec / execFile 能够回调？ 为什么 spawn 调用后需要手动调用 child.stdout.on('data', callback)，这里的 child.stdio / child.stderr 到底是什么？ 为什么有 data / error / exit / close 这么多种回调，它们的执行顺序到底是什么怎样的？ exec源码解读 exec 和 execFile 的区别就是参数的区别 在 execFile 中调用 spawn 并且监听了 stderr 和 stdout 的 data 事件，执行事件处理函数，exec 和 execFile 的回调函数就是这个事件处理函数。所以 exec 和 execFile 有回调函数 执行 exec 时，最后调用 spawn 规范后的参数 出现了 /bin/sh envPairs 是环境变量 this._handle 是实际的进程 执行 child.spawn 实际执行的是 this._handle.spawn，执行后开启新进程 exec 执行后也是可以得到子进程对象的 课程中调试源码时， ls -la|grep node_modules 报错，而直接在 bash 中运行不报错，是因为node 有执行的环境，执行的环境不一样(执行时，所在路径不一样) 统一执行环境后(没有node_modules文件夹)，bash 中不会报错，但是没有结果。但调试还报错，是因为 bash 处理了错误。我们代码中输出了错误而已 shell 的使用 方法一：直接执行shell文件 /bin/sh test.shell 方法二：直接执行 shell 语句 /bin/sh -c \"ls -la\" 所以，没有 -c 要指定文件路径 shell 命令 ls -la === /bin/sh -c \"ls -la\" exec 源码精读 对象的扩展运算符进行浅拷贝 // 等同于 {...Object(true)} {...true} // {} // 等同于 {...Object(undefined)} {...undefined} // {} // 等同于 {...Object(null)} {...null} // {} {...'hello'} // {0: \"h\", 1: \"e\", 2: \"l\", 3: \"l\", 4: \"o\"} { ...['a', 'b', 'c'] }; // {0: \"a\", 1: \"b\", 2: \"c\"} 浅拷贝和深拷贝 浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。 深拷贝：将一个对象从内存中完整的拷贝一份出来，包括属性指向的引用类型，从堆内存中开辟一个新的区域存放新对象，且修改新对象不会影响原对象 注意：第二个参数传任何非 function 类型，都会产生获得一个对象。 function normalizeExecArgs(command, options, callback) { if (typeof options === 'function') { callback = options; options = undefined; } // 浅拷贝 options = { ...options }; // 将任意非 function 都将转化为参数 options.shell = typeof options.shell === 'string' ? options.shell : true; // 得到shell属性。 return { file: command, options: options, // options 至少有一个属性：shell callback: callback }; } option.shell 可以是一个字符串，用来执行命令的文件。默认值: Unix 上是 '/bin/sh'，Windows 上是 process.env.ComSpec execFile 中首先对参数逐个判断，判断逻辑有点意思 function execFile(file /* , args, options, callback */) { let args = []; let callback; let options; // 解析可选参数（第一个参数是 shell 文件路径），使用argument let pos = 1; if (pos 这样的参数解析，可以不用固定参数的顺序 查看 ERR_INVALID_ARG_VALUE 的报错 const cp = require('child_process'); cp.exec('ls -la', null,'sdds'); 要传入第二个参数时，才能看见第三个参数的报错。原因见”对象的扩展运算符“ olly@192 child_process % node index.js child_process.js:202 throw new ERR_INVALID_ARG_VALUE('args', arguments[pos]); ^ TypeError [ERR_INVALID_ARG_VALUE]: The argument 'args' is invalid. Received 'sdds' at Object.execFile (child_process.js:202:11) at Object.exec (child_process.js:145:25) at Object. (/Users/jolly/Desktop/imooc/child_process/index.js:4:4) at Module._compile (internal/modules/cjs/loader.js:959:30) at Object.Module._extensions..js (internal/modules/cjs/loader.js:995:10) at Module.load (internal/modules/cjs/loader.js:815:32) at Function.Module._load (internal/modules/cjs/loader.js:727:14) at Function.Module.runMain (internal/modules/cjs/loader.js:1047:10) at internal/main/run_main_module.js:17:11 { code: 'ERR_INVALID_ARG_VALUE' } 数组的浅拷贝 //args = args.slice(0) var a = [1, 2, 3]; var b = a.slice(0); // b: [1, 2, 3] a === b; // false spawn 中的命令拼接部分 if (options.shell) { const command = [file].concat(args).join(' '); // 拼接命令文件和传入的参数 // Set the shell, switches, and commands. if (process.platform === 'win32') { // windows if (typeof options.shell === 'string') // 自定义执行shell的文件 file = options.shell; else file = process.env.comspec || 'cmd.exe'; // '/d /s /c' is used only for cmd.exe. if (/^(?:.*\\\\)?cmd(?:\\.exe)?$/i.test(file)) { // 匹配任意路径下的 cmd.exe。这里指定了 cmd.exe 的路径 args = ['/d', '/s', '/c', `\"${command}\"`]; // '/d /s /c' 仅用于 cmd.exe. options.windowsVerbatimArguments = true; // options 中的 windowsVerbatimArguments 参数 } else { args = ['-c', command]; } } else { if (typeof options.shell === 'string') file = options.shell; else if (process.platform === 'android') // 安卓系统 file = '/system/bin/sh'; else file = '/bin/sh'; // 默认使用 '/bin/sh' args = ['-c', command]; } } spawn 中的 new ChildProcess() EventEmitter.call(this); 之后，可以分发事件了。 emit 分发 on 监听 this._handle.onexit 进程执行完之后回调 child.spawn/ ChildProcess.prototype.spawn getValidStdio() 创建输入输出错误流 输入流，子进程只有读权限 输出流，子进程只有写权限 new Pipe() 创建 socket 通信，调用 pipe_wrap ipc 建立进程间的双向通信，在 fork 时创建 循环建立父子进程 socket 通信 socket 对象使用 on('data')监听 node_process回调调用流程 Process 执行命令 child._handle.spawn(options) 执行命令 exitCode 为0，表示执行成功，小于0表示失败 命令执行成功后，往”流“中写入信息，回调 onStreamRead 方法读取流中信息 onStreamRead 每读取完一条流中信息，调用一次 onReadableStreamEnd maybeClose() 中，判断所有socket 关闭后，关闭子进程 两条线： 子进程的执行线 流的读取线 事件处理函数执行顺序 const child = cp.execFile('ls -la', function(err, stdout, stderr){ console.log('callback start-----------'); console.log('err: ', err); console.log('stdout: ', stdout); console.log('stderr: ', stderr); console.log('callback end-----------'); }); child.on('error', chunk => { console.log('error! ', chunk); }) child.stdout.on('data', chunk => { console.log('stdout data: ', chunk); }); child.stderr.on('data', chunk => { console.log('stderr data: ', chunk); }); child.stdout.on('close', chunk => { console.log('stdout close'); }); child.stderr.on('close', chunk => { console.log('stderr close'); }); child.on('exit', (exitCode, signalCode) => { console.log('exit! ', exitCode, ' ', signalCode); }); child.on('close', (exitCode, signalCode) => { console.log('close! ', exitCode, ' ', signalCode); }); jolly@192 child_process % node index.js stdout data: total 24 drwxr-xr-x 6 jolly staff 192 2 10 15:11 . drwxr-xr-x 14 jolly staff 448 2 7 16:58 .. drwxr-xr-x 3 jolly staff 96 2 10 15:11 .vscode -rw-r--r-- 1 jolly staff 225 2 7 21:10 child.js -rw-r--r-- 1 jolly staff 1901 2 11 16:50 index.js -rwxr-xr-x 1 jolly staff 15 2 7 20:19 test.shell exit! 0 null stderr close callback start----------- err: null stdout: total 24 drwxr-xr-x 6 jolly staff 192 2 10 15:11 . drwxr-xr-x 14 jolly staff 448 2 7 16:58 .. drwxr-xr-x 3 jolly staff 96 2 10 15:11 .vscode -rw-r--r-- 1 jolly staff 225 2 7 21:10 child.js -rw-r--r-- 1 jolly staff 1901 2 11 16:50 index.js -rwxr-xr-x 1 jolly staff 15 2 7 20:19 test.shell stderr: callback end----------- close! 0 null stdout close exec 执行和回调脑图 颜色说明： 黄色：回调执行过程 紫色：广播事件 绿色：进程 error 流程 关于 stderr 当命令执行失败，如 lss -ls 时 ChildProcess.prototype.spawn() 中 exitCode 是 0，并不小于0 Buffer 对象的字符串解码器 在 fork 流程，setupChannel(child, ipc) 设置，其中涉及 Buffer 对象的字符串解码。 string_decoder 模块提供了一个 API，用一种能保护已编码的多字节 UTF-8 和 UTF-16 字符的方式将 Buffer 对象解码为字符串。基本用法 const { StringDecoder } = require('string_decoder'); const decoder = new StringDecoder('utf8'); const cent = Buffer.from([0xC2, 0xA2]); console.log(decoder.write(cent)); const euro = Buffer.from([0xE2, 0x82, 0xAC]); console.log(decoder.write(euro)); fork 源码解读 剩余部分见 exec 执行脑图 stdio ipc 通信：[0, 1, 2, 'ipc'] process.execPath 拿到 node 路径 重点 getValidStdio(stdio, false) 执行setupChannel(this, ipc)，增强 ipc 功能，在父、子进程之间启动 ipc：channel.readStart() new Control(channel) 创建 control 对象，用于执行 ipc 的ref 和 unref 方法 有数据读取时，进入 channel.onread child.send() 调用 target.send() 进行进程通信， 使用 pipe 进行数据传递 在执行的 js 文件中，process.send() 也是使用 target.send() 进行通信 Node 多进程源码总结 exec/execFile/spawn/fork的区别 exec : 原理是调用 bin/shell -c 执行我们传入的 shell 脚本，调用 execFile，但传参做了处理 execFile：原理是直接执行我们传入的 file 和 args，底层调用 spawn 创建和执行子进程，但通过监听 spawn 中广播的事件，建立了回调，且一次性将所有的 stdout 和 stderr 结果返回 spawn：原理是调用 internal/child_process，实例化了 ChildProcess 子进程对象，再调用 ChildProcess.prototype.spawn() 创建子进程并执行命令，底层调用了 child._handle.spawn() 执行 C++ process_wrap 中的 spawn 方法。执行过程是异步的。执行完后，通过 pipe 进行单向数据通信，通信结束后，子进程发起 child._handle.onexit 回调，同时 socket 会执行 close 回调。 fork：原理是通过 spawn 创建子进程和执行命令。使用 node 执行命令，通过 setupchannel 创建 IPC 用于子进程和父进程之间的双向通信 data/error/exit/close回调的区别 data：主进程读取数据过程中，通过 onStreamRead 发起回调 error：命令执行失败后发起的回调 exit：子进程关闭完成后发起的回调 close：子进程所有 Socket 通信端口全部关闭后发起的回调 stdout close/stderr close：特定的 PIPE 读取完成后调用 onReadableStreamEnd() 关闭 Socket 时发起的回调。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第四周 cluster深入浅出.html":{"url":"pages/jolly_chen/第四周 cluster深入浅出.html","title":"第四周 Cluster深入浅出","keywords":"","body":"cluster 工作原理 单个 Node.js 实例运行在单个线程中。 为了充分利用多核系统，有时需要启用一组 Node.js 进程去处理负载任务。 cluster 模块可以创建共享服务器端口的子进程。 工作进程由 child_process.fork() 方法创建，因此它们可以使用 IPC 和父进程通信，从而使各进程交替处理连接服务。 require 加载内置模块解析 判断内置模块 源码 function NativeModule(id) { this.filename = `${id}.js`; this.id = id; this.exports = {}; this.module = undefined; this.exportKeys = undefined; this.loaded = false; this.loading = false; this.canBeRequiredByUsers = !id.startsWith('internal/'); } // ... const { moduleIds, compileFunction } = internalBinding('native_module'); NativeModule.map = new Map(); for (let i = 0; i moduleIds：内置模块的路径+文件ming。通过 C++ 代码拿到 this.canBeRequiredByUsers：是否是内置模块，moduleIds 中，internal/ 文件夹下都是内置模块 cluster 执行流程 cluter 对象，是 EventEmitter 对象的实例，具有 event emit、on 等方法 cluster.fork([env]) env 要添加到进程环境变量的键值对。 返回：cluster.worker cluster.setupMaster([settings]) settings 用于修改默认的 fork 行为。 一旦调用，将会按照 settings 对 cluster.settings 进行设置。 所有的设置只对后来的 .fork() 调用有效，对之前的工作进程无影响。 process.execArgv 属性返回当·Node.js 进程被启动时，Node.js 特定的命令行选项。 这些选项在 process.argv 属性返回的数组中不会出现，并且这些选项中不会包括 Node.js 的可执行脚本名称或者任何在脚本名称后面出现的选项。 这些选项在创建子进程时是有用的，因为他们包含了与父进程一样的执行环境信息。 $ node --harmony script.js --version process.execArgv 的结果： ['--harmony'] process.argv 的结果： ['/usr/local/bin/node', 'script.js', '--version'] setup 事件 每当 cluster.setupMaster() 被调用时触发。 work.process 是 child_process.fork() 创建的进程 在主进程中，访问 cluster.workers 获得工作进程信息。其是一个哈希表，储存了活跃的工作进程对象，使用 id 作为键名。只能在主进程中访问 internal/cluster/child.js 规定了工作进程的行为，这里定义了 cluster.worker，保存工作进程对象的引用。 在工程进程中可访问，指向当前工作进程。 疑问 workerProcess 由 child_process.fork() 创建 'internalMessage' 事件怎么触发，返回的参数 message 和 handle 是什么？ 其 send 方法干了啥？ 见 child_process 异步源码解析文章 fork 部分，setupChannel(child, ipc) Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/jolly_chen/第四周 脚手架命令注册和执行过程开发.html":{"url":"pages/jolly_chen/第四周 脚手架命令注册和执行过程开发.html","title":"第四周 脚手架命令注册和执行过程开发","keywords":"","body":"脚手架命令注册和执行过程开发 本周收获 如何设计高性能脚手架 Node 多进程开发 JavaScript 面向对象的实战技巧 主要内容 图解高性能脚手架架构设计方法 封装通用的 Package 和 Command 类 基于缓存 + Node 多进程实现动态命令加载和执行 将业务逻辑和脚手架框架彻底解耦 Node 多进程开发——child_process源码分析 深入Node源码，看清 spawn / exec / execFile / fork 的本质区别 脚手架命令注册 使用 commander 库 脚手架优化 为什么要优化 cli 安装速度慢：所有 package 都集成在 cli 里，因此当命令较多时，会减慢cli的安装速度 当前的cil结构 灵活性差：init 命令只能使用 @imooc-cli-dev/init 包，对于集团公司而言，每个项目组的 init 命令可能都不相同，可能需要实现 init 命令动态化。 团队A使用 @imooc-cli-dev/init 作为初始化模块 团队B使用自己开发的 @imooc-cli-dev/my-init 作为初始化模块 优化结果 脚手架命令动态加载功能架构设计 架构图 node 命令执行源码 node -e \"require('./xx/yy/index.js')\" Package 对象功能 获取入口文件的路径 判断当前package是否存在 安装package 更新package 获取入口文件的路径 的实现 获取 package.json 所在目录，使用 pkg-dir 库 读取 package.json 找到属性 main，没有的话，找属性 lib，拼接为路径 路径兼容（macOS/windows） 安装package 使用 cnpm 的 npminstall 包安装。在执行 cnpm install 命令安装npm包时，实际用到的就是 npminstall 实例代码如下。npminstall() 返回一个 promise 对象。 const npminstall = require('npminstall'); const path = require('path'); const userhome = require('user-home') npminstall({ root: path.resolve(userhome, '.imooc-cli-dev'), // 模块路径 storeDir: path.resolve(userhome, '.imooc-cli-dev', 'node_modules'), // 实际存储位置，root + node_modules registry: 'https://registry.npm.taobao.org', pkgs: [ { name: 'foo', version: '~1.0.0' }, ], // 指定安装的包名和版本 }); 更新package fs-extra fs 的替代品。添加了 fs 没有的文件系统方法，并支持 Promise 。 mkdir -p 递归创建文件夹 获取最新 npm 模块版本号 查询最新版本号对应的路径是否存在 如果不存在，直接安装最新版本 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/linlei/":{"url":"pages/linlei/","title":"Linlei","keywords":"","body":"linlei - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/linlei/01-需求分析.html":{"url":"pages/linlei/01-需求分析.html","title":"需求分析","keywords":"","body":"需求设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/linlei/02-脚手架架构设计和搭建.html":{"url":"pages/linlei/02-脚手架架构设计和搭建.html","title":"脚手架架构设计和搭建","keywords":"","body":"脚手架架构设计和搭建 脚手架是什么 脚手架的本质是一个操作系统的客户端，他通过命令行执行，比如： vue create project 上面的命令由3部分组成： 主命令：vue command：create command的params：project 他表示创建了一个vue的项目，项目名称为project，以上是一个比较简单的脚手架命令，不过实际应用场景会更加复杂： vue create project --force 这里--force叫做option用来辅助脚手架确认在特定的场合下用户的选择，也可以理解成配置。 这里我们就会好奇这些指令是怎么来的？ 打开终端输入：vue -h Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. 通过面板我们可以看到Commands下有create，add等等一系列的命令。如果我们需要查看create的具体配置如下： Usage: create [options] create a new project powered by vue-cli-service Options: -p, --preset Skip prompts and use saved or remote preset -d, --default Skip prompts and use default preset -i, --inlinePreset Skip prompts and use inline JSON string as preset -m, --packageManager Use specified npm client when installing dependencies -r, --registry Use specified npm registry when installing dependencies (only for npm) -g, --git [message] Force git initialization with initial commit message -n, --no-git Skip git initialization -f, --force Overwrite target directory if it exists --merge Merge target directory if it exists -c, --clone Use git clone when fetching remote preset -x, --proxy Use specified proxy when creating project -b, --bare Scaffold project without beginner instructions --skipGetStarted Skip displaying \"Get started\" instructions -h, --help output usage information 那么我们输入这些指令之后到底发生了什么？ 脚手架实现原理 当用户输入在终端vue create project时： 脚手架的执行原理如下： 在终端输入vue create project 终端解析出vue命令 终端在环境变量中找到vue命令 终端根据vue命令链接到实际到文件vue.js 终端利用node执行vue.js vue.js解析command/options vue执行command 执行完毕，退出终端 脚手架原理进阶 开发一个脚手架 为什么要开发一个脚手架？ 1、减少时间，不必从零开始搭建初始项目，提高开发效率。 2、便于多人协作。 3、项目更新同步方便，只需要更新代码库中项目模板，即可下载最新的项目。 脚手架的开发流程 脚手架开发 创建npm项目 npm init -y 创建脚手架文件入口，最上方添加： #! /usr/bin/env node 配置package.json,添加bin属性，编写脚手架代码，发布npm 然后执行npm link软连接到node下,这个时候就可以直接使用在bin下定义的intest-cli了。 打开终端输入： intest-cli 打印： 开发cli 脚手架安装 以上是我们在本地开发中使用，如果项目发布到npm上了，那么就在终端输入npm i intest-cli -g进行全局安装，就可以进行使用了。 脚手架开发难点 分包：将复杂到系统拆分为若干个模块 命令注册：vue create vue add vue invoke 参数解析：vue command [options] options全称：--version,--help options简写：-V,-h 带params的options：--path/ Users/linlei/Desktop/vue-test 帮助文档： global help Usage Options Commands 还有很多，比如： 比如命令行交互 日志打印 命令行文字变色 网络通信，http/websocket 文件处理 ... 脚手架本地link标准流程 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件： cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件： cd your-lib-dir npm unlink cd your-cli-dir npm unlink your-lib 理解npm link: npm link your-lib: 将当前项目中的node_modules下指定的库文件链接到node全局下的库文件 npm link: 将当前项目链接到node全局node_modules中作为库文件，并解析bin配置，创建可执行文件 理解npm unlink: npm unlink将当前项目从node到全局node_modules下删除 npm unlink your-lib: 将当前项目中的库文件依赖删除 lerna lerna是一个优化给予git+npm的多package项目的管理工具 优势 大幅减少重复操作 提升操作的标准化 lerna是架构优化的产物，它揭示了一个架构真理，项目复杂度提升后，就需要对项目进行架构优化，架构优化的主要目标，往往以效能为核心。 如何使用 1.脚手架项目初始化 初始化npm项目-->安装lerna-->learn init初始化项目 2.创建package lerna create 创建package-->lerna add 安装依赖-->lerna link 链接依赖 3.脚手架开发和测试 lerna exec 执行shell脚本--> lerna run执行npm命令 --> lerna clean 清空依赖 -->lerna bootstrap 重装依赖 4.脚手架发布上线 lerna version bump version --> lerna changed查看上版本以来的所有版本 --> lerna diff 查看diff --> lerna publish发布 基于lerna创建项目 安装lerna npm install -g lerna lerna命令： lerna create xxx创建一个项目 lerna add axios我们可以看到在packages下的所有子项目都会安装这个依赖 lerna add axios packages/xxx给某个项目安装依赖 lerna exec -- rm -rf node_modules 删除目录下的所有的node_modules文件夹 lerna exec --scope xxx -- rm -rf node_modules 删除指定目录下的文件，xxx代表package.json的name值 lerna bootstrap 重装依赖 lerna run xxxxxx表示scripts脚本命令，所有的项目都会执行 lerna run --scope devname xxx执行指定目录下的脚本，devname表示package.json包名，xxx表示scripts脚本命令 yargs的基本使用 1.安装 npm i yargs 2.在项目中使用 #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') const arg = hideBin(process.argv) const dedent = require('dedent') // 终端信息栏对齐 const cli = yargs(arg) cli .usage('Usage: intest-cli [command] ') // 使用方式的介绍 .alias('h', 'help') // 别名 .alias('v', 'version') .wrap(cli.terminalWidth()) // 终端右侧的宽度 .epilogue(dedent`底部信息 111`) // epilogue给底部添加一个信息，dedent，终端左侧栏对齐 .demandCommand(1, 'A command is required. Pass --help to see all available commands and options.') // 最少输入的命令个数 .strict() // 严格模式 .options({ // 对全局的[command]都起作用可以处理多个option debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) .option('registry', {// 同options类似，处理单个 describe: '注册', alias: 'r' }) .group(['debug'], 'Dev Options') // 对option进行分组 .command('init [name]', 'create a project', (yargs)=> {// 执行命令 yargs.option('name', { type: 'string', describe: 'name of a project' }) },(args)=> { console.log(args) }) .command({ // 可以处理多个command以对象对形式处理 command: 'list', aliases: ['ls', 'li'], describe: 'list local packages', builder: (yargs) => { }, handler: (argv) => { console.log(argv) // 打印终端输入的指令 } }) .argv; Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/linlei/03-脚手架核心开发流程.html":{"url":"pages/linlei/03-脚手架核心开发流程.html","title":"脚手架核心开发流程","keywords":"","body":"脚手架核心开发流程 痛点分析 创建项目组件时，存在大量重复代码拷贝，快速复用已有沉淀 协同开发时，由于git操作不规范导致分支混乱，操作耗时，制定标准的操作规范，并集成到脚手架 发布上线耗时，容易出现各种错误，制定标准的上线流程和规范并集成到脚手 需求分析 通用到研发脚手架 通用到项目/组件创建能力 模版支持定制，定制后能够发布生效 模版支持快速接入，极地到接入成本 通用到项目/组件发布能力 发布过程自动完成标准的git操作 发布成功后自动删除开发分支并创建tag 发布后自动完成云构建，CDN，域名绑定 发布过程支持测试/正式两种模式 脚手架设计图 脚手架拆包策略 核心流程 命令 初始化 发布 模型层 command命令 project项目 component组件 npm模型 git仓库 支撑模块 git操作 云构建 工具方法 api请求 git api 脚手架拆包原则 核型模块 core 命令模块 command 模型模块 models 工具模块 utils core模块技术方案 准备阶段 命令注册 命令执行 命令执行流程 准备阶段 命令注册 命令执行设计技术点 核型库 import-local commander 工具库 npmlogs fs-extra semver colors user-home dotenv root-check 开始写代码 1.首先创建一个lerna项目: learn init intest-cli-dev 2.根目录下创建core，utils，models，commands文件夹，并修改lerna.json配置如下：{ \"packages\": [ \"core/*\", \"utils/*\", \"models/*\", \"commands/*\" ], \"version\": \"1.0.1\" } 3.将原项目packages下的core移入到创建的core目录下，同时将packages下的utils下，修改core项目为cli,如下图： 4.在cli/bin/index.js代码如下： #!/usr/bin/env node const utils = require('intest-cli-dev-utils') // console.log('111') // console.log(utils) const importLocal = require('import-local') const npmlog = require('npmlog') if(importLocal(__filename)) { npmlog.info('cli', '正在使用本地版本') } else { require('../lib')(process.argv.slice(2)) } import-local的作用当全局node_modules和本地node_modules中，存在相同的库，则优先加载本地node_modules中的库 npmlog打印工具 5.检查版本号开发 在core/cli/lib/index.js下写入代码如下： const pkg = require('../package.json') function checkPkgVersion() { const { version } = pkg // log.notice('cli', version) } 此时我们可以获取到配置文件package.json的版本号，那么现在我们需要考虑require加载资源的方式 require可加载的资源文件有.js, .json, .node 加载.js时需要我们必须在js文件中，使用module.exports=any或者exports.输出 加载.json时会使用JSON.parse进行转译从而得到一个json对象 .node是一个c++插件 如果我们加一个txt文件，暂且命名为test.txt，其内容如下: module.exports = function test() { console.log('11') } 我们使用require('./test.txt')()，这个时候代码依然会执行，这是为什么呢？原来我们是使用require的时候，如果加载的文件不是上述三种格式的文件，会默认当成js文件进行解析 npmlog的使用 1.使用lerna创建lerna create intest-cli-dev-log,项目会创建在core下，移入到utils下并进入当前目录，安装npmlognpm i npmlog -S,代码如下： 'use strict'; const log = require('npmlog') log.addLevel('success', 2000, { fg: 'green' }) // 降级处理 log log.level = process.env.LOG_LEVEL || 'info' //c 添加前缀 log.heading = 'intest' module.exports = log 2.如何在项目使用intest-cli-dev-log模块呢？ 首先在core/cli/package.json下,自动引入,注意file:../../utils/log是其相对路径目录，如下：{ ... \"dependencies\": { ... \"intest-cli-dev-log\": \"file:../../utils/log\", } } 然后在core/cli下npm link,此时就可以在core/cli中使用了。 6.检查Node版本 依然在core/cli/lib/index.js下创建方法checkNodeVersion方法，通过semver库（用于检测版本号的库），通过process.version获取node版本，以及代码中设置的最对版本进行判断，代码如下： const LOW_NODE_VERSION = '8.0.0' function checkNodeVersion() { // 1.获取当前node版本好 const currentVersion = process.version // 比对最低版本 const result = semver.gt(currentVersion, LOW_NODE_VERSION) // console.log(chalk.red(result)) if (!result) { throw new Error(chalk.red('当前版本过低，请升级node版本。 ') + chalk.blue(`最低版本: ${LOW_NODE_VERSION}`)) } } 6.检查root启动 我们可以使用process.getuid()来获取uid,如果返回值是0则说明说超级管理员，否则是一般用户。开发中一般是使用一般用户进行开发，如果需要降级，可以使用root-check这个库进行开发，使用也很简单，代码如下： function checkRoot() { const rootCheck = require('root-check') // 使用之后可降级为用户权限 rootCheck() } 7.用户主目录检查功能开发 const chalk = require('chalk) const pathExists = reuqire('path-exists').sync // 判读目录是否存在 const userHome = require('user-home') // 获取当前用户主目录 function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(chalk.red('当前登陆用户主目录不存在！')) } } 8.入参数检查和debug模式开发 入口参数就是我们在终端上输入的指令例如：vue create project,我们可以得到create和project参数 我们如何得到入口参数呢？这里我们使用minimist这个库来获取入口参数，代码如下： const args = require('minimist')(process.argv.slice(2)) const log = require('intest-cli-dev-log') function checkInputArgs() { checkArgs() } // 设置debug function checkArgs() { if(args.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL } 9.环境变量检查功能开发和npm全局更新功能开发 我们可以使用dotenv进行读取.env的配置内容，具体方法可以参考dotenv官方文档 具体代码如下： const dotEnv = require('dotenv) function checkEnv() { const dotEnvPath = path.resolve(userHome, '.env')// 获取本地.env文件内容 if (pathExists(dotEnvPath)) { config = dotEnv.config({ path: dotEnvPath }) } else { log.error('找不到.env') } createDefaultConfig() // 设置默认配置 } // 设置默认的环境变量 function createDefaultConfig() { const cliConfig = { home: userHome, } if(process.env.CLI_HOME) { cliConfig['cli_home'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cli_home'] = path.join(userHome, DEFAULT_CLI_HOME) } // console.log(cliConfig) process.env['CLI_HOME_PATH'] = cliConfig['cli_home'] } 9.通用npm API封装 实现这个功能需要如下步骤： 1.获取当前版本号和模块名 2.调用npm API获取说有的版本号和模块名 3.提取所有版本版本号，比对那些版本号是大于当前版本号的 使用lerna创建get-npm-info模块 lerna create intest-cli-dev-get-npm-info，并移入到utils/目录下 在core/cli/package.json下配置 如下,并进行软连接 npm link { ... \"dependencies\": { ... \"intest-cli-dev-log\": \"file:../../utils/log\", \"get-npm-info\": \"file:../../utils/get-npm-info\", } } get-npm-info模块下lib/index.js写入如下代码： 'use strict'; const axios = require('axios') const urlJoin = require('url-join') const semver = require('semver') function getNpmInfo(npmName, registry) { // TODO if (!npmName) return const registryUrl = registry || getDefaultRegistry() const res = urlJoin(registryUrl, npmName) return axios.get(res).then(resp => { if (resp.status === 200) { return resp.data } else { return null } }) .catch(err => { return Promise.reject(err) }) } function getDefaultRegistry(isOrigin = false) { return isOrigin ? 'http://registry.npmjs.org/' : 'http://registry.npm.taobao.org/' } async function getNpmVersion(npmName, registry) { const data = await getNpmInfo(npmName, registry); if (data) { // console.log(Object.keys(data.versions)) const r = Object.keys(data.versions) return r } else { return [] } } function getSemverVersion(baseVersion, versionList) { return versionList .filter(version => semver.satisfies(version,`^${baseVersion}`)) .sort((a,b)=>semver.gt(b,a)) } async function getNpmSemverVersion(baseVersion, npmName, registry) { const versionList = await getNpmVersion(npmName, registry) const newVersions = getSemverVersion(baseVersion, versionList) if(newVersions && newVersions.length) return newVersions[0] return } async function getNpmLatest(npmName, registry) { const versions = await getNpmVersion(npmName, registry) if(versions) { return versions.sort((a,b)=>semver.gt(a,b))[0] } return null } module.exports = { getNpmInfo, getNpmVersion, getNpmSemverVersion, getDefaultRegistry, getNpmLatest }; 4.获取最新的版本号，提示用户更新到该版本号 在core/cli/lib/index.js下写入如下代码： const { getNpmSemverVersion } = require('get-npm-info') async function checkGlobalUpdate() { // 1.获取当前版本号和模块名 const { version, name } = pkg // 2.调用npm API获取说有的版本号和模块名 const lastVersion = await getNpmSemverVersion(version, name) // 3.提取所有版本版本号，比对那些版本号是大于当前版本号的 // 4.获取最新的版本号，提示用户更新到该版本号 if(lastVersion && semver.gt(lastVersion,version)) log.warn(chalk.yellow(`请手动更新${name} 当前版本：${version} 最新版本：${lastVersion}`)) } commander到使用 快速实现一个commander脚手架，代码如下： function registryCommand() { program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false) .option('-tp, --targerPath ', '是否指定本地调试文件路径', '') program .command('init [projectName]') .option('-f,--force', '是否强制初始化项目') .action(exec) // 开启debug模式 program.on('option:debug', function(){ if (program.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL log.verbose('test') }) // 监听targetPath,并设置环境变量 program.on('option:targerPath', function() { // console.log(this.targerPath) process.env.CLI_TARGET_PATH = this.targerPath }) // 对未知命令进行监听 program.on('command:*', function(obj) { // 获取所有注册的命令 const allRegistryCommand = program.commands.map(cmd=>cmd.name()) console.log(chalk.red('未知命令：' + obj[0])) }) program.parse(process.argv) // 后面调用 // console.log(program.args) if(program.args && !program.args.length){ program.outputHelp() } } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/littlefish1900/":{"url":"pages/littlefish1900/","title":"Littlefish1900","keywords":"","body":"littlefish1900 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/littlefish1900/01-week01-作业.html":{"url":"pages/littlefish1900/01-week01-作业.html","title":"Week01 作业","keywords":"","body":"慕课乐高整体架构设计 需求分析 慕课乐高需求文档 范围 项目整体架构设计 模块设计 组件库，独立的第三方组件库，同时用于编辑器和 H5 自研统计服务，使用自定义事件，统计不同分享渠道的流量 作品的数据结构设计 基本思路 每个组件尽量符合 vnode 规范 用数据来组织数据，保证有序 尽量使用引用关系，减少冗余 work: { title: '', setting: {/*可能需要的配置项*/}, props: {/*页面body的一些设置*/}, components: [ { id: 'xxx1', name: 'xxx1', tag: 'image', attrs: { fontSize: '14px' }, children: [ '文本' ] }, { id: 'xxx2', name: 'xxx2', tag: 'text', attrs: { fontSize: '14px' }, children: null }, ] } //画布当前选中的组件 activeComponentId: 'xxx' } 图层通过计算属性获取 layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } 数据流转 核心： B 端、C 端、管理后台，共用一个数据库 创建作品： 初始化一个 JSON 数据 保存作品： 修改 JSON 数据 发布作品： 修改一个标记 C 端浏览作品： 获取 JSON 数据，SSR 渲染页面 后台管理作品： 修改数据标记，C 端判断是否展示 此外，C 端需要缓存，防止频繁访问数据库 扩展性保证 组件平台提供扩展组件功能 数据结构 setting 和 props 提供了扩展性 扩展编辑器的功能，通过扩展 vnode 实现，例如：组件隐藏，锁定 （讨论，集思广益） 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/liwen/":{"url":"pages/liwen/","title":"Liwen","keywords":"","body":"hi Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/liwen/01-需求分析和架构设计.html":{"url":"pages/liwen/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"week1 init Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/lwjcjmx123/":{"url":"pages/lwjcjmx123/","title":"Lwjcjmx123","keywords":"","body":"lwjcjmx123 - 学习记录 Week01 Week01-笔记 Week01-作业-技术方案设计 V1.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/lwjcjmx123/01-技术方案设计文档.html":{"url":"pages/lwjcjmx123/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":" 整体架构设计V1.0 需求背景 需求文档 创建作品、发布作品、管理作品 范围 根据我的理解，我将作品范围一共分为三层 展示层： 给用户展示海报的H5页面 用户生存海报的B端前端 管理员管理的M端前端 server层： 对应的展示层的各个应用的后端 扩展层： 如自研统计服务等 脚手架 组件平台等 模块设计 核心数据结构 { // 作品 work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就预留 */}, props: {/* 页面body的一些设置，如背景色等 */}， layers: [ /*我的思路是每个layer里一个组件列表*/ [ // 单个node，要符合VNode规范 { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: 20px }, children: [ '文本1' // 文本内容，有时候放在attrs或props中，没有标准，看情况而定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 图层的设计 我最初的思路是每个图层里都有一个组件列表，然后根据图层来渲染。 扩展性保证 保证配置可扩展：预留扩展字段如setting等 保证服务可扩展：各业务单独部署，互不影响 保证组件可扩展：Vnode格式本身即可满足扩展需求 开发提效 脚手架 脚手架的作用是方便后续工程快速启动。 组件平台 组件平台可以将公用组件封装起来。方便各项目复用，其实简单的封装组件，还是会有一些问题，比如多项目间组件版本管理。 运维保障 线上服务和运维服务用什么： 阿里云，腾讯云等厂商服务 安全： 数据库安全，服务器安全。xss，sql注入等问题。 监控和报警： 第三方监控如sentry，结合sdk可以发送邮件，钉钉消息，短信等告警信息 服务扩展性：流量大时怎么解决，云服务弹性扩容 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/lwjcjmx123/01-第一周笔记.html":{"url":"pages/lwjcjmx123/01-第一周笔记.html","title":"第一周笔记","keywords":"","body":" 核心数据结构设计 写技术方案设计文档 流程图 架构师思维： 全局思维： 考虑全面 整体思维 闭环思维 架构师思维来分析需求 业务组件库： 自定义事件统计 学习方法 要有耐心，不要只想着写代码。要多考虑需求和she ji 抛弃程序员思维 技术永远是为业务服务的，技术是实现业务增长的工具 注意事项 不要只关注于细节，要看整体，看范围 设计时判断可行性，不确定就调研一下 设计要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 抽奖活动设计 接口列表： 奖品列表： 对应奖品中奖几率 活动有效时长：活动上线及结束 调用抽奖接口：返回抽奖结果 兑奖的能力：怎么兑换奖品 抽奖资格校验 看完流程图后的想法： 全局思维还不够，没有以业务增长的角度看问题，分享没想到。统计分析没想到 全面 完整 闭环 这三点都没想到 核心数据结构设计 保存的数据结构 数组结构 分图层保存，低级图层在前面，渲染的时候按图层渲染 数据同步 双向绑定数据，左边组件的数据和右边编辑器里一致 图层设计 每个图层一个数组。数组里是组件 思考： 未考虑到Vnode形式，以前从来就没有用vnode来代替自己的DSL，这是一种新的思路，给我启发了很多。 用vuex来保存数据的话，应该是拖动组件的时候一直延时调用mutation来更新右边的属性列表。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/mazy/":{"url":"pages/mazy/","title":"Mazy","keywords":"","body":"mazy - 学习记录 Week01 Week01-作业-整体架构设计 V1.0 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/mazy/01-week01.html":{"url":"pages/mazy/01-week01.html","title":"Week01","keywords":"","body":"第一周笔记 收获 自身角度 我目前职位是高级前端工程师, 从今年开始, 开始承担项目负责人的职务, 从老师的讲课中发现大部分还是跟自己的现状比较吻合 虽然说是项目负责人, 但是考虑问题的角度更多还是以前端程序员的角度出发, 这个好做,这个不好做, 这个会有什么问题等等的考虑 在开需求评审的时候很少在整体的角度思考问题, 既需求是不是合理, 做的东西是否有输出有体现, 如何更好的交互等 在开发过程中, 要保证准时上线, 那么可能会跟产品有分歧, 砍掉需求等 总体来说, 目前的状态大多数还是跟产品对立的形式, 并没有统一战线, 使项目向着更好更稳定的方向发展 项目 项目的整体划分 B端和编辑器 biz-editor-FE biz-editor-server C端 H5(SSR) 管理系统 admin-FE admin-server 组件库 统计服务 三方免费pv/uv 自研自定义事件统计服务 为什么这样分 前后端分离, 单独开发, 整体提升工作效率, 这个是必然, 术业有专攻 一个系统从来都不是单纯存在的, 有前台必然有后台, 所以有BC端, 必然有管理系统 组件库, 这个可以复用, 当多个系统同时使用同一套组件库,可以直接看文档传参数直接使用. 或者可以有专门人员来维护, 减少开发成本 统计服务,几乎所有网站都要用到统计, 简单的pv和uv,这个比较浅显, 那么还有一些业务较复杂的统计, 三方很难普及到, 或者说收费高, 那么就需要自己实现一套, 满足于系统业务的统计服务 数据结构 考虑因素 是否可扩展,个人认为比较重要 结构是否清晰, 或者大多数人可以接受 数据结构本身的考量, 既哪些数据结构具有什么样的特点 实现方案 在设计组件或者store的时候都需要考虑扩展性问题 怎么传, 怎么做兼容 如何合并 结构清晰, 数组, 对象的特点, 在设计结构的时候, 是否冗余, 本来可以使用结构特点就可以实现, 最后又加了另外的结构来解决问题, 一直下去, 其他人很难维护 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/qingfeng1/":{"url":"pages/qingfeng1/","title":"Qingfeng1","keywords":"","body":"清风 - 学习笔记 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/qingfeng1/01-第一周学习笔记.html":{"url":"pages/qingfeng1/01-第一周学习笔记.html","title":"第一周学习笔记","keywords":"","body":"需求总揽 全局思维，闭环思维，架构师思维 职责 在深入理解业务需求之后，能用软件把业务模拟出来。并且保证稳定执行和后续增长。 注意事项 不要关注细节，要看整体，看范围 考虑扩展性（这就需要深入理解业务，否则你也不知道未来将如何扩展） 考虑可行性，不确定的就调研一下 考虑实现成本，不要为了设计而设计，技术要永远服务于业务，永远都要选择最简单的实现方案 需要项目 B端和编辑器，做前后端分离 biz-editor-fe biz-editor-server H5适合做SSR，因为要考虑性能 H5-server 管理后台，做前端分析 admin-fe admin-server [注意] 大家都到处嚷嚷SSR，使用还是得分场景。一般来讲，toB的不适合用，toC的适合用。所以，架构设计要考虑成本，要用最简单的方案，不要为了设计而设计 添加时向服务端传递的数据的大致是什么样子 { // 作品 work: { title: '标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: { /* 页面body的一些设置，如背景色 */}, components: [ // components 要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx',// 每个组件都有id，不重复 name: '文本1', attrs: {fontSize: '20px'}, children: [ // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 '文本1' ] } ] }, activeComponentId: 'xxx' } layers (图层)使用vuex getter，使用computed计算出来的索引 { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 基本思路： 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据流转 核心：B端、C端、管理后台，公用一个数据库 创建作品：初始化一个JSON数据 保存作品：修改JSON数据 发布作品：修改一个标记，仅此而已 C端浏览作品：获取JSON数据，SSR渲染页面 屏蔽作品：修改一个标记，C端来判断 当然，其中C端还有缓存，防止频繁访问数据库 技术方案设计文档 关于技术方案设计文档 为何难写？ 没有规范可依 不常写 如何写，技巧： 随性一些，解释一下你要如何做，即可 可以先尝试写一部分代码，捋一捋思路，再来写文档 写设计方案文档是浪费时间吗？ 如果你真的想明白了，最多浪费你1-2h时间，不会导致项目延期 如果你写不出来，说明你没想明白，正好暴露了问题 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/qingfeng1/02-第二周学习笔记和作业.html":{"url":"pages/qingfeng1/02-第二周学习笔记和作业.html","title":"第二周学习笔记和作业","keywords":"","body":"匹配字符相等算法 // node_modules reverse var nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ]; let from = \"F:\\node-test\\lerna-3.22.1\\lerna-3.22.1\";// 绝对路径 // 末尾开始找 const CHAR_BACKWARD_SLASH = 92; // \\ const CHAR_BACKWARD_SLASH = 47;// / const CHAR_COLON = 58;// : for (var i = from.length - 1; i >= 0; --i) { const code = from.charCodeAt(i); if (code === CHAR_BACKWARD_SLASH || code === CHAR_FORWARD_SLASH || code === CHAR_COLON) { if (p !== nmLen) // /.../之间不能与node_modules匹配，加上node_modules paths.push(from.slice(0, last) + '\\\\node_modules'); last = i; p = 0; } else if (p !== -1) { if (nmChars[p] === code) { //匹配 ++ ++p; } else {//新的目录，重新开始计数 p = -1; } } } yargs 脚手架构成 bin：package.js中配置bin属性，npm link本地安装 command：命令 options：参数（boolean、string、number） 文件顶部增加 #!usr/bin/env node 脚手架初始化流程 构造函数：Yargs() 常用方法： Yargs.options Yargs.option Yargs.group Yargs.demandCommand Yargs.recommendCommands Yargs.strict Yargs.fail Yargs.alias Yargs.wrap Yargs.epilogue 脚手架参数解析方法 hideBin(process.args)/Yargs.argv Yargs.parse(argv,options) 命令注册方法 Yargs.command(command,describe,builder,handler) Yargs.command({command,describe,builder,handler}) Lerna实现原理 Lerna是基于git+npm的多package项目管理工具 实现原理 通过import-local优先调用本地lerna命令 通过Yargs生成脚手架，先注册全局属性，再注册命令，最后通过parse方法解析参数 lerna命令注册时需要传入builder和handler两个方法，builder方法用于注册命令专属的options，handler用来处理命令的业务逻辑 lerna通过配置npm本地依赖的方式来进行本地开发，具体方法是在package.json的依赖中写入：file:your-local-module-path，在lerna publish时会自动将该路径替换 Node.js模块路径解析流程 Node.js项目模块路径解析是通过require.resolve方法来实现的 require.resolve就是通过Module._resolveFileName方法实现的 require.resolve实现原理： Module._resolveFileName方法核心流程有3点： 判断是否为内置模块 通过Module._resolveLookupPaths方法生成node_modules可能存在的路径 通过Module._findPath查询模块的真实路径 Module._findPath核心流程有4点： 查询缓存（将request和paths通过\\x00合并成cacheKey） 遍历paths，将path与request组成文件路径basePath 如果basePath存在则调用fs.realPathSync获取文件真实路径 将文件真实路径缓存到Module._pathCache（key就是前面生成的cacheKey） fs.realPathSync核心流程有3点： 查询缓存（缓存的key为p，即Module._findPath中生成的文件路径） 从左往右遍历路径字符串，查询到/时，拆分路径，判断该路径是否为软链接，如果是软连接则查询真实链接，并生成新路径p，然后继续往后遍历，这里有1个细节需要特别注意： 遍历过程中生成的子路径base会缓存在knownHard和cache中，避免重复查询 遍历完成得到模块对应的真实路径，此时会将原始路径original作为key，真实路径作为value，保存到缓存中 require.resolve.paths等价于Module._resolveLookupPaths，该方法用于获取所有node_modules可能存在的路径 require.resolve.path实现原理： 如果路径为/（根目录），直接返回['/node_modules'] 否则，将路径字符串从后往前遍历，查询到/时，拆分路径，在后面加上node_modules，并传入一个paths数组，直到查询不到/后返回paths数组 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/renderman/":{"url":"pages/renderman/","title":"Renderman","keywords":"","body":" .logo{ margin-bottom:15px; height:60px; line-height:60px; } .logo img{ height:100%; vertical-align:middle; } .logo img+span{ vertical-align:middle; margin-left:10px; font-size:35px; font-weight:700; color:#459ece; } h1,h2{font-size:0!important;visibility:hidden;} h3{ position:relative; text-indent:1em; } h3:before{ content:\"\"; position:absolute; top:0;left:0; width:0.15em;height:100%; background-color:#459ece; } RENDERMAN _ __ week01 “永远选择最简单的实现方案” -双越 乐高项目的需求分析思考 乐高项目的整体技术方案思考过程 乐高项目的整体技术方案文档 week02 “架构优化的目的是效能提升” -Sam 脚手架是什么 使用原生方式开发一个分包的脚手架 Lerna 是什么 使用 Lerna 开发一个分包的脚手架 lerna 的实现原理 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/ricky94/":{"url":"pages/ricky94/","title":"Ricky94","keywords":"","body":"Ricky94 - 学习笔记 第一周：需求分析和架构设计：做什么，如何做？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/ricky94/01-第一周.html":{"url":"pages/ricky94/01-第一周.html","title":"第一周","keywords":"","body":"第一周：需求分析和架构设计：做什么，如何做？ 需求设计 架构脱离不了业务。要做好架构必须要深入理解需求、参与需求、看透需求背后的业务本质。 PV（Page View）：即页面浏览量或点击量，用户每一次对网站中的每个网页访问均被记录一个PV。用户对同一个页面的多次访问，访问量累计，用以衡量网站用户访问的网页数量。 UV（Unique Visitor）：是指通过互联网访问、浏览这个网页的自然人。一天内同一个访客多次访问仅计算一个UV。 自定义事件：通过代码埋点，对用户行为进行追踪，完成对用户行为细节的记录。 架构设计 分析需求，确定需要创建的项目 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/rookie/第八周Clipboard.html":{"url":"pages/rookie/第八周Clipboard.html","title":"第八周Clipboard","keywords":"","body":"Clipboard.d.ts文件定义 从这次作业中，关于ts的类型定义学到了很多东西，通过查看github中定义文件 1.ts 2.ts type Action = 'cut' | 'copy' type triggerType = string | HTMLElement | HTMLCollection | NodeList declare class MyClipboard { constructor ( selector: triggerType, options: MyClipboard.Options) destroy(): void resolveOptions(options: MyClipboard.Options | {}): void listenClick(trigger: triggerType): void on(type: Response, handler: (e: MyClipboard.Event) => void): this; on(type: string, handler: (...args: any[]) => void): this; } declare namespace MyClipboard { interface Options { action?(elem: Element): Action target?(elem: Element): Element text?(elem: Element): string container?: Element } interface Event { action: string; text: string; trigger: Element; clearSelection(): void; } } 第一次知道了在namespace中也可以定义interface，学到了在接口中判断是否属于函数的方法。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/wanda/":{"url":"pages/wanda/","title":"Wanda","keywords":"","body":"wanda 你好，我是wanda，我的QQ号240329435，希望与大家共同学习共同进步 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/wanda/01-第一周笔记和作业.html":{"url":"pages/wanda/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） https://www/yuque.com/imooc-lego/zlz87z 范围 整体设计，架构设计，没有细节 模块设计 模块拆分和关系图（如图） 特殊的模块重点说明 组件库 ：独立的第三方组件 同事用于H5和B端的编辑器，所见即所得 自研统计：有助于自定义事件的统计 数据结构 vuex store 的结构 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 扩展性保证 开发提效 脚手架 组件平台 运维保障 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/wanda/02-第二周笔记和作业.html":{"url":"pages/wanda/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"脚手架的意义、使用方法和实现原理 脚手架的价值- 提升前端研发效能 自动化：重复代码拷贝、git操作、发布上线操作 标准化：项目创建发布流程 数据化：是研发过程可量化，方便多人多团队协力开发 脚手架的执行流程 脚手架的命令分四步：主命令 command option param 主命令 ： 终端（cmd、gitbase）解析主命令 在环境变量中找到主命令的位置，通过软链接找到真正执行的文件 然后执行命令 解析commamd命令 并解析command后面的参数 脚手架开发 建立npm项目 在package.json中加入bin属性设置脚手架入口 发布项目到npm 下载 npm项目后 会在node中设置软连接到bin属性中文件的位置，然后就可以执行了 脚手架本地开发调试 npm link 本地脚手架在node中安装 npm link （lib） 在node中安装（lib）另一个脚手架，并加入model 要安装线上发布的脚手架是记得unlink本地的脚手架 用lerna管理大型项目的脚手架 lerna能极大的减少重复操作，能统一版本之类的问题，替身操作的规范性 用lerna管理的脚手架一般用group上传npm 形如@xxx/xxx 主要刘场如下图 lerna源码分析 入口文件是package中的bin \"lerna\": \"core/lerna/cli.js\"，而package的位置配置在lerna.json里面 建立脚手架主要使用yargs yargs 的使用 先建立yargs的对象 然后对yargs进行设置 主要设置的参数有:option、alias、recommendCommands、strict 然后对yargs进行command设置 最后解析参数argvlerna通过配置本地依赖的方法进行本地开发，在packages中 写入形如file:helpers/calls-back ，在lerna publish中会将该地址变化 node.js 模块路径解析流程-后续再看 git fork后如何同步、更新 git remote -v 查询是否添加了更新源，如果没有，upsteamgit remote add upstream xxxx.git 主项目url git fetch upstream 更新 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/wanda/03-第三周笔记和作业.html":{"url":"pages/wanda/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"脚手架核心流程开发 脚手架模块拆分策略和core模块技术方案 核心流程：core 命令：commands 初始化 发布 清楚缓存 模型层：models command命令 project项目 component组件 npm模块 git仓库 支撑模块 utils git操作 云构建 工具方法 api请求 gitapi core模块技术方案 core模块prepare具体代码 一、按脚手架模块拆分策略拆包 拆成core、commands、utils、models 并且修改lerna.json { \"packages\": [ \"core/*\", \"commands/*\", \"utils/*\", \"models/*\" ], \"version\": \"1.0.1\" } 二、core主流程 在bin文件中建立主流程并修改package里面的入口文件 由于是入口文件需要node解析所以要在头部加上#! /usr/bin/env node ```javascript const importLocal = require('import-local') if(importLocal(__filename)){ require('npmlog').info('cli','正在使用 cli本地版本') }else{ require('../lib')(process.argv.slice(2)) } 主要来监控不是用本地本地版本（参考了lerna的代码） 是一个入口文件 ### 三、prepare 具体代码 - checkPkgVersion 检查版本号 其中涉及到了require的用法，require可以引入js文件和json文件，默认除了json都默认js文件。 - checkNodeVersion 检查node版本 设置一个最低版本比较当前版本和最低版本，如果版本吧太低要处理，会用到semver组件来比较版本大小 - checkRoot 检查是否为root权限，如果不是升级问root权限，会用到root-check组件 - checkUserHome 检查用户主目录 会用到osHomedir组件 - checkArgs 检查入参 监听入参然后处理 会用到minimist组件来处理参数 - checkEnv 检查环境变量 判断是否有特定的环境变量如果有就用dotenv组件解析内容，将其分配给 process.env，如果没有就手动添加 - checkGlobalUpdata 检查版本提示更新 要获取npm上最新版本，比较和现在的版本，如果有差别要提示更新 会新建一个npm组件来获取这个事。如下： - 要要npm给的接口，可以选择速度快的淘宝镜像'http://registry.npmjs.org' : 'http://registry.npm.taobao.org'加上npmName，要用到axios组件，注意返回promise对象 - 对获取的版本号进行排序，拿最新的和现有版本比较 ## commander 的使用方法 - 用途是注册命令和yargs的用途类似 - 阅读commander npm的官方文档 ## 用node支持ES model模式的开发 - node现在是不支持ES model开发的，只能用CMD模式开发即require来开发，如果要用ES model开发有两个方法，一个是用webpack来把代码编译成node能识别的模式，一种是用.mjs来作文js代码的后缀，还在试验环节，目前主要学习第一种方法 ### 使用webpack 下载webpack和webpack-cli ，新建webpack.config.js文件 ```javascript const path = require('path') module.exports = { entry:'./bin/core.js', output:{ path: path.join(__dirname,'/dist'), filename:'core.js' }, mode:'development', target:'node', } 其中entry设置传入的其实文件;output设置传出的文件;mode是文件类型有development和production两种开发模式易于阅读，生产模式体积小;target设置node可以用node环境里面的内置库 在scripts里面添加\"build\": \"webpack\",\"dev\": \"webpack -w\"命令 使用npm run build和npm run dev来执行webpack build是一次性编译，dev是持续编译终端要被占用 学习心得 npm里面有很多好用的组件，要习惯看npm上面的英文文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/xggg/":{"url":"pages/xggg/","title":"Xggg","keywords":"","body":"学习笔记和作业打卡 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/xggg/01-第一周作业.html":{"url":"pages/xggg/01-第一周作业.html","title":"第一周作业","keywords":"","body":"第一周架构方案设计文档 需求 https://www.imooc-lego.com/ 范围（三个方面） 普通用户：就是看到成品的用户，可以对海报作品进行分享，形成自增长，用 H5 SSR 方式开发 企业用户：B端用户可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品。前后端分离：Biz-FE、Biz-server 平台管理员（admin）：项目管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计。前后端分离： admin-FE + admin-server 模块设计 数据结构 每个组件尽量符合vnode规范 用数组组织数据，有序 尽量使用引用关系，防止冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据关系流转 共用一个数据库 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证（组件拓展，功能拓展，数据结构拓展；引导讨论拓展性） 扩展组件，数据结构层面扩展 扩展编辑器的功能，例如：组件隐藏、锁定等 扩展页面的配置 开发提效（复用性，易用性） 脚手架：创建发布 组建平台：减少冗余代码 运维保障 线上服务和运维服务 安全 监控和警报 服务扩展性：流量大时可随时扩展服务配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/":{"url":"pages/yhtx1997/","title":"Yhtx1997","keywords":"","body":"yhtx1997 - 课程记录 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/01-第一周作业.html":{"url":"pages/yhtx1997/01-第一周作业.html","title":"第一周作业","keywords":"","body":"幕客乐高技术方案 目录 需求 总体需求 原始需求：用户可按自身需求生成页面，并可分享出去供其他人浏览 确定范围 用户可编辑页面（后台编辑） 其他人可浏览（H5页面） 可分享（埋点，数据分析） 模块设计 模块拆分和关系图；关键功能职责；特殊模块重点说明 模块拆分 后台编辑项目 后台编辑接口项目 后台管理项目 后台管理接口项目 H5 项目 - SSR 公用组件库项目 公用接口项目 埋点项目 特殊模块说明 后台管理和编辑拆两个项目的原因：管理员可以使用用户的操作，以及用户没有的操作将敏感操作和正常操作，尽量隔离 多拆一个公用接口项目：后台管理和编辑，有高度相似接口，例如都支持新增、编辑、删除页面等基础操作 公用组件库：后台管理和编辑有相似组件（例如：页面列表），后台和H5有相似组件（例如：后台预览和H5显示） H5只拆一个项目：没必要再多拆一个后端接口项目（后端预览可通用过来），且页面数据及渲染在编辑后，页面展示结果唯一，以及可能需要较好的 SEO优化，故此使用 SSR 可提升首屏速度，及SEO 关系图 数据结构 数据结构原则 使用 VNode 规范（拓展性好） 有序数据使用数组（数组是一组有序的相同类型的数据） 尽量使用引用关系，不要冗余（保证数据唯一性） 最外层一定要是对象（方便拓展新的顶级参数） 数据结构示例 { page: { // 与H5页面渲染相关的字段 id: \"加密后的用户id-加密后的创建时间-随机标识码\"， title: \"标题\", setting: { // 页面功能性配置 }, style: { // 页面样式配置 }, componets: [ { tag: '组件名', id: '加密后的(用户id+随机标识码)', flag: '', // 模板类（直接返回子元素），组件类（子元素外层包了一层），内容类（最底层的文本显示） data: { // 当前组件的数据 }, children: [ // 子组件：无限套娃 { tag: '组件名', id: '加密后的(用户id+随机标识码)', flag: '', // 模板类（直接返回子元素），组件类（子元素外层包了一层），内容类（最底层的文本显示） data: { // 当前组件的数据 }, children: [ // 子组件 ], setting: { // 组件功能性配置 }, attrs: { style: { // 组件样式 } // 标签属性 }, event: { // 要触发的事件 } } ], setting: { // 组件功能性配置 }, attrs: { style: { // 组件样式 } // 标签属性 }, event: { // 要触发的事件 } } ] }, setting: { // 设置 }, status: { currentComponentId: -1 // 当前选中组件，默认整个页面 } } 数据流转关系图 拓展性 新组件怎么拓展 新功能怎么拓展 数据结构怎么拓展 引导讨论拓展性（大家一起讨论，不是某个人单独就能确定的） 开发提效 复用性，易用性 运维保障 如何保证系统；线上服务运维，安全，监控，报警，服务拓展性 公司有自研运维保障服务，要熟悉自研的 公司没有自研运维保障服务，要熟悉常见服务商提供的 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/01-第一周笔记.html":{"url":"pages/yhtx1997/01-第一周笔记.html","title":"第一周笔记","keywords":"","body":"笔记 内容分享目录格式 标题 讲师 将收获什么 主要内容 关键词 学习方法 注意事项 架构师原则及思维 总体思维导向 以业务价值为前提（首先要有），提升价值为最终目的（然后增加），并铺垫好今后可能发展的基础（最后发展） 需求 > 设计 > 开发 通过技术手段保证业务的增长 技术为业务服务 设计时判断可行性，不确定就调研 设计时要考虑复杂度，越简单越好，不要过度设计，不要为了设计而设计 脱离业务的架构就是耍流氓。架构师需要深入理解需求、参与需求、看透需求背后业务本质。 如何深入理解需求 三方面考虑：全面、 完整、 闭环 拿到需求 -> 理解需求 -> 前因后果（哪里来那里去） -> 整体流程 -> 业务增长 -> 回顾总结 实际使用场景：从用户角度思考问题，简单好用 产品及运营角度： 1. 产品第一，运营第二；2. 看重投入产出比，方便做决策 统计，汇总，分析，基础建设； 风险控制、 稳定性;系统稳定才能保证有人长期使用 架构师职责：深入理解需求，用软件把业务模拟出来。保证稳定运行，持续增长。技术永远为业务服务。 如何做技术设计 基于业务 做方案先不要太过关注细节，要看整体，确定范围都哪些 拓展性，可行性 可复用部分 实现成本（永远选择最简单的实现方案） 不确定就调研 技术方案目录示例 标题 目录 需求 范围 模块设计 数据结构 拓展性保证 开发提效 运维保障 数据结构设计思路 拓展性字段的考虑，字段名称的统一性，字段尽可能的少 VNode(将组件或元素用数据描述出来) 单一数据源存储所有的数据（索引类尽量使用引用，避免多数据源强关联关系） 数据流的周期 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/02-第二周作业.html":{"url":"pages/yhtx1997/02-第二周作业.html","title":"第二周作业","keywords":"","body":"脚手架执行流程 根据流程反推如何开发 npm 包项目要有bin 配置指向js文件 项目发布到 npm 官网 js 入口文件内指定使用 node 执行自己 #!/usr/bin/env node 安装到 node 目录下的 node_modules 环境变量软连接到 node 目录下的 node_modules/脚手架/入口文件 疑问 问： @vue/cli 后为什么使用命令是 vue ？ 答：因为 @vue/cli 只是 npm 包名，实际命令是在 package.json 的 bin 属性配置 问：全局安装 @vue/cli 时发生了什么？ 答：首先 npm 下载包文件到 node 安装目录下的 node_modules，然后将 package.json 文件 bin 属性中的命令配置成环境变量，之后就可以使用相关命令了 问：为什么 vue 命令指向了一个js文件，我们确可以直接运行它？ 答： 因为在 js 文件头部，我们声明了要用 node 去执行当前文件，所以实际上是：系统通过 node 执行 js 文件 基于 lerna 发布的脚手架（无功能） https://www.npmjs.com/package/fe-lazy-cli https://www.npmjs.com/package/@fe-lazy-cli/core https://www.npmjs.com/package/@fe-lazy-cli/utils Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/02-第二周笔记.html":{"url":"pages/yhtx1997/02-第二周笔记.html","title":"第二周笔记","keywords":"","body":"笔记 内容分享目录格式 标题 讲师 将收获什么 主要内容 关键词 学习方法 注意事项 脚手架架构设计和框架搭建 总体思维导向 需求分析，架构设计，开源项目的深入研究 学习方法 掌握原理 独立思考 总结反思 深度剖析优秀开源项目，由表及里，由浅入深 视角切换，多切换架构师视角，全方位思考 脚手架开发必要性 提升研发效能 脚手架核心价值 将研发过程 自动化、标准化、数据化 自动化： 项目重复性代码复制粘贴/git操作/发布上线 标准化： 项目创建/git flow/发布流程/回滚流程 数据化： 研发过程系统化、数据化；使得研发过程可量化 和自动构建工具的区别 不满足需求：jenkins、travis通常在git hooks中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动化、本地git操作自动化等 定制复杂：jenkins、travis定制过程需要开发插件，其过程较为复杂，需要使用Java语言，对前端同学不够友好 什么是脚手架 脚手架就是命令行操作系统的客户端，例如： vue create vue-test-app --force -r https://registry.npm.taobao.org 命令的组成 主命令：vue 子命令 command: create 子命令参数 command 的 param: vue-test-app 配置 option： -r --force 配置参数 option 的 param：https://registry.npm.taobao.org 脚手架执行流程 根据流程反推如何开发 npm 包项目要有bin 配置指向js文件 项目发布到 npm 官网 js 入口文件内指定使用 node 执行自己 #!/usr/bin/env node 安装到 node 目录下的 node_modules 环境变量软连接到 node 目录下的 node_modules/脚手架/入口文件 疑问 问： @vue/cli 后为什么使用命令是 vue ？ 答：因为 @vue/cli 只是 npm 包名，实际命令是在 package.json 的 bin 属性配置 问：全局安装 @vue/cli 时发生了什么？ 答：首先 npm 下载包文件到 node 安装目录下的 node_modules，然后将 package.json 文件 bin 属性中的命令配置成环境变量，之后就可以使用相关命令了 问：为什么 vue 命令指向了一个js文件，我们确可以直接运行它？ 答： 因为在 js 文件头部，我们声明了要用 node 去执行当前文件，所以实际上是：系统通过 node 执行 js 文件 脚手架开发流程 开发流程 创建 npm 项目npm init -y 创建入口文件，并在顶部声明执行方式#!/usr/bin/env node 配置 bin 属性 编写代码 发布 npmnpm publish 使用流程 安装npm install -g 脚手架 使用脚手架 <> [] 脚手架开发难点 分包：复杂的系统模块拆分 命令注册 参数解析 options 全称 options 简称 option 参数 params 命令行交互 日志打印 命令行文字变色 网络通信 文件处理 帮助文档 npm 本地开发调试 npm link 查找环境变量 which 变量名 在 npm 包目录下将当前包链向 全局环境变量 npm link 将项目 node_modules 目录下指定npm 包链向 全局环境变量 npm lint 要使用的npm包名 在全局环境变量中取消 npm 的 link 指向 npm unlink // 当前目录 npm unlink 包名 // 当前项目 node_modules 目录下指定包名 lerna 介绍（多 package 项目管理） Lerna 是一个用于优化管理基于 git + npm 的多 package 项目的工具 node原生命令注册 参数解析 node 核心库 process argv 属性：所有命令行 命令参数数组 原生脚手架开发痛点 痛点一：重复操作 多 package 本地 link 多 package 依赖 多 package 单元测试 多 package 代码提交 多 package 代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互版本依赖的升级 package 越多，管理复杂度越高 lerna 优势 大幅减少重复操作 提升操作标准化项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 babel vue-cli create-react-app 都在使用 lerna 管理项目 lerna 开发流程 项目初始化 初始化 npm 项目 安装 lerna lerna init 初始化项目 创建package lerna create 创建package lerna add 安装依赖 lerna link 链接依赖 脚手架开发和测试 lerna exec 执行 shell 脚本 lerna run 执行 npm 命令 lerna clean 清空依赖 lerna bootstrap 重装依赖 脚手架发布上线 lerna version bump version lerna changed 查看上版本以来的所有变更 lerna diff 查看 diff lerna publish 项目发布 注意事项： lerna publish 发布时会自动执行： git add package-lock.json ，所以 package-lock.json 不要加入 .gitignore 先创建远程仓库，并且同步一次 master 分支 执行 lerna publish 前先完成 npm login 如果发布的 npm 包名为： @xxx/yyy 的格式，需要先在 npm 注册名为：xxx 的 organization，否则可能会提交不成功 发布到 npm group 时默认为 private，所以我们需要手动在 package.json 中添加如下配置: \"publishConfig\": { \"access\": \"public\" } lerna exec 和 lerna run --scope 属性后添加的是包名，而不是 package 的路径，这点和 lerna add 用法不同 lerna clean 只会删除 node_modules ，不会删除 package.json 中的依赖 lerna link 如果未发布上线，需要手动将依赖添加到 package.json 再执行 lerna link lerna add 第一个参数：添加 npm 包名 第二个参数：本地 package 的路径 选项： --dev：将依赖安装到 devDependencies，不加时安装到 dependencies lerna add [loc] --dev lerna init 会初始化 git 但是不会创建 .gitignore VSCode调试技巧 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/03-第三周作业.html":{"url":"pages/yhtx1997/03-第三周作业.html","title":"第三周作业","keywords":"","body":"作业 脚手架架构设计图 脚手架准备过程代码 主要函数 async function core() { try { // 检查 node 版本号 checkNodeVersion(); // root 降级 checkRoot(); // 检查主目录 checkUserHome(); // 检查入参 checkInputArgs(); // 检查环境变量 checkEnv(); // 检查更新 await checkGlobalUpdate(); // 命令 commands(pkg); } catch (error) { log.error(colors.red(error.message)); } } 检查node版本号 function checkNodeVersion() { const currentNodeVersion = process.version; const lowestVersion = constant.LOWEST_NODE_VERSION; if(semver.lt(currentNodeVersion, lowestVersion)) { throw new Error(colors.red(`需要安装 ${lowestVersion} 及以上版本的 node`)); } } root 降级 function checkRoot() { const rootCheck = require('root-check'); rootCheck(); } 检查主目录 function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error('当前用户主目录不存在！'); } } 检查入参 function checkInputArgs() { const minimist = require('minimist'); args = minimist(process.argv.slice(2)); checkArgs(); log.verbose('debug', 'test deubug level'); } 检查更新 async function checkGlobalUpdate() { const currentVersion = pkg.version; const npmName = pkg.name; const lastVersion = await getNpmSemverVersion(currentVersion, npmName); if (lastVersion && semver.gt(lastVersion, currentVersion)) { log.warn(colors.yellow(`最新版本号：${lastVersion} 请使用 npm install -g ${npmName} 更新版本！ 获得更好的使用体验！`)); } } 检查变量 function checkEnv() { const dotEnv = require('dotenv'); const dotEnvPath = path.resolve(userHome); if (pathExists(dotEnvPath)) { config = dotEnv.config({ path: dotEnvPath }); } createDefaultConfig(); log.verbose('环境变量', config); } 创建默认配置 function createDefaultConfig() { const cLiConfig = {}; if (process.env.FE_LAZY_CLI_HOME) { cLiConfig['feLazyCliHome'] = path.join(userHome, process.env.FE_LAZY_CLI_HOME); } else { cLiConfig['feLazyCliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME) } process.env.FE_LAZY_CLI_HOME = cLiConfig.feLazyCliHome; } 检查是否开启debug模式 function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose'; } else { process.env.LOG_LEVEL = 'info'; } log.level = process.env.LOG_LEVEL; } 通过 commander 框架实现一个脚手架，包含自定义 option 和 command 功能 文件头 'use strict'; const commander = require('commander'); const colors = require('colors'); const log = require('@fe-lazy-cli/log'); // 获取 commander 的单例 // const { program } = commander; // 手动实例化一个 commander const program = new commander.Command(); module.exports = command; 脚手架主命令 function command(pkg) { program .name(Object.keys(pkg.bin)[0]) .usage(\" [option]\") .version(pkg.version) .option('-d, --debug [debugModule]', '是否开启 debug 模式', false) .option('-v, -V, --version', \"输出版本信息\"); regCommand(); regAddCommand(); // 对未知命令进行提示 program.on('command:*',(arg) => { let commands = program.commands.map(item => { return { name: item._name.split(''), consistency: 0 }; }) commands = commands.map(item => { let argArr = arg[0].split(''); let consistency = item.consistency item.name.map(c => { if (argArr.indexOf(c) >= 0) { consistency ++; argArr.splice(argArr.indexOf(c), 1); } }) return { name: item.name.join(''), consistency }; }); commands = commands.filter(item => item.consistency > 0).sort((a, b) => b.consistency - a.consistency); commands = commands && commands.length && commands[0].name || false; let argText = arg[0] || \"\"; if (commands) { throw new Error(colors.red(`抱歉！没有找到 '${argText}' 命令. 是否要运行 '${commands}' 命令. 或者运行 '${Object.keys(pkg.bin)[0]} --help' 查看帮助信息！`)); } throw new Error(colors.red(`抱歉！没有找到 '${argText}' 命令. 请运行 '${Object.keys(pkg.bin)[0]} --help' 查看帮助信息！`)); }); program .parse(process.argv); } 普通命令注册方式 function regCommand() { const echo = program.command('echo [argv]'); echo .description('输出当前指令') .option('-t, --test', '配置', false) .action((envName, argv, option) => { log.info('测试输出', envName, argv, option.test); }) } addCommand 命令注册方式 function regAddCommand() { const print = new commander.Command('print'); print .alias('p') .description('输出指定数据') .command('int ') // .command( // 'init ', // '描述', // 添加描述后 执行当前脚手架 + '-init'的脚手架： fe-lazy-cli-init // { // executableFile: 'fe', // 添加选项 执行 fe 脚手架 // isDefault: true, // 默认的执行命令 // hidden: true // 隐藏命令 // } // ) .description('输出整数') .option('--hex ', '进制', 10) .action((number, option) => { log.info(`${option.hex} 进制`, parseInt(number, option.hex)); }); program.addCommand(print); } 通过 webpack 和原生两种方式实现 node 对 es module 的支持 webpack + babel 安装 npm 包 \"@babel/core\": \"^7.12.10\", \"@babel/plugin-transform-runtime\": \"^7.12.10\", \"@babel/preset-env\": \"^7.12.11\", \"@babel/runtime-corejs3\": \"^7.12.5\", \"babel-loader\": \"^8.2.2\", \"webpack\": \"^5.13.0\", \"webpack-cli\": \"^4.3.1\" webpack.config.js const path = require('path'); module.exports = { entry: './bin/core.js', // 入口文件 mode: 'development', // 开发模式，development => 开发模式 production =》 生产模式 output: { // 输出 path: path.join(__dirname, '/dist'), // 输出目录 filename: 'core.js' // 输出的文件名 }, target: 'node', // 默认web，因为需要使用到node原生模块，所以需要更改为node module: { rules: [{ // 配置babel-loader test: /\\.js$/, // 处理js exclude: /(node_modules|dist)/, // 排除node_modules和dist目录 use: { loader: 'babel-loader', // 使用babel对js进行低版本兼容处理 options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { 'corejs': 3, 'regenerator': true, \"useESModules\": true, 'helpers': true }] ] } } }] } } Node原生支持 ES Module 更改js文件后缀为.mjs import js的时候，不能省略后缀名 是实验性质特性，在node版本v14.x.x以后支持该特性 node --experimental-modules ./index.mjs Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/yhtx1997/03-第三周笔记.html":{"url":"pages/yhtx1997/03-第三周笔记.html","title":"第三周笔记","keywords":"","body":"笔记 脚手架核心流程开发——准备阶段 大厂项目流程 设计阶段 业务或研发过程中的痛点 需求： PD 需求文档（PRD） 产品原型图 痛点 做完后希望达成的目标（可量化） 技术方案设计： 技术方案文档 技术选型 技术架构 api定义 技术调研 评估技术风险 项目立项 kick-of 确立 PO PM （产品负责人，开发团队人员） 项目排期 计划并确立时间节点 实施阶段 交互视觉设计 开发 测试 验收 上线 结项 看是否达到目标 大厂git规范 分支规范 master：同步分支 线上代码 dev：开发分支： dev 0.0.1 自动升版本 release：上线后 添加 tag： release 0.0.1 仓库规范 原始仓库：代码合并前 code review，合并后无问题提交测试 fork 仓库: 存放自己的代码 本地仓库：本地开发，开发完成合并回原始仓库 脚手架架构设计 架构设计图：系统设计思路 考虑好外部依赖 痛点分析： 创建项目/组件时，存在大量重复代码：快速复用已有沉淀 协同开发时 git 操作不规范，分支混乱，操作耗时：制定标准的git操作规范 发布上线耗时，而且容易出现各种错误：制定标准的上线流程 需求分析： 通用的研发脚手架 通用的项目/组件创建能力 模板支持定制，定制后能够快速生效 模板支持快速接入，极低的接入成本 通用的项目/组件发布能力 发布过程自动完成标准的 git 操作 发布完成后自动删除开发分支，并创建tag 发布后自动完成云构建、oss上传、cdn上传、域名绑定 发布过程支持测试/正式两种模式 架构图体系 项目初始化体系 项目初始化 组件初始化 初始化模式 项目发布体系 项目发布 组件发布 发布模式 标准git操作体系 仓库创建 开发模式 发布模式 核心框架（初始化，完成执行流程，完成命令执行，完成异常监听） 执行准备 命令注册 命令执行 OPEN API 项目/组件模板 静态资源查询 配置信息 WebSocket 服务 云构建 云发布 发布模式 外部依赖 代码仓库 资源体系 远程缓存体系 本地缓存体系 模板库 数据体系 代码实现思路 脚手架拆包策略 核心流程：core 命令：commands 初始化 发布 清缓存 模型层：models 命令 项目 组件 npm git 仓库 支撑模块：utils git 操作 云构建 工具方法 API 请求 git API core模块技术方案 准备阶段 检查版本号 检查node版本 检查root启动 检查用户主目录 检查入参 检查环境变量 检查是否最新版本 命令注册 命令执行 核心库 1. import-local 1. commander 脚手架框架 工具库 1. npmlog 控制台输出 1. fs-extra 检查文件是否存在 1. semver 比较版本号 1. colors log信息添加颜色 1. user-home 操作系统用户主目录 1. dotenv 从文件加载环境变量 1. root-check root用户降级 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/zcyan2013/":{"url":"pages/zcyan2013/","title":"Zcyan2013","keywords":"","body":"zcyan2013 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/zcyan2013/01-第一周笔记和作业.html":{"url":"pages/zcyan2013/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"架构方案设计 V1.0 需求 https://www.yuque.com/imooc-lego/zlz87z 范围 需要的项目 B 端和编辑器,做前后端分离 biz-editor-fe biz-editor-server H5 适合做 SSR，因为要考虑性能 H5-server 管理后台，做前端分析 admin-fe admin-server 独立的业务组件库 编辑器画布使用的组件和渲染逻辑，和 H5 页面是完全一样的，因此，把业务组件库抽离出来，给画布和 H5 使用。 自研统计服务 我们需要实现分渠道统计，实现这个功能，就需要自定义事件统计。 支持自定义事件统计 支持 Open API 经调研发现，市面上的第三方统计服务，要么不支持，要么收费太贵。综合对比，选择自研。包括： 日志收集 日志分析 Open API 模块设计 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: { }, // 一些可能的配置项，扩展性保证 props: { }, // 页面 的一些设置，扩展性保证 components: [ { id: 'xxx', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转关系图 核心：B 端、C 端、管理后台，共用一个数据库 创建作品：初始化一个 JSON 数据 保存作品：修改 JSON 数据 发布作品：修改一个标记，仅此而已 C 端浏览作品：获取 JSON 数据，SSR 渲染页面 屏蔽作品：修改一个标记，C 端来判断 扩展性保证 扩展组件 扩展编辑器的功能，如组件隐藏、锁定 扩展页面的配置，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台：代码复用，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/":{"url":"pages/い狂奔的蜗牛/","title":"い狂奔的蜗牛","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/01.Node.js中经典算法（一）.html":{"url":"pages/い狂奔的蜗牛/01.Node.js中经典算法（一）.html","title":"01.Node.Js中经典算法（一）","keywords":"","body":"Node.js中经典算法（一） ​ 给定一个路径和目录，返回在这个路径下所有可能存在当前目录的路径组合算法，摘自Node模块算法 一、声明一个保存node_modules逆序字符串(seludom_edon)的ASCII编码数组 // seludom_edon对应的编码 const nmChars = [ 115, 101, 108, 117, 100, 111, 109, 95, 101, 100, 111, 110 ]; 二、算法 Module._nodeModulePaths = function(from) { // 得到绝对路径 from = path.resolve(from); // 如果是根目录，直接返回一个['/node_modules'] if (from === '/') return ['/node_modules']; // 存放所有可能存在node_modules的绝对路径数组 const paths = []; // 用户筛选异常路径中可能包含的node_modules目录 var p = 0; var last = from.length; // 路径的长度 // 反向遍历 for (var i = from.length - 1; i >= 0; --i) { // 得到最后一个字符 const code = from.charCodeAt(i); // CHAR_FORWARD_SLASH === '/' === 47 // 判断当前的编码是否为47 if (code === CHAR_FORWARD_SLASH) { if (p !== nmLen) // 比对完一个目录 判断目录是否为node_modules,如果不是则拼接一个/node_modules路径放入paths数组 paths.push(from.slice(0, last) + '/node_modules'); last = i;// 记录当前比对到的字符为'/'的位置(剩余未比对路径的长度+1)，用于拼接上一级目录+'/node_modules' // 重置当前字符比对node_modules逆序时的相等相等的字符长度 如/a/modules_modules会跳过/a/modules_modules // 直接加入paths,而是比对到/a后拼接得到一个/a/modules_modules加入paths目录 p = 0; } else if (p !== -1) { if (nmChars[p] === code) { // 判断当前获取的字符是否和node_modules逆序相同，用于匹配node_modules ++p; } else { p = -1; } } } // 最后追加一个根目录下的node_modules paths.push('/node_modules'); return paths; }; 示例：'/a/b/c' 结果：['/a/b/c/node_modules','/a/b/node_modules','/a/node_modules','/node_modules'] Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/02.Node.js中使用ES Module的两种方式.html":{"url":"pages/い狂奔的蜗牛/02.Node.js中使用ES Module的两种方式.html","title":"02.Node.Js中使用ES Module的两种方式","keywords":"","body":"Node.js中使用ES Module的两种方式 方式一 ​ 使用webpack对源码进行构建，使用babel对js进行处理使其适应于低版本node 依赖： 一、package.json \"devDependencies\": { \"@babel/core\": \"^7.12.10\", \"@babel/plugin-transform-runtime\": \"^7.12.10\", \"@babel/preset-env\": \"^7.12.11\", \"@babel/runtime-corejs3\": \"^7.12.5\", \"babel-loader\": \"^8.2.2\", \"webpack\": \"^5.11.0\", \"webpack-cli\": \"^4.3.0\" } npm scripts \"scripts\": { \"build\": \"webpack\", \"dev\": \"webpack --watch\" }, 二、webpack.config.js配置 const path = require('path'); module.exports = { entry: './bin/core.js', // 入口文件 mode: 'development', // 开发模式，development => 开发模式 production =》 生产模式 output: { // 输出 path: path.join(__dirname, '/dist'), // 输出目录 filename: 'core.js' // 输出的文件名 }, target: 'node', // 默认web，因为需要使用到node原生模块，所以需要更改为node module: { rules: [{ // 配置babel-loader test: /\\.js$/, // 处理js exclude: /(node_modules|dist)/, // 排除node_modules和dist目录 use: { loader: 'babel-loader', // 使用babel对js进行低版本兼容处理 options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { 'corejs': 3, 'regenerator': true, \"useESModules\": true, 'helpers': true }] ] } } }] } } 方式二 ​ 通过Node原生支持ES Module 步骤一、 更改js文件后缀为.mjs 步骤二、 import js的时候，如import './core';不能省略后缀名，需要写成import './core.mjs'; 执行：node --experimental-modules ./bin/index.mjs 步骤三、 由于是实验性质特性，所以需要配置开启 --experimental-modules，否则会报如下错误 internal/modules/cjs/loader.js:821 throw new ERR_REQUIRE_ESM(filename); ^ Error [ERR_REQUIRE_ESM]: Must use import to load ES Module: /Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin/index.mjs at Object.Module._extensions..mjs (internal/modules/cjs/loader.js:821:9) at Module.load (internal/modules/cjs/loader.js:643:32) at Function.Module._load (internal/modules/cjs/loader.js:556:12) at Function.Module.runMain (internal/modules/cjs/loader.js:839:10) at internal/main/run_main_module.js:17:11 开启后会报一个警告，在node版本v14.x.x以后也支持该特性，不会显示警告信息 (node:59215) ExperimentalWarning: The ESM module loader is experimental. Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/03.sim-cli核心图集.html":{"url":"pages/い狂奔的蜗牛/03.sim-cli核心图集.html","title":"03.Sim Cli核心图集","keywords":"","body":"第四周更新 - sim-cli核心图集 一、sim-cli脚手架架构图 二、sim-cli脚手架核心流程图 第四周扩充 三、sim-cli脚手架依赖示意图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/04.第四周-Node.js多进程源码分析.html":{"url":"pages/い狂奔的蜗牛/04.第四周-Node.js多进程源码分析.html","title":"04.第四周 Node.Js多进程源码分析","keywords":"","body":"第四周作业 - Node源码分析 一、总结： exec/execFile/spawn/fork的区别 exec：原理是调用/bin/sh -c执行我们传入的shell脚本，只做了参数处理就调用了execFile execFile：原理是直接执行我们传入的file和args，底层调用spawn创建和执行子进程，并建立了回调，一次性将所有的stdout和stderr结果返回 spawn：原理是调用了internal/child_process，实例化了ChildProcess子进程对象，再调用child.spawn创建子进程并执行命令，底层调用了child._handle_spawn执行process_wrap中的spawn方法，此时才创建了子进程。执行过程是异步的，执行完毕后通过PIPE进行单向数据通信，通信结束后子进程发起onexit回调，同时Socket会执行close回调 fork：原理是通过spawn创建子进程和执行命令，通过setupchannel创建IPC通信，用于父子进程之间双向通信 data/error/exit/cloes回调的区别 data：主进程读取数据过程中通过onread=onStreamRead发起回调 error：命令执行失败后发起回调 exit：子进程关闭完成后发起回调 close：子进程所有Socket实例全部关闭后发起回调（stdin,stdout,stderr） Stdout close /stderr close：特定的PIPE读取完成后调用onReadableStreamEnd关闭socket时发起的回调 二、源码分析思维导图 exec： execSync： Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/05.第四周-import-local源码分析及node模块加载流程源码分析.html":{"url":"pages/い狂奔的蜗牛/05.第四周-import-local源码分析及node模块加载流程源码分析.html","title":"05.第四周 Import Local源码分析及Node模块加载流程源码分析","keywords":"","body":"第四周作业扩展 - import-local源码分析及node模块加载流程源码分析 一、总结 分析入口lerna源码 模块的完整查找流程只会执行一次，执行过后模块会以模块名/查找路径为key，模块真实路径为value缓存 Module._resolveFilename()为node模块加载流程实现核心方法，require等在此基础是进一步封装 import-local以包名（lerna）和入口文件（cli.js）调用resolveCwd.silent(path.join(pkg.name, relativePath))得到lerna源码中cli.js的绝对路径：/Users/snail/Desktop/code/lego/lerna/core/lerna/cli.js 二、import-local源码分析及node模块加载流程源码分析思维导图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/06.第五周-如何解决安装模板时控制台动画闪烁问题.html":{"url":"pages/い狂奔的蜗牛/06.第五周-如何解决安装模板时控制台动画闪烁问题.html","title":"06.第五周 如何解决安装模板时控制台动画闪烁问题","keywords":"","body":"如何解决安装模板时控制台动画闪烁问题 原因分析： ​ 在我们使用cli-spinner给我们的脚手架添加自己的安装动画时，由于我们使用了npminstall作为我们安装npm包的依赖，npminstall本身在安装包的时候就有安装动画。所以我们自己给脚手架添加的动画和npminstall内置的有冲突，导致控制台交替输出，从而导致闪烁。后续思路为去掉npminstall动画出发，保留我们自己的动画为目的进行。 步骤一： ​ 查看npminstall配置，是否有去掉动画配置。通过查看使用说明，未能找到对应的配置。 await npminstall({ // install root dir root: process.cwd(), // optional packages need to install, default is package.json's dependencies and devDependencies // pkgs: [ // { name: 'foo', version: '~1.0.0' }, // ], // install to specific directory, default to root // targetDir: '/home/admin/.global/lib', // link bin to specific directory (for global install) // binDir: '/home/admin/.global/bin', // registry, default is https://registry.npmjs.org // registry: 'https://registry.npmjs.org', // debug: false, // storeDir: root + 'node_modules', // ignoreScripts: true, // ignore pre/post install scripts, default is `false` // forbiddenLicenses: forbit install packages which used these licenses }); 步骤二： ​ 因为没有文档说明如何去掉，于是去翻看源码，查看local_install.js文件，找到默认动画相关核心代码如下 local_install.js module.exports = async options => { options = formatInstallOptions(options); options.spinner && options.spinner.start(); ... } format_install_options.js module.exports = function formatInstallOptions(options) { options.trace = !!options.trace; if (options.trace) { // make sure detail enable when trace enable options.detail = true; } options.spinner = options.detail ? null : ora(); ... } 通过分析代码发现和默认安装动画相关的分别为两个在文档中未提及的参数trace、detail，和ora方法，其中ora方法内部对cli-spinner动画进行了封装，所以当detail为true的时候options.spinner为null，而options.spinner引用着一个cli-spinner中Spinner的实例，当options.spinner为null时，这个时候将没有动画。所以我们在执行npminstall方法的时候传入detail为true，如：npminstall({detail:true})从而达到我们希望去掉npminstall动画的目的。需要注意的是如果我们需要npminstall的默认安装动画，我们不能在执行npminstall方法的时候传入trace为true，否则传入的detail将会被覆盖为true。 步骤三： ​ 测试 trace=false，有加载动画，控制台输出如下 ✔ Installed 1 packages ✔ Linked 1 latest versions ✔ Run 0 scripts ✔ All packages installed (1 packages installed from npm registry, used 631ms(network 630ms), speed 6.18KB/s, json 1(3.9KB), tarball 0B) 测试 trace=true，npminstall代码内部会将options.detail=true此时无加载动画，控制台输出如下 [1/1] imooc-cli-dev-template-vue2@1.0.0 installed at node_modules/_imooc-cli-dev-template-vue2@1.0.0@imooc-cli-dev-template-vue2 All packages installed (1 packages installed from npm registry, used 453ms(network 451ms), speed 8.64KB/s, json 1(3.9KB), tarball 0B) [trace] 454ms &#x1F3CA; memory usage, rss: 50.16MB, heapTotal: 31.02MB, heapUsed: 16.84MB, external: 1.56MB; &#x1F4BB; os free: 41.12MB, os load: 4.5, 5.1, 5.3; &#x1F3C3; cpu usage, user: 0, system: 0 通过设置detail为true动画是可以去掉了，但是安装信息任然存在，通过查看代码发现最终结果日志在local_install.js 569行打印。代码如下 if (options.spinner) { options.spinner.succeed(util.format(...logArguments)); } else { options.console.info(...logArguments); } 思考：如何让npminstall保持沉默，不输出任何信息？ 方式一： ​ 改local_install.js源码，手动改肯定是不行的，可否脚手架代码更改？因为js是动态语言/解释执行，实际上通过找到npminstall包，然后找到local_install.js，通过nodejs提供的文件读写能力干掉以上代码应该可行。细思极恐啊！！！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/07.第五周-readline源码阅读及实现简易版readline.html":{"url":"pages/い狂奔的蜗牛/07.第五周-readline源码阅读及实现简易版readline.html","title":"07.第五周 Readline源码阅读及实现简易版Readline","keywords":"","body":"readline源码阅读及实现简易版readline 一、readline阅读思维导图 二、简版readline实现 function readline(callback) { function onKeyPress(s) { output.write(s); line += s; switch (s) { case '\\r': input.pause(); // 会清空输入时output输出的内容 callback(line.slice(1)); break; } } const input = process.stdin; const output = process.stdout; let line = ''; // 记录输入的内容 input.on('keypress', onKeyPress) emitKeypressEvents(input); input.setRawMode(true); input.resume(); } function emitKeypressEvents(stream) { function onData(chunk) { g.next(chunk.toString()); } const g = emitKeys(stream); g.next() stream.on('data', onData); // 输出一个大于符号 g.next('>'); } function* emitKeys(stream) { while (true) { const ch = yield; stream.emit('keypress', ch); } } readline((res) => { console.log('>' + res); }); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/08.第五周-类似inquirer列表类型交互实现.html":{"url":"pages/い狂奔的蜗牛/08.第五周-类似inquirer列表类型交互实现.html","title":"08.第五周 类似Inquirer列表类型交互实现","keywords":"","body":"类似inquirer列表类型交互实现 一、源码设计思维导图 ​ 二、源码 const EventEmitter = require('events'); const readline = require('readline'); const MuteStream = require('mute-stream'); const {fromEvent} = require('rxjs'); var cliCursor = require('cli-cursor'); const ansiEscapes = require('ansi-escapes'); const options = { type: 'list', name: 'userName', message: '请选择你的名字', choices: [{ name: '张三', value: '张三' }, { name: '李四', value: '李四' }, { name: '王五', value: '王五' }] }; class List extends EventEmitter { constructor(list) { super(); this.type = options.type; this.name = options.name; this.message = options.message; this.choices = options.choices; this.input = process.stdin; // 对标准输出流进行一次包装 const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; // Interface实例 this.rl = readline.createInterface({ input: this.input, output: this.output }); // 当前选中位置 用于光标位移 this.selected = 0; // 列表高度 this.height = 0; // 监听按键按下事件 this.keypress = fromEvent(this.rl.input, 'keypress').forEach(this.onKeyPress); // 是否已经选中完毕 this.haveSelected = false; } onKeyPress = (keymap) => { const key = keymap[1]; if (key.name === 'down') { // 下箭头 this.selected++; if (this.selected === this.choices.length) { this.selected = 0; } this.render(); } else if (key.name === 'up') { // 上箭头 this.selected--; if (this.selected === -1) { this.selected = this.choices.length - 1; } this.render(); } else if (key.name === 'return') { this.haveSelected = true; this.render(); this.close(); // 派发给程序开发者的 this.emit('exit', this.choices[this.selected]); } } close() { // this.input.pause(); this.output.unmute(); this.rl.output.end(); //this.rl.close();内部会调 this.rl.pause(); 会调 this.input.pause(); // this.rl.pause(); this.rl.close(); cliCursor.show(); } // 渲染列表 render() { cliCursor.hide(); // 让用户可以输入 this.output.unmute(); this.clean(); // 输出列表 this.output.write(this.getContent()); // 用户不能继续输入 this.output.mute(); } // 获取输出内容 getContent() { if (!this.haveSelected) { // 用户还没选择结束 // 加粗无效 let content = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choice, index) => { // 是否为当前选中项，高亮显示，因为除了最后一个选项外，每一项后面需要加入\\n换行 if (index === this.selected) { if (index === this.choices.length - 1) { // 最后一行 不要加\\n content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } else { // 不是最后一行，添加\\n content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } } else { // 没有选中 除了最后一个选项外，每一项后面需要加入\\n换行 if (index === this.choices.length - 1) { // 最后一行 不要加\\n content += ' ' + choice.name + '\\n'; } else { // 不是最后一行，添加\\n content += ' ' + choice.name + '\\n'; } } }); // 空行 询问标题占两行 this.height = this.choices.length + 2; return content; } else { // 输出给使用者看的 const name = this.choices[this.selected].name; return '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; } } // 清屏 clean() { const emptyLines = ansiEscapes.eraseLines(this.height); this.output.write(emptyLines); } } function prompt(options) { return new Promise((resolve, reject) => { try { const list = new List(options); list.render(); // 添加退出监听 list.on('exit', function (result) { resolve(result); }); } catch (e) { reject(e); } }); } prompt(options).then((result) => { console.log(result); } ); 思考？ ​ inquirer的list在用户选择时没有光标，而自实现的有光标。如何去掉？ 答案： ​ 使用cli-cursor包提供的hide和show方法完成光标的隐藏与显示（从阅读inquirer源码获得） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/09.第六周-ejs源码分析.html":{"url":"pages/い狂奔的蜗牛/09.第六周-ejs源码分析.html","title":"09.第六周 Ejs源码分析","keywords":"","body":"ejs源码分析 收获一 ​ 简单转义方法实现代码 // 对&<>'\"进行转义 var _ENCODE_HTML_RULES = { '&': '&amp;', '': '&gt;', '\"': '&#34;', \"'\": '&#39;' }; var _MATCH_HTML = /[&<>'\"]/g; function encode_char(c) { return _ENCODE_HTML_RULES[c] || c; } exports.escapeXML = function (markup) { return markup == undefined ? '' : String(markup) .replace(_MATCH_HTML, encode_char); }; 收获二 ​ 对一个字符串按照特定方形进行拆分算法 parseTemplateText: function () { var str = this.templateText; // ` var pat = this.regex; // new Regex('(||-%>|_%>)') var result = pat.exec(str); var arr = []; var firstPos; // 如果匹配到结果进入继续拆分配配 while (result) { firstPos = result.index;// 匹配到的开始位置 if (firstPos !== 0) { arr.push(str.substring(0, firstPos));// 匹配到的结果位置索引不为0，则将索引之前的字符串截取添加到数组中 str = str.slice(firstPos);// 从匹配到的位置开始截取字符串 } arr.push(result[0]); // 将匹配到的结果添加到数组 str = str.slice(result[0].length); // 从匹配到结果的长度处截取剩余的字符串 //匹配一次之后的结果为： user.name %> result = pat.exec(str);// 对剩余的字符串进行再次匹配处理 } // 如果没匹配到但是字符串还有值，则直接添加到数组 if (str) { arr.push(str); } return arr; }, ​ 收获三 ​ fn.apply和fn.call都用于改变方法内部的this指向，第一个参数为this指向对象，第二个参数。其中apply第二个参数为数组，call的2-n为参数，对应传给形参。 收获四 ​ with的简要用法 收获五 ​ ejs三种使用方式执行流程 总结： ​ ejs中最为核心的为templ.compile()方法，ejs.render、ejs.renderFile底层都调用compile()，只是针对不同的场景进行了不同的方法暴露，其中render可通过传入的options中设置cache=true提高效率，当opts.cache为true时，如果已经生成了函数，则直接返回，否则将重新生成函数。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/10.第六周-require源码分析.html":{"url":"pages/い狂奔的蜗牛/10.第六周-require源码分析.html","title":"10.第六周 Require源码分析","keywords":"","body":"require源码分析 - v12.5.0 一、require是如何缓存的？ 缓存模块路径： 通过执行文件的目录和require(path)中的path拼接得到一个路径，在后续查找到模块真实路径的情况下会以之前拼接的路径为key，正式路径为value进行缓存，如： { \"/Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin\\u0000./ejs\": \"/Users/snail/Desktop/code/lego/imooc-test1-dev/imooc-test1/bin/ejs/index.js\" } 缓存模块： 以上一步拿到的真实文件路径为key，创建的module实例为value缓存到Module._cache对象中 Module._cache = Object.create(null); // 缓存 Module._cache[filename] = module; 二、require支持加载的文件类型？ .js 读取文件内容，移除utf-8 BOM头和移除脚手架中定义的#!/usr/bin/env node，将内容包装在一个函数内进行自执行并传入exports、require、module、filename、dirname； .json 读取文件内容 调用JSON.parse(content)转成json对象后返回； .node .mjs node 14+版本支持，如果低版本需要指定开启 --experimental-modules，否则将报错； 如果文件没有指定文件类型，则按js处理； 注：一个文件中多次加载同一个模块，后面的将使用第一次加载的缓存模块； 三、源码分析思维导图 ​ 包含自定义模块，node_modules下的模块和内置模块 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/11.第八周-为clipboard.js库写类型文件.html":{"url":"pages/い狂奔的蜗牛/11.第八周-为clipboard.js库写类型文件.html","title":"11.第八周 为Clipboard.Js库写类型文件","keywords":"","body":"为 clipboard.js 库写类型文件 ​ 开源库github地址：https://github.com/zenorocha/clipboard.js ​ 因未深入学习和使用clipboard.js库，只是粗略看了下源码和简要看了下文档了解其基本用法，写了如下类型声明文库。不足或不对之处还请见谅。 ​ 为避免在编写时编辑器智能感知提示为clipboard.js中申明的定义文件，所以特意将名字修改为MyClipboard进行测试； type Trigger = String | HTMLElement | HTMLCollection | NodeList; // on添加监听回调方法 interface IOnCallbackFunParams { action: string; text: string; trigger: HTMLElement; clearSelection: () => void; } // 第二个参数 // 参照https://github.com/zenorocha/clipboard.js#advanced-options定义 interface IOptions { target?: (trigger: Trigger) => Node; text?: (trigger: Trigger) => string; container?: HTMLElement; } type Action = [\"copy\", \"cut\"]; type MyEventType = \"success\" | \"error\"; type AttributeValue = string | null | undefined; type OnCallbackFun = (e: IOnCallbackFunParams) => void; // 参照源码定义包含方法，因为继承于Emitter，未深入研究Emitter的实现，所以只简要申明了on方法的定义 declare class MyClipboard { constructor(trigger: Trigger, options?: IOptions); resolveOptions(any: {}): void; listenClick(trigger: Trigger): void; onClick(e: Event): void; defaultAction(trigger: Trigger): AttributeValue; defaultTarget(trigger: Trigger): Element | null | undefined; static isSupported(action?: Action): boolean; defaultText(trigger: Trigger): AttributeValue; destroy(): void; // 继承自Emitter的方法 on(eventName: MyEventType, callback: OnCallbackFun): void; } // 测试使用 const clipboard = new MyClipboard('.btn', { text: (e: any) => { return '123'; }, container: document.createElement('div') }); clipboard.on(\"success\", (e) => { console.log(e.action); console.log(e.text); console.log(e.trigger); e.clearSelection() }); clipboard.on(\"error\", (e) => { console.log(e.action); console.log(e.text); console.log(e.trigger); e.clearSelection() }); clipboard.destroy(); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/12.第九周-项目技术规范.html":{"url":"pages/い狂奔的蜗牛/12.第九周-项目技术规范.html","title":"12.第九周 项目技术规范","keywords":"","body":"项目技术规范 项目编码规范 项目使用 ESLint 进行编码规范的约束，且强制如下约束 引用现有规范方案 'extends': [ 'plugin:vue/vue3-essential', 'eslint:recommended', '@vue/typescript/recommended' ], js/ts语句以;作为语句结束符 js/ts字符串使用''替换“” TypeScript定义interface时应将所有的interface放置到同一个目录下，且每个interface独立为一个文件，默认导出interface定义的接口，如: 定义： interface UserProps { isLogin: boolean; userName?: string; } export default UserProps; 引用： import UserState from '../../types/UserState'; 好处为引用的时候都为import x from '../../types/x'形式，统一的约定和定义方便查看类型定义和引用。 针对不同编辑器默认格式化样式不统一问题，引入editorconfig对代码进行格式化约束，如 # editorconfig.org root = true [*] indent_style = space indent_size = 2 end_of_line = lf charset = utf-8 trim_trailing_whitespace = true insert_final_newline = true [*.md] trim_trailing_whitespace = false 项目文件结构规范 避免多层嵌套 Git使用规范 采用 Github Flow Github Flow 文档地址：https://guides.github.com/introduction/flow/index.html 图片描述： 文字过程描述： 根据需求，从 master 拉出分支 激烈的开发阶段，提交 commit 开发完毕，发起 PR（pull request） 代码评审（很重要！） 部署，并且测试 没问题， merge 到 master！ 分支命名 分支命名规范属于强制采用的规范 feature 开头代表功能开发 如 feature/add-vuex hotfix 开头代表代码 bug 修复 如 hotfix/fix-header Commit 信息 Commit 信息，杜绝 update，fix bug 这类废话，每次提交必须言之有物，至少要言简意赅的把一次 commit 完成的任务说清楚。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/13.第十周-作业.html":{"url":"pages/い狂奔的蜗牛/13.第十周-作业.html","title":"13.第十周 作业","keywords":"","body":"作业1 - 完成删除画布的逻辑 步骤一 在EditWrapper.vue中新增一个div用于用户点击移除对应的l-text 移除 步骤二 定义派发的事件名称 emits: ['set-active', 'removeComponent'], 步骤三 定义点击事件处理函数 const onRemoveClick = (id: string) => { context.emit('removeComponent', id); }; return { ... onRemoveClick }; 步骤五 在Editor.vue中给EditWrapper组件添加事件 ... 步骤六 在Editor.vue中增加处理函数 const removeComponent = (id: string) => { store.commit('removeComponent', id); }; return { ... removeComponent }; 步骤七 在store/editor.ts mutations中定义函数处理组件数组，移除当前点击移除的组件 removeComponent(state, id: string) { let index = -1; for (let i = 0; i 最终完成界面更新，无需单独处理 作业2 - 添加更多属性和组件的对应关系 透明度实现代码（propsMap.ts） opacity: { component: 'a-slider', extraProps: {min: 0, max: 100, step: 1, reverse: true}, text: '透明度', initalTransform: (value: string) => parseFloat(value) * 100, afterTransform: (e: number) => (e / 100).toString() } 加粗、倾斜、下划线实现 步骤一 安装图标依赖 npm install -S @ant-design/icons-vue 步骤二（PropsTable.vue） 组件包括元素添加no-text类名 :class=\"['prop-item', {'no-text': key === 'textDecoration' || key === 'fontWeight' || key === 'fontStyle' }]\" 步骤三（PropsTable.vue） 引入图标组件 import { ItalicOutlined, BoldOutlined, UnderlineOutlined } from '@ant-design/icons-vue'; components: { ... ItalicOutlined, BoldOutlined, UnderlineOutlined }, 步骤四（PropsTable.vue） 修改css .prop-item.no-text { width: 32px; height: 32px; display: inline-block; margin-right: 10px; } .no-text:nth-child(3) { margin-left: 27%; } 步骤五（propsMap.ts） fontWeight: { component: 'a-button', subComponent: 'BoldOutlined', text: '', valueProp: 'type', extraProps: {shape: 'circle'}, eventName: 'click', options: [{value: '',text: ''}], initalTransform(value: string) { return value === 'bold' ? 'primary' : 'default'; }, afterTransform: (e: any) => { return e.target.classList.contains('ant-btn-default') ? 'bold' : 'normal'; } }, fontStyle: { component: 'a-button', subComponent: 'ItalicOutlined', text: '', valueProp: 'type', extraProps: {shape: 'circle'}, eventName: 'click', options: [{value: '',text: ''}], initalTransform(value: string) { return value === 'italic' ? 'primary' : 'default'; }, afterTransform: (e: any) => { return e.target.classList.contains('ant-btn-default') ? 'italic' : 'normal'; } }, textDecoration: { component: 'a-button', subComponent: 'UnderlineOutlined', text: '', valueProp: 'type', extraProps: {shape: 'circle'}, eventName: 'click', options: [{value: '',text: ''}], initalTransform(value: string) { return value === 'underline' ? 'primary' : 'default'; }, afterTransform: (e: any) => { return e.target.classList.contains('ant-btn-default') ? 'underline' : 'none'; } } 作业3 - 添加更多属性和组件的对应关系 点击组件跳转问题原因，因为组件内部增加了点击事件跳转，所以用户点击时l-text捕获了点击事件，导致画板上点击l-text时发生了跳转。 解决思路： 如何让l-text无法获取点击事件或者捕获到了不做跳转处理？ 方案一： 在外层wrapper下新增一个元素，设置其覆盖在l-text上，且把原本添加到外层wrapper上的点击事件添加到遮罩层上，代码如下： html： css: .edit-wrapper { position: relative; padding: 0px; cursor: pointer; border: 1px solid transparent; user-select: none; } .edit-wrapper .mask { position: absolute; top: 0; right: 0; bottom: 0; left: 0; } 缺点：暂时不知道当前处理方式对于后续拖动改变尺寸是否有影响 方案二： l-text新增一个属性，让l-text内部适配判断是否有该属性从而处理点击逻辑 缺点：由于编辑模式和最终发布后都依赖于传入的属性控制最终渲染样式，导致最终在调用接口存储数据的时候需要修改属性值，增加了提交时候的复杂度 效果图 不足：以上方式实现对fontWeight、fontStyle、textDecoration的位置有要求 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/14.第十一周-IconSwitch组件的开发与测试.html":{"url":"pages/い狂奔的蜗牛/14.第十一周-IconSwitch组件的开发与测试.html","title":"14.第十一周 IconSwitch组件的开发与测试","keywords":"","body":"IconSwitch组件的开发与测试 IconSwitch组件 使用了ant-design-vue中的a-tooltip和a-button组件。 import { defineComponent, computed } from 'vue'; export default defineComponent({ name: 'IconSwitch', props: { value: { type: Boolean, default: false }, placement: { type: String, default: 'top' }, title: { type: String, default: 'title' }, shape: { type: String, default: 'circle' } }, emits: ['change'], setup(props, context) { const type = computed(() => { return props.value ? 'primary' : ''; }); const onChange = () => { context.emit('change', !props.value); }; return { type, onChange }; } }); 单元测试 import { mount, VueWrapper } from '@vue/test-utils'; import IconSwitch from '@/components/IconSwitch.vue'; const mockComponent = { template: 'B' }; let wrapper: VueWrapper; const title = '我是鼠标悬浮提示'; describe('IconSwitch.vue', () => { beforeAll(() => { wrapper = mount(IconSwitch, { props: { value: true, title }, global: { components: { 'a-button': mockComponent, 'a-tooltip': mockComponent } } } ); }); it('测试title', () => { const tooltip = wrapper.findAll('.icon-switch>div')[0]; // 判断传入的title expect(tooltip.attributes('title')).toBe(title); }); it('测试title位置', async () => { const tooltip = wrapper.findAll('.icon-switch>div')[0]; expect(tooltip.attributes('placement')).toBe('top'); await wrapper.setProps({ placement: 'topLeft' }); // 判断传入的placement是否正确 expect(tooltip.attributes('placement')).toBe('topLeft'); }); it('测试value值', async () => { // 判断传入的value值 expect(wrapper.props('value')).toBeTruthy(); }); it('测试value值 - 2', async () => { await wrapper.setProps({ value: false }); // 判断传入的value值 expect(wrapper.props('value')).toBeFalsy(); }); it('测试点击事件', async () => { const item = wrapper.get('div[type=primary]'); // 触发点击事件 await item.trigger('click'); const events = wrapper.emitted('change'); // 传入属性为 value === true，取反则为false expect(events[0]).toEqual([false]); }); afterEach(() => { // 测试value值 - 2 会更改props，如果不还原会导致测试点击事件失败 wrapper.setProps({ value: true }); }); }); 集成到编辑器 步骤一 由于使用了图标，需要安装@ant-design/icons-vue，命令如下 cnpm install --save @ant-design/icons-vue 步骤二 在PropsTable组件中引入要使用的IconSwitch和字体组件 import IconSwitch from '@/components/IconSwitch.vue'; import BoldOutlined from '@ant-design/icons-vue/BoldOutlined'; import ItalicOutlined from '@ant-design/icons-vue/ItalicOutlined'; import UnderlineOutlined from '@ant-design/icons-vue/UnderlineOutlined'; 步骤三 组件外层循环增加一个新的类名，命名规则为“组件名-item”，如icon-switch-item 步骤四 增加如下css样式 .icon-switch-item { display: inline-block; margin-right: 10px; } 步骤五 设置第一个icon-switch距离左边的位置 onMounted(() => { const firstElement = document.getElementsByClassName('icon-switch-item')[0] as HTMLElement; firstElement.style.paddingLeft = '28%'; }); 步骤六 编写css属性与组件的映射关系 fontWeight: { component: 'icon-switch', subComponent: 'BoldOutlined', text: '', extraProps: { title: '常规/加粗' }, initalTransform(value: string) { return value === 'bold'; }, afterTransform(value: boolean) { return value ? 'bold' : 'normal'; }, options: [{value: '', text: ''}] }, fontStyle: { component: 'icon-switch', subComponent: 'ItalicOutlined', text: '', extraProps: { title: '常规/斜体' }, initalTransform(value: string) { return value === 'italic'; }, afterTransform(value: boolean) { return value ? 'italic' : 'normal'; }, options: [{value: '', text: ''}] }, textDecoration: { component: 'icon-switch', subComponent: 'UnderlineOutlined', text: '', extraProps: { title: '常规/下划线' }, initalTransform(value: string) { return value === 'underline'; }, afterTransform(value: boolean) { return value ? 'underline' : 'none'; }, options: [{value: '', text: ''}] } 效果图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/第十三周-组件分离、CI、CD踩坑记.html":{"url":"pages/い狂奔的蜗牛/第十三周-组件分离、CI、CD踩坑记.html","title":"第十三周 组件分离、CI、CD踩坑记","keywords":"","body":" 产出 组件库地址：lego-editor-components Travis CI/CD：CI/CD 踩坑一 使用npm run build进行打包时，打包出的文件如xxx.esm.js包含defaultProps.ts中定义的数据，但是并没有导出，如textDefaultProps、imageDefaultProps、shapeDefaultProps等。导致组件使用方无法获取到这部分数据。 解决办法 src下index.ts中增加如下代码 export * from './defaultProps'; 踩坑二 默认情况下浏览器会报如下错误且l-text无法正常渲染： resolveComponent can only be used in render() or setup() 导致原因为组件库中vue与editor中vue不一致导致，在4-6小节有讲，需要使用npm link让vue指向editor中的vue，命令如下 npm link editor项目所在目录/node_modules/vue Travis CI/CD踩坑记 踩坑一 运行travis encrypt --pro npm_token --add deploy.api_key命令会提示not logged in, please run travis login --pro，意思是需要先执行travis login --pro完成登录，但在执行travis login --pro输入github用户名和密码时会报如下错误： ```shell We need your GitHub login to identify you. This information will not be sent to Travis CI, only to api.github.com. The password will not be displayed. Try running with --github-token or --auto if you don't want to enter your password anyway. Username: github_username Password for github_username: ** Not Found for a full error report, run travis report --pro **解决办法** 使用`travis login --pro --github-token your_token`完成登录，your_token在自己github中配置获取。 ## 踩坑二 > 使用tag时，让travis在测试通过检测到有tag时自动publish包到npm，其中.travis.yml配置如下 ```shell language: node_js node_js: - node deploy: provider: npm email: xxx@qq.com skip_cleanup: false api_key: secure: FbmjqqmwYNJ/amKnuSdQsNW9U6zy2KxCRAaCzO11mvpHkSklgJ+Dfa/E6bOAfY7js1v723YI9wsUELTJyWZJsrwGMCh8cJ/r7rgm9PdYQ7ZBrWV2HStp+XtMA75yVMMiQyAHg7S8i/fDvwatEPqieFFPr9fxp2Sr7UkyJBudffFfUStk+lUgfwChsHYGJpNbgOu/b8ilxoXAQsy05ojgTubXr4uAIFsggyFcQjvJeFgpWvTlcaCODpf+PDD02wx8KtR/P/vcyhat8GnHz4ypk0VOylsYLqTlNqCBIXvKx55zmSQEmnmHnowiHgSYmZxh4kNZA/00feO//RMKJoPd3Ry/ILqkR4Fn/agbGkW8HpaWCn43G70CI9iqh+umsWD8iE9tknLABpUXPBqnIdOiZJEUAa7FyO0AOoxeNZiRLC1k7T8fKIsf9xxs8FwWtrXc7oCttND63uJfldGDl+KB8B75IHiDp96PIaJsxaUl+PKelFBNa+TBSc+UHAup7FNP+4IiyLQP4yztqkA8gBFUC1EpHdGDXEsHibn8isOL7BOWyjgVJIMNXdSNeS97zJaKpGN3hVSoGIFYDj7gX2NmzodxR+44e7kinaWDy4RuMweOx3hVTc1yW1D+2ruAAGztQaZcUmZsRwcGzcRXfPZUa6R5isA/q3dcnM7pwTYGfMI= on: tags: true travis运行vue-cli-service test:unit测试通过，执行到Deploying application时提示如下错误 sh: 1: vue-cli-service: not found npm ERR! code 127 npm ERR! path /home/travis/build/github_username/lego-editor-components npm ERR! command failed npm ERR! command sh -c vue-cli-service lint --max-warnings 5 npm ERR! A complete log of this run can be found in: npm ERR! /home/travis/.npm/_logs/2021-03-01T12_47_43_636Z-debug.log npm ERR! code 127 npm ERR! path /home/travis/build/github_username/lego-editor-components npm ERR! command failed npm ERR! command sh -c npm run lint && npm run test && npm run build npm ERR! A complete log of this run can be found in: npm ERR! /home/travis/.npm/_logs/2021-03-01T12_47_43_742Z-debug.log 解决办法 .travis.yml中skip_cleanup配置为false导致，需要配置为true。 完整配置如下： language: node_js node_js: - node deploy: provider: npm email: xxx@qq.com skip_cleanup: true api_key: secure: FbmjqqmwYNJ/amKnuSdQsNW9U6zy2KxCRAaCzO11mvpHkSklgJ+Dfa/E6bOAfY7js1v723YI9wsUELTJyWZJsrwGMCh8cJ/r7rgm9PdYQ7ZBrWV2HStp+XtMA75yVMMiQyAHg7S8i/fDvwatEPqieFFPr9fxp2Sr7UkyJBudffFfUStk+lUgfwChsHYGJpNbgOu/b8ilxoXAQsy05ojgTubXr4uAIFsggyFcQjvJeFgpWvTlcaCODpf+PDD02wx8KtR/P/vcyhat8GnHz4ypk0VOylsYLqTlNqCBIXvKx55zmSQEmnmHnowiHgSYmZxh4kNZA/00feO//RMKJoPd3Ry/ILqkR4Fn/agbGkW8HpaWCn43G70CI9iqh+umsWD8iE9tknLABpUXPBqnIdOiZJEUAa7FyO0AOoxeNZiRLC1k7T8fKIsf9xxs8FwWtrXc7oCttND63uJfldGDl+KB8B75IHiDp96PIaJsxaUl+PKelFBNa+TBSc+UHAup7FNP+4IiyLQP4yztqkA8gBFUC1EpHdGDXEsHibn8isOL7BOWyjgVJIMNXdSNeS97zJaKpGN3hVSoGIFYDj7gX2NmzodxR+44e7kinaWDy4RuMweOx3hVTc1yW1D+2ruAAGztQaZcUmZsRwcGzcRXfPZUa6R5isA/q3dcnM7pwTYGfMI= on: tags: true 总结 13周看着难度不大，实践起来坑却不少！！！！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/い狂奔的蜗牛/第十二周-完成ImageProcesser组件的开发与Event派生关系整理.html":{"url":"pages/い狂奔的蜗牛/第十二周-完成ImageProcesser组件的开发与Event派生关系整理.html","title":"第十二周 完成ImageProcesser组件的开发与Event派生关系整理","keywords":"","body":"Event事件部分派生关系 ImageProcesser.vue组件 {handleUploadSuccess(data.resp, data.file.raw)}\" > 更换图片 上传中 更换图片 import { defineComponent, PropType } from 'vue'; import Uploader from './Uploader.vue'; import { commonUploadCheck } from '../helper'; import { UploadOutlined, LoadingOutlined } from '@ant-design/icons-vue'; import { UploadResp } from '../../types/UploadResp'; export default defineComponent({ name: 'ImageProcesser', components: { Uploader, UploadOutlined, LoadingOutlined }, props: { value: { type: String as PropType, required: true } }, emits: ['change'], setup(props, {emit}) { const handleUploadSuccess = (resp: UploadResp, file: File) => { emit('change', resp.data.url); }; return { commonUploadCheck, handleUploadSuccess }; } }); .image-processer { padding: 10px 0; display: flex; box-sizing: border-box; .image-preview { flex: 0 0 150px; width: 150px; height: 84px; border: 1px dashed #e6ebed; background: no-repeat 50%/contain; } .image-process { padding: 5px 0; margin-left: 10px; display: flex; flex-direction: column; justify-content: space-between; } } 测试 ImageProcesser.spec.ts import { mount, VueWrapper } from '@vue/test-utils'; import ImageProcesser from '@/components/ImageProcesser.vue'; import flushPromises from 'flush-promises'; import axios from 'axios'; jest.mock('axios'); const mockedAxios = axios as jest.Mocked; let wrapper: VueWrapper; // 测试文件 const testFile = new File(['xyz'], 'test.png', {type: 'image/png'}); const mockComponent = { template: '' }; const mockButtonComponent = { template: '' }; const mockComponents = { 'UploadOutlined': mockComponent, 'LoadingOutlined': mockComponent, 'a-button': mockButtonComponent }; // 设置文件的值 const setInputValue = (input: HTMLInputElement) => { const files = [testFile] as any; Object.defineProperty(input, 'files', { value: files, writable: false }); }; describe('ImageProcesser', () => { beforeAll(() => { wrapper = mount(ImageProcesser, { props: { value: 'test.url' }, global: { stubs: mockComponents } }); }); it('测试图片是否显示', () => { expect(wrapper.find('.image-preview').attributes('style')).toBe('background-image: url(test.url);'); }); it('测试更改图片', async () => { mockedAxios.post.mockResolvedValueOnce({data: {url: 'a.png'}}); const vm = wrapper.vm as any; vm.handleUploadSuccess = jest.fn(); expect(wrapper.get('button').text()).toBe('更换图片'); const input = wrapper.get('input').element as HTMLInputElement; setInputValue(input); await wrapper.get('input').trigger('change'); expect(mockedAxios.post).toBeCalledTimes(1); expect(wrapper.get('button').text()).toBe('上传中'); await flushPromises(); expect(wrapper.get('button').text()).toBe('更换图片'); expect(vm.handleUploadSuccess).toBeCalled(); expect(vm.handleUploadSuccess).toBeCalledWith({ url: 'a.png' }, testFile); await wrapper.setProps({ value: 'a.png' }); expect(wrapper.find('.image-preview').attributes('style')).toBe('background-image: url(a.png);'); }); afterEach(() => { mockedAxios.post.mockReset(); }); }); 集成到属性面板 步骤一 更改PropsToForms.tstype AllProps = TextComponentProps & ImageComponentProps; type PropsToForms = { [key in keyof AllProps]?: PropToForm; } 步骤二 修改propsMap.ts src: { component: 'image-processer', text: '' } 重构StyledUploader与ImageProcesser 由于模板部分StyledUploader与属性部分的StyledUploader样式不一致,故定义如下属性以便针对两边进行适配。 // props属性类型定义 type ButtonType = 'primary' | 'default' | 'dashed' | 'danger' | 'link'; type Shape = 'circle' | 'round' | 'default' type Titles = string[]; type Icon = 'FileImageOutlined' | 'UploadOutlined'; // 属性声明 props: { type: { type: String as PropType, default: 'primary' }, shape: { type: String as PropType, default: 'default' }, titles: { type: Array as PropType, default() { return ['上传图片', '上传中...', '上传图片']; } }, fixedWidth: { type: [String, Number], default: '110px' }, icon: { type: String as PropType, default: 'FileImageOutlined' } } 完整实现 {handleUploadSuccess(data.resp, data.file.raw)}\" > {{ titles[0] }} {{ titles[1] }} {{ titles[2] }} import { defineComponent, PropType, computed } from 'vue'; import { FileImageOutlined, LoadingOutlined, UploadOutlined } from '@ant-design/icons-vue'; import { commonUploadCheck } from '../helper'; import Uploader from './Uploader.vue'; type ButtonType = 'primary' | 'default' | 'dashed' | 'danger' | 'link'; type Shape = 'circle' | 'round' | 'default' type Titles = string[]; type Icon = 'FileImageOutlined' | 'UploadOutlined'; export default defineComponent({ props: { type: { type: String as PropType, default: 'primary' }, shape: { type: String as PropType, default: 'default' }, titles: { type: Array as PropType, default() { return ['上传图片', '上传中...', '上传图片']; } }, fixedWidth: { type: [String, Number], default: '110px' }, icon: { type: String as PropType, default: 'FileImageOutlined' } }, components: { Uploader, FileImageOutlined, LoadingOutlined, UploadOutlined }, emits: ['success'], setup(props, {emit}) { const handleUploadSuccess = (resp: any, file: File) => { emit('success', {resp, file}); }; return { commonUploadCheck, handleUploadSuccess }; } }); 重构ImageProcesser import { defineComponent, PropType, ref } from 'vue'; import { UploadResp } from '../../types/UploadResp'; import StyledUploader from '@/components/StyledUploader.vue'; export default defineComponent({ name: 'ImageProcesser', components: { StyledUploader }, props: { value: { type: String as PropType, required: true } }, emits: ['change'], setup(props, {emit}) { const titles = ref(['更换图片', '上传中...', '更换图片']); const onImageUploaded = async (res: { [key: string]: UploadResp | File }) => { const resp = res.resp as UploadResp; emit('change', resp.data.url); }; return { titles, onImageUploaded }; } }); .image-processer { width: 100%; padding: 10px 0; display: flex; box-sizing: border-box; .image-preview { flex: 0 0 150px; width: 150px; height: 84px; border: 1px dashed #e6ebed; background: no-repeat 50%/contain; } .image-process { flex: 1; padding: 5px 0; margin-left: 10px; display: flex; flex-direction: column; justify-content: space-between; } } 最终效果 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/一点/":{"url":"pages/一点/","title":"一点","keywords":"","body":"一点 - 作业 第一周 01-需求和架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/一点/01-需求和架构设计.html":{"url":"pages/一点/01-需求和架构设计.html","title":"需求和架构设计","keywords":"","body":"慕课乐高架构方案设计文档 需求分析 需求分析思维导图 范围 从需求上我们大致可以分为 B端（作者端） H5 SSR（用户端） 后台管理系统（管理端） 三个端 而前端开发部分又可以分解成三个项目 editor-fe h5-ssr admin-fe 后端项目分也分解成三个项目 editor-server h5-server admin-server 模块设计 独立业务组件库 编辑器画布使用的组件和渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 作品的数据结构 思路 每个尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 组件扩展 编辑器组件的扩展（比如以后增加其它组件，视频组件，音频组件，抽奖组件等等） 页面信息的扩展（比如以后增加微信/微博/QQ分享） 其他扩展（比如埋点统计大数据分析） 开发提效 实现平滑发布增加用户体验感 脚手架：创建发布 组件平台 运维保障 错误日志收集 监控和报警 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/一点/02-脚手架设计和框架搭建.html":{"url":"pages/一点/02-脚手架设计和框架搭建.html","title":"脚手架设计和框架搭建","keywords":"","body":"1. 脚手架实现原理，基于 Lerna 搭建自己的脚手架并发布到npm 1.1脚手架简述 脚手架本质是一个操作系统得客户端，它通过命令行执行 vue create vue-test-app 上面这条命令主要由3个部分组成 主命令 vue command create command的 param vue-test-app 1.2脚手架的执行原理图 脚手架的执行原理如下： 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接倒实际文件 vue.js 终端利用 node 执行 vue.js vue.js解析 command / options vue.js执行 command 执行完毕，退出执行 1.3为什么全局安装 @vue/cli 后会添加的命令为 vue? 全局安装脚手架，会根据脚手架根目录的package.json 中的 bin 来决定脚手架的命令 \"bin\": { \"vue\": \"bin/vue.js\" } 1.4全局安装 @vue/cli 时发生了什么？ 全局安装脚手架后，会在node的目录下的node_modules生成 @vue 的脚手架包，并且会在 node的安装目录下生成一个vue环境变量，而这个环境变量的名字就取决于 @vue 的脚手架包根目录的 package.json 中的bin 1.5为什么 vue 执行一个 js 文件，我们却可以直接通过vue命令去执行它？ 因为在脚手架根目录的 package.json 中的bin 所指向的真正执行的 vue.js 中有 #!/usr/bin/env node 相当于我们执行 node vue.js 2. 理解 Yargs 常用 API 和开发流程 const yargs = require('yargs/yargs') // 一个ES6字符串标签，从多行字符串中去除缩进。 const dedent = require(\"dedent\"); const cli = yargs() const argv = process.argv.slice(2) // 注入额外参数 const context = { diaoVersion: '1.0.0', }; cli // 开启严格模式，输入无效命令会报错无法识别命令 .strict() // 在头部输出一段信息 .usage('Usage: diao-cli [command] ') // 设置需要输入命令的最小值，这里设置最少输入一个命令，否则则抛出错误信息 .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") // 如果没有找到匹配的命令，yargs提供关于类似命令的建议 .recommendCommands() // 在有错误的时候执行，可以在这里自定义错误信息 .fail((err, msg) => { console.error('err:', err) }) // 设置 command 的别名 .alias('h', 'help') .alias('v', 'version') // 设置命令行输出时候的宽度 .wrap(cli.terminalWidth()) // 在命令行末尾打印的消息 .epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `) // 配置额外选项 .options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) // 配置额外选项 .option(\"registry\", { type: \"string\", describe: 'Define global registry', alias: 'r' }) // 对选项进行分组 .group(['debug'], 'Dev Options') .group(['registry'], 'Extra Options') // 注册命令 .command('init [name]', 'Do init a project', (yargs) => { yargs .option('name', { type: 'string', describe: 'Name of a project', alias: 'n' }) }, (argv) => { console.log(argv) }) // 注册命令 .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'List local packages', builder: (yargs) => {}, handler: (argv) => { console.log(argv) } }) // 解析命令输入参数 .parse(argv, context) 3. 理解 Lerna 实现原理 Lerna 是基于 git+npm 的多package项目管理工具 3.1常用命令 npm init -y npm install -g lerna (// 全局安装) npm install lerna lerna -v ( // 输出版本号说明安装成功) lerna init (// 初始化lerna项目，会创建一个lerna.json) // 经过上面init这一步，会初始化git仓库，再搞一个.gitignore 配置一些不用上传的目录 git remote xxx (// 添加远程仓库) lerna create core (// 创建一个package) lerna create utils(// 又创建了一个package) lerna add (// 批量给两个package都安装依赖) lerna publish (// 发布项目) 3.2Lerna 实现原理 懵逼中，后面回过头再看~ 4. 理解 import-local 实现原理，理解 require.resolve 实现原理 懵逼中，后面回过头再看~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/光天化日之下/":{"url":"pages/光天化日之下/","title":"光天化日之下","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/光天化日之下/01-整体架构.html":{"url":"pages/光天化日之下/01-整体架构.html","title":"整体架构","keywords":"","body":"整体架构设计v1.0 需求 https://www.yuque.com/imooc-lego/zlz87z 范围 整体设计，架构设计，没有细节 模块设计 特殊模块重点说明 组件库，独立第三方，用于H5编辑器前端和后台前端 自研统计服务 作品的数据结构 vuex store 集中管理 work: { name: '作品名称', id: 'xxx', config: {}, props: { componnets: [ { id: 'xxx', name: '文本'， tag: 'div', attrs: { color: '#000' }, children: [ '文本1' ] } ], } }, activeSelectComp: '当前选中的组件id' 数据流转关系图 图层layer通过computed计算得出 扩展性保证 扩展组件，数据结构层面 扩展编辑器的功能，如：隐藏、锁定 扩展页面的配置，config 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/":{"url":"pages/六个周/","title":"六个周","keywords":"","body":"课程学习概况 I'm六个周，2021年的全年学习目标，就围绕着这门课程开始了。 2021年1月27日，第一阶段课程已经学习完毕，第二阶段还未开始。 2021年3月6日，第一阶段课程的第二遍内容已经学习完毕，并做了完整的课程学习记录，目录如下： 目录 Week0-整体架构设计文档范本V0.1 Week1-需求分析与架构设计 Week2-脚手架架构设计和框架搭建 Week3-脚手架核心流程开发 Week4-脚手架命令注册和执行过程开发 Week5-脚手架创建项目流程设计和开发 Week6-脚手架项目和组件初始化开发 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/01.需求分析与架构设计.html":{"url":"pages/六个周/01.需求分析与架构设计.html","title":"01.需求分析与架构设计","keywords":"","body":"Week1-需求分析与架构设计 week1:需求分析与架构设计 第一章 课程导学 1-1 课程导学 课程目标对标大厂P7 课程准备从招聘、提高自身实力、分析未来发展展开 课程内容：5大核心系统、12个代码仓库、4万行代码等构成一个体系完整的闭关系统项目。 项目预览、体系关系图、知识点图谱等。 收获：具有web前端架构师能力、亲身精力实战研发过程、拥有架构师思维。 对前置知识：TS/Vue/React/Webpack/nodejs等自行查漏补缺。 多实践、记录笔记。 第二章 周介绍 2-1 周介绍 本周内容：需求和架构设计 收获：研发流程规范化、熟悉产品需求、以架构师思维分析理解需求、《整体技术方案设计》文档、学会如何写技术方案设计。 第三章 需求分析 脱离业务的架构就是耍流氓 、架构师必须深入理解需求、参与需求、看透需求背后的业务本质。 3-1 产品研发流程 公司起步-> 项目启动 ->需求 -> 技术方案设计 -> 开发 -> 联调 -> 测试 -> 上线(版本升级) -> 项目总结 -> 年度总结 3-2 以架构师的思维分析需求 一道面试题开始--要对业务本身以及延伸展开考虑 3-3 项目浅层需求 简言之就是从项目前端业务展示看整个项目的流程 3-4 深度需求 不容易一眼看出来，却很重要的需求 作品管理(删除恢复、转增、复制) 作品统计(通过统计看结果，分渠道统计) 作品发布(url不变、支持多渠道) H5分享(对业务增长服务) 后台管理(数据全局把控) 3-5 需求总结 第四章 架构设计 4-1 整体架构设计--章介绍 任何看似复杂的架构，都是让整个系统变得简单 学会如何写技术方案设计 看整体、考虑扩展性、可行性、多调研、莫为设计而设计、用最简单实现方式。 4-2 分析需要多少个项目 B端编辑器(前端、后端)、H5、管理后台(前端、后端) 4-3 需要自研统计服务 需要自研统计服务的原因：第三方贵且不能很好满足需求。 4-4 各个项目之间的关系图 4-5 作品数据结构设计 4-6 数据流转关系图 4-7 技术方案文档的重要性 4-8 写架构设计文档 通过此节内容，整理一个架构设计文档的范本，方便以后在写架构设计文档的时候有个demo参考。 整体架构设计范本 4-9 本周总结以及下一步操作 第五章 本周总结 5-1 本周总结 以架构师思维分析需求、理解需求，写整体技术方案设计。 5-2 关于作业和打卡 homework.imooc-lego.com Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/02.脚手架架构设计和框架搭建.html":{"url":"pages/六个周/02.脚手架架构设计和框架搭建.html","title":"02.脚手架架构设计和框架搭建","keywords":"","body":"Week2-脚手架架构设计和框架搭建 第一章 本周介绍 1-1 确立本周目标 脚手架的实现原理、调试原理 Lerna的常见用法、源码分析 架构设计技巧和架构图绘制方法 Node的module模块分析 yarns使用方法 剖析Lerna架构设计 1-2 前端研发脚手架imooc-cli核心功能演示 安装imooc-cli脚手架： npm i -g @imooc-cli/core 查看脚手架相关内容： __imooc-cli 通过脚手架新建项目: imooc-cli init 项目发布到测试环境： imooc-cli publish 项目发布到正式环境: imooc-cli publish --prod 1-3 脚手架在课程中的定位 本项目中基础项目均由脚手架管理 技术简历突出 提高技能 第二章 脚手架开发入门 2-1 本章知识脉络和难点解析 分析开发脚手架的必要性 从使用角度去理解什么是脚手架 脚手架的实现原理(与操作系统关联) 脚手架的开发流程 2-2 站在前端研发的视角，分析开发脚手架的必要性 开发imooc-cli脚手架的核心目标：提升前端研发效能【提炼通用代码、通用流程、构建发布上线】 脚手架核心价值：自动化、标准化、数据化 和自动化构建工具(jenkins、travia)区别：自动化构建工具在服务端执行，无法覆盖本地操作且定制自动化的构建工具需要用到Java等后端语言，对前端不友好。 2-3 从使用角度理解什么是脚手架？ 脚手架简介：脚手架的本质是一个操作系统的客户端，通过命令行执行。 脚手架执行原理： 从应用角度看vue-cli开发脚手架过程： 首先是个npm项目，项目中有一个bin/vue.js的文件，且这个项目发布到了npm上 将npm项目安装到了lib/node_modules 在node的bin目录下配置软链接到lib/node_modules/@vue/cli/bin/vue.js 脚手架执行原理解析： 在终端输入：vue create vue-test-app 终端解析vue命令【通过which vue查找vue】 根据vue命令链接到实际的vue.js文件 终端使用node执行vue.js文件 vue.js文件解析command/options vue.js文件执行command 执行完毕，退出执行 2-4 脚手架原理讲解(上) 问题一：为什么全局安装@vue/cli后,我们执行的命令为 vue呢？ 答：这是因为通过which vue后我们会看到vue所在目录，而这个vue是一个软链接，指向的是@vue/cli。确定这个vue命令名称的是在node/v12.16.1/lib/node_modules/@vue/cli目录下package.json中的bin的键值。 问题二：全局安装@vue/cli时发生了什么？ 答：执行 npm install -g @vue/cli的时候，首先node会把我们当前包下载到node下的node_modules中去。下载完成后，会在下载好的包中查找package.json中是否有bin，如果有，会通过package.json中的bin中的键去配置软链接。 上面两个问题其实问题二在前，问题一在后，两个问题说的是一个流程的双向解释，理解了问题二，问题一就清楚了。 问题三：执行vue命令时发生了什么？为什么vue指向一个js文件，我们却可以通过vue命令执行它？ 答：首先执行vue命令，与执行which vue打印出来的地址 效果是等价的(即执行的是which vue的那个软连接:/Users/liumingzhou/.nvm/versions/node/v12.16.1/bin/vue)。 而软连接又指向它的实际文件存在路径(../lib/node_modules/@vue/cli/bin/vue.js)。 我们知道，一个test.js文件可以通过node执行，但不能单独执行，这是因为它没有可执行权限。 我们在/Users/liumingzhou/Desktop目录下新建一个test.js文件，我们可以给这个js文件一个执行权限：chmod 777 test.js 然后在命令行直接输入 ./test.js仍然不可以执行。这是因为js文件需要一个解释器来进行执行，这个node就是一个解释器。(.py文件需要 python解释器执行，.java文件需要java解释器进行执行)。 那么我们上面的vue.js文件是怎么执行的呢？ 通过查看vue.js文件源码，我们发现第一行代码是这样的：#!/usr/bin/env node 这行代码的意思是：告诉我们的操作系统，直接调用这个文件的时候，到环境变量中查找node命令执行。 (/usr/bin/env 是我们的环境变量) 然后，我们在我们的test.js文件中第一行加入这行代码 #!/usr/bin/env node 直接输入 ./test.js 即可执行这个js文件。 接着，我们不想用 ./test.js这样的方式执行js文件，我们想通过一个命令，比如 liugezhou 这个命令来执行这个test.js文件，我们需要怎么做呢？ 第一种方式，我们去找环境变量，通过 echo $PATH 首先，我们创建一个环境变量： cd /Users/liumingzhou/.nvm/versions/node/v12.16.1/bin 创建软连接：ln -s /Users/liumingzhou/Desktop/test.js liugezhou 创建完毕后，就可以看到一个liugezhou软连接，我们在任何目录执行liugezhou就可以执行test.js文件了。 2-5 脚手架原理讲解（下） 问题一：为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装额应用/软件有什么区别** 脚手架执行起来的本质是靠node这个命令，node是一个操作系统客户端，而test.js 这个文件仅仅是作为一个参数注入到node命令中。node本质上是一个可执行文件(在window操作系统中可以看到node的扩展名为.exe的)。 本质来说没有区别。区别仅仅是安装的应用软件会提供一个GUI,而node并没有提供GUI 问题二：如何为node脚手架命令创建别名 方法一：即为上文提到的创建一个软连接。 接着，我们希望继续为上文提到的 liugezhou 软连接继续添加一个别名，我们需要这么做 在上文的bin目录下，执行命令 ln -s ./liugezhou liugezhou2 即 软连接可以嵌套。 问题三：描述脚手架命令执行的全过程 2-6 脚手架开发流程和难点解析 通过以上分析，我们大致了解一个脚手架的开发流程如下： 创建一个npm项目 创建脚手架的入口文件，且入口文件需要添加代码：#!/usr/bin/env node 配置package.json文件，添加bin属性(指定脚手架命令与地址) 编写脚手架代码 将脚手架发布到npm 使用流程： 安装脚手架： npm install - g your-own-cli 使用脚手架： your-own-cli 脚手架开发难点： 脚手架开发过程中通常需要将复杂的系统拆分为多个模块(分包) 脚手架开发过程中需要注册一系列的命令。如何对命令进行注册是一个重要的环节 需要对参数进行解析: [vue command [options] ] 帮助文档：global[主命令] ………… 命令行交互、日志打印、命令行文字变色、网络通信 HTTP/WebSocket、文件处理等。 2-7 快速入门第一个脚手架 通过上节流程，我们本节快速开发一个liugezhou-test脚手架并发布，流程如下: cd /Users/liumingzhou/Desktop mkdir liugezhou-test cd liugezhou-test npm init -y 终端打开liugezhou-test项目：新建lib目录，lib目录下新建index.js文件（index.js文件内容如下） 修改package.json文件，添加 \"bin\":{\"liugezhou-test\":\"lib/index.js\"} npm publish 发布npm包 下载安装：npm i -g liugezhou-test 测试：liugezhou-test #!/usr/bin/env node console.log('welcome liugezhou-test') 这里注意一点，在npm publish的时候，如果是在Descktop目录下执行的，那么我们下载liugezhou-test包之后，会看到软链指向的是本地，这是因为npm为了我们本地调试：如果/Desktop目录下有这个包，会指向本地。 2-8 脚手架本地调试方法 方式一：如上文所说，直接在Desktop目录下执行：npm install -g liugezhou-test,即调试本地包。 (移除本地安装的包：npm remove -g liugezhou-test) 方式二：直接在liugezhou-test文件目录下，执行：npm link,软链指向的node_modules源文件指向本地包。 分包情况下，如何调试本地包？ 如果/Desktop/liugezhou-test要使用/Desktop/lilugezhou-test/lib包下的方法，如何做呢？ 在/Desktop/liugezhou-test/lib目录下，npm link 在/Desktop/liugezhou-test/目录下，npm link liugezhou-test-lib 2-9 脚手架本地调试标准流程总结 链接本地脚手架 cd your-cli-dir npm link 链接本地库文件 cd your-lib-dir npm link cd your-cli-dir npm link your-lib-dir 取消链接本地库文件 cd your-lib-dir npm unlink cd your-cli-dir npm unlink your-lib-dir #link存在 rm -rf node_modules # link不存在 npm i -S your-lib-dir 理解 npm link npm link : 将当前项目链接到node全局node_modules中作为一个库文件，并解析bin配置创建可执行文件。 npm link your-libr:将当前项目中node_modules下指定的库文件链接到node全局node_modules下的库文件 理解 npm unlink npm unlink:将当前项目从node全局node_modules中移除 npm unlink your-lib:将当前项目中的库文件依赖删除。 2-10 脚手架命令注册和参数解析 process是node的内置库 我们在index.js中写代码： console.log(require('process')) 通过命令行执行 liugezhou-test init 会看到process有许许多多个属性，其中有一个argv属性。 通过分析这个argv属性，我们就看到了init这个属性。 因此我们可以通过argv来判断是否输入了 init 这个命令。 2-11 脚手架项目发布 老生常谈，npm publish 通过判断argv输入的参数，在liugezhou-test-lib中与liugezhou-test中加入相关逻辑 实现 liugezhou-test init 与 liugezhou -V的输出显示 然后分别发布，remove掉本地链接。 第三章 脚手架框架搭建 3-1 本章的收获是什么，难点是什么？ 本节课程非常下饭： 收获一：Lerna简介 [Lerna管理的项目有:babel、create-reat-app、vue-cli] 通过学习lerna将学会如何管理一个复杂的Javascript项目 收获二：Lerna源码分析：讲解源码结构、执行流程、源码精读 收获三：基于lerna设计简历。 3-2 原生脚手架开发痛点分析 lerna设计源于其要解决的问题，首先我们要分析写原生脚手架开发的痛点： 痛点一：重复操作 多Package本地link 多Package依赖安装 多Package单元测试 多Package代码提交 多Package代码发布 版本一致性 发布时版本一致性 发布后相互依赖版本升级 3-3 本章重点：lerna简介及脚手架开发流程 Lerna简介 Lerna : A tool for managing JavaScript projects with multiple packages. 用于管理具有多个程序包的JavaScript项目的工具。 Lerna : Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm. Lerna是一个基于 git+npm 的优化工作流的多package项目的管理工具。 优势 大幅减少重复操作 提升操作的标准化 Lerna 是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 lerna官网：https://lerna.js.org/ Lerna开发脚手架流程 ⭐️⭐️⭐️ 3-4 基于lerna搭建脚手架框架 本节使用命令依次如下 mkdir liugezhou-cli-dev cd liugezhou-cli-dev npm init -y npm i -g lerna【全局安装】 npm i -S lerna lerna init lerna create core lerna create utils 3-5 Lerna核心操作 本节使用命令依次如下： lerna add liugezhou-test (在packages目录下所有包中安装liugezhou-test包) lerna add liugezhou-test packages/core （在指定包core中添加依赖） lerna clean (清除packages目录下的依赖) lerna bootstrap (将刚清除的所有依赖，重新安装) lerna link (开发的版本互相存在依赖，可用此命令完成) lerna exec -- [...args] lerna exec -- rm -rf node_modules 删除packages目录下的所有node_modules文件夹 lerna exec --scope @liugezhou-cli/utils--rm -rf node_modules 删除packages目录下utils的。。。。 【上下文为packages目录】 lerna run test lerna run --scope @liugezhou-cli/core test [执行core包package.json中script标签的test属性] 3-6 Lerna发布流程(lerna使用总结) lerna init 会自动完成 git 初始化，但不会创建 .gitignore，这个必须要手动添加，否则会将 node_modules 目录都上传到 git lerna add: 第一个参数：添加npm包名 第二个参数：本地package的路径（如果不加，则全部安装） 可选参数：--dev：将依赖安装到devDependencies,不加时安装到dependencies lerna link 如果未发布上线，需要手动添加到package.json中再执行。 lerna clean 只会删除 node_modules,不会删除package.json中的依赖 lerna exec 和 lerna run --scope属性后添加的是包名，不是package的路径，这点和 lerna add 不同 lerna publish 发布时会自动执行 git add package-lock.json,所以该文件不能加入到.gitignore中去。 发布时先创建远程仓库，且push代码。 执行npm publish前完成 npm login 如果发布的包名为 @xxxx/yyy 的格式，需要现在npmjs.org上注册organization 发布到npm group时默认为private，package.json中需手动添加配置： \"publishConfig\": { \"access\": \"public\"} 第四章 Lerna源码解析 4-1 赚回学费：武装简历、升职加薪 为什么要做源码解析：赚回学费、走上人生巅峰 自我成长、提升编码能力和技术深度的需要 为我所用，应用到实际开发，实际产生效益 学习借鉴，站在巨人的肩膀上，登高望远 为什么要分析Lerna源码 2W+ star的明星项目 Lerna是脚手架，对我们开发脚手架有借鉴意义 Lerna项目中蕴含大量的最佳实践，值得深入研究和学习 学习目标 Lerna源码结构和执行流程分析 import-local源码深度精读 学习收获 如何将源码分析写进简历 学习明星项目的架构设计 获得脚手架执行流程的一种实现思路 获得脚手架调试本地源码的另一种方式 Node.js加载node_modules模块的流程 ✨✨✨✨✨ 各种文件操作算法和最佳实践 4-2 lerna源码结构分析和调试技巧 github下载lerna源码到本地且安装依赖！ 使用webstorm打开源码，找到入口文件--package.json中的bin属性。 webstorm添加调试：Edit Configurations，这里需要在Configuration中添加node parameters 这里遇到一个问题，代码调试的时候，Variables窗口内没内容。 4-3 Node源码调试过程中必会的小技巧 WebStorm -> Preferences... -> 搜索 Node.js and NPM -> 勾选 Coding assistance for Node.js 这个目的是：对当前项目中的一些默认库或内置库做一些高亮 搜索 Debugger -> Stepping -> 默认勾选的都取消掉 这个目的是在调试的时候，取消勾选就可以进去一些库文件查看源码 4-4 lerna初始化过程源码详细分析 通过前面分析，我们知道，入口文件为：lerna/core/lerna/cli.js文件，从这里开始看源码： require(\".\")(process.argv.slice(2)); require('.'):这里的 . 是相对路径,相当于是 require('./index.js) 到这行代码后，先加载与该cli.js同级别目录下的index.js文件。 等文件加载完毕后，将process.argv.slice(2)参数， 也就是我们写入的参数，传入到 index.js文件中module.exports出来的方法 main 4-5 【高能知识点】npm项目本地依赖引用方法 本地依赖的最佳实践：引用本地包的方式可以使用 file的方式，这是因为lerna publish的时候可以在线上环境把fiel的方式改成引用线上包的方式。大概是个这么个意思。这种方式可以去除之前使用 npm link的方式。 理解了这里本地依赖的file引用后，回到之前的3-6 lerna-publish发布流程项目，将本地引用的@cloudscope-cli/utils改为file引用，这里需要注意：在@cloudscope-cli/core中使用file方式引用了本地的utils包后，需要npm install一下。 4-6 脚手架框架yargs快速入门 首先在npmjs官网搜索yargs，看一下基本使用情况,然后开始我们的学习： 在某目录下，新建一个空的项目，具体操作如下： mkdir liugezhou-test npm init -y 新建lib/index.js package.json文件添加 \"bin\":\"lib/index.js\" npm install -S yarns npm install -S dedent 然后，开始编辑index.js文件，进行yargs相关用法的学习： 4-7 yargs高级用法讲解 关于yargs的command用法，我们从npmjs官网，看到示例如下： 通过以上代码，我们可以看到定义command的时候，传入了四个参数： 'serve [port]': command的格式,port为我们自定义的option，相当于 liugezhou-test serve 'start the serve':关于此serve command命令的补充描述 第三个参数为builder函数：在执行此command具体命令之前做的动作，比如上文为serve这个命令定义了一个参数 port，且给定port的默认值为5000 第四个参数我们叫做handler：是用来具体执行command的一个行为 在对上面demo有个简单了解后，回到我们上一节的代码中，继续添加command定义： 4-8 lerna脚手架初始化过程超详细讲解 通过 4-6、4-7两节内容，分析lerna脚手架的初始化过程讲解。 4-9 lerna脚手架Command执行过程详解 大致流程了解，未画流程图。 4-10 【关键知识复习】javascript事件循环--EventLoop EventLoop中存在两种事件：宏任务(MacroTask)和微任务(MicroTask) JavaScript脚本中加入到宏任务中去 当宏任务队列中任务执行完毕后，会将微任务队列中任务清空，清空之后再去执行宏任务队列。这种循环往复的执行流程就称为事件循环--EventLoop。 然后：我们在宏任务中加入一个setTimeout。 接着，我们在宏任务队列中加入一个 Promise.then() , Promise.then()中的内容会被加入到微任务队列中去。 4-11 import-local执行流程深度分析 import-local的作用是：当我们的项目当中本地存在一个脚手架命令，同时全局在node当中也存在一个脚手架命令的时候，优先选用本地的node_modules中的版本。 在执行一个node代码的时候，默认会向node代码当中注入一些变量：filename 、 dirname 、 require 、 module、exports. 首先，执行lerna命令的时候，会执行node全局下的lerna，即which lerna 指向的： 软连接：/Users/liumingzhou/.nvm/versions/node/v12.16.1， 实际指向：/Users/liumingzhou/.nvm/versions/node/v12.16.1/lib/node_modules/lerna/cli.js[PRATIC] 然后，在webstorm的debug调试中，Node parameters修改为[PRATIC] 地址。 接着，点击调试按钮，我们知道，程序首先进入的文件是[PRATIC] #!/usr/bin/env node \"use strict\"; /* eslint-disable import/no-dynamic-require, global-require */ const importLocal = require(\"import-local\"); if (importLocal(__filename)) { require(\"npmlog\").info(\"cli\", \"using local version of lerna\"); } else { require(\".\")(process.argv.slice(2)); } 通过上面分析我们知道了执行流程，现在的重点就是看代码中的 require('import-local')中的源码。 我们进入到import-local源码中： 'use strict'; const path = require('path'); const resolveCwd = require('resolve-cwd'); const pkgDir = require('pkg-dir'); module.exports = filename => { const globalDir = pkgDir.sync(path.dirname(filename)); const relativePath = path.relative(globalDir, filename); const pkg = require(path.join(globalDir, 'package.json')); const localFile = resolveCwd.silent(path.join(pkg.name, relativePath)); return localFile && path.relative(localFile, filename) !== '' ? require(localFile) : null; }; path.dirname(filename)：这句代码的意思是获取到文件filename的上级目录。 4-12 pkg-dir源码解析（一大波优秀的文件操作库) 本节分析上面代码，对import-local源码细节分析，本节分析代码流程为globalDir是如何获得的： const pkgDir = require('pkg-dir') pkg-dir:字面意思为，获得package.json文件的上级目录 进入 pkg-dir源码： 'use strict'; const path = require('path'); const findUp = require('find-up'); module.exports = cwd => findUp('package.json', {cwd}).then(fp => fp ? path.dirname(fp) : null); module.exports.sync = cwd => { const fp = findUp.sync('package.json', {cwd}); return fp ? path.dirname(fp) : null; }; 我们分析pkg-dir代码可知：pkg-dir这个库向我们暴露了两个方法：默认cwd和sync方法，其中sync方法会以同步的方式执行。 同时，这里又引用find-up这个库 'use strict'; const path = require('path'); const locatePath = require('locate-path'); module.exports = (filename, opts = {}) => { const startDir = path.resolve(opts.cwd || ''); const {root} = path.parse(startDir); const filenames = [].concat(filename); return new Promise(resolve => { (function find(dir) { locatePath(filenames, {cwd: dir}).then(file => { if (file) { resolve(path.join(dir, file)); } else if (dir === root) { resolve(null); } else { find(path.dirname(dir)); } }); })(startDir); }); }; module.exports.sync = (filename, opts = {}) => { let dir = path.resolve(opts.cwd || ''); const {root} = path.parse(dir); const filenames = [].concat(filename); // eslint-disable-next-line no-constant-condition while (true) { const file = locatePath.sync(filenames, {cwd: dir}); if (file) { return path.join(dir, file); } if (dir === root) { return null; } dir = path.dirname(dir); } }; 同理，find-up这个库也是默认的module.exports方法与同步返回的sync方法。 这里我们继续分析find-up这个库的sync方法，一行一行代码解析： let dir = path.resolve(opts.cwd || ''); path.resolve是我node当中经常使用的方法，它主要作用是把两个相对路径进行结合。 path.resolve('/Users','/liumingzhou'),返回的路径为 /liumingzhou path.join('/Users','/liumingzhou'),返回的路径为 /Users/liumingzhou 这里有个注意点是path.resolve('.')返回的是当前路径,而path.join('.'),返回的就是. 不会帮我们判定当前的 . 与上级路径的关系。 const {root} = path.parse(dir); path.parse(\"/Users/liumingzhou/Documents/imoocCourse/Web前端架构师/lerna/core\") 返回的结果为： { root:'/', dir:'/Users/liumingzhou/Documents/imoocCourse/Web前端架构师/lerna/core', base:'lerna', ext:'', name:'lerna' } const filenames = [].concat(filename); 通过分析上下文，我们知道这行代码的filename指的是 package.json,于是filenames = ['package.json'] while (true) {} 这里是个无限循环，需要注意的一点是退出条件 const file = locatePath.sync(filenames, {cwd: dir}); 这里又调用了这个locatePath这个库的sync方法，local-path这个库的作用是磁盘中是否存在这个路径，如果存在会把第一个文件返回。 ... module.exports.sync = (iterable, options) => { options = Object.assign({ cwd: process.cwd() }, options); for (const el of iterable) { if (pathExists.sync(path.resolve(options.cwd, el))) { return el; } } }; 通过上面的代码，我们看到上面又用到了一个库：pathExists(通过名字我们显而易见的知道，这个库的作用是判断传入的一个路径是否存在的)，pathExists这个库源码不贴了，主要的一行代码是：fs.accessSync(fp),这行代码就是判断是否能到达一个文件，如果报错就会被try catch捕获返回false if (file) { return path.join(dir, file); } 通过前面分析 path.join(dir, file)返回的就是 /Users/liumingzhou/Documents/imoocCourse/Web前端架构师/lerna/core/lerna/package.json 最终获得globalDir！ 4-13 resolve-from源码解析（彻底搞懂node_modules模块加载逻辑） 我们回到import-local源码，继续看 const relativePath = path.relative(globalDir, filename); demo: const relativePath = path.relative(\"/a/b/c\", '/a/b/c/d.js'); relativePath返回值为 d.js const pkg = require(path.join(globalDir, 'package.json')); 这里获得package.json这个文件 import-local最关键的一部分来了： const localFile = resolveCwd.silent(path.join(pkg.name, relativePath)); resolveCwd的含义是给出一个包名和主进入文件名，去本地文件中查找是否存在这样的路径 然后我们就进入resolveCwd这个引用库的源码，查看是如何实现的(传入的参数为 lerna/cli.js) 'use strict'; const resolveFrom = require('resolve-from'); module.exports = moduleId => resolveFrom(process.cwd(), moduleId); module.exports.silent = moduleId => resolveFrom.silent(process.cwd(), moduleId); 这里又引用了resolve-from这个库的silent静默方法(源码见下)： 这里需要引起注意一点的是resolve-from这个库传入的两个参数分别是上面提到的 lerna/cli.js以及 process.cwd()这个参数，这个process.cwd的传入参数为Working directory： 'use strict'; const path = require('path'); const Module = require('module'); const resolveFrom = (fromDir, moduleId, silent) => { if (typeof fromDir !== 'string') { throw new TypeError(`Expected \\`fromDir\\` to be of type \\`string\\`, got \\`${typeof fromDir}\\``); } if (typeof moduleId !== 'string') { throw new TypeError(`Expected \\`moduleId\\` to be of type \\`string\\`, got \\`${typeof moduleId}\\``); } fromDir = path.resolve(fromDir); const fromFile = path.join(fromDir, 'noop.js'); const resolveFileName = () => Module._resolveFilename(moduleId, { id: fromFile, filename: fromFile, paths: Module._nodeModulePaths(fromDir) }); if (silent) { try { return resolveFileName(); } catch (err) { return null; } } return resolveFileName(); }; module.exports = (fromDir, moduleId) => resolveFrom(fromDir, moduleId); module.exports.silent = (fromDir, moduleId) => resolveFrom(fromDir, moduleId, true); 分析上面代码，最关键的代码为： const resolveFileName = () => Module._resolveFilename(moduleId, { id: fromFile, filename: fromFile, paths: Module._nodeModulePaths(fromDir) }); Module：node的内置模块，(通常开发过程中是不需要使用的),Module中的 下划线(_)方法，都称为内置方法 _resolveFilename方法，是我们node中 require方法实现的核心方法之一，关于require方法的实现，参考阮一峰老师的这篇文章：require()源码解读 分析上面这段代码，Module._resolveFilename的作用是解析模块的真实路径，这个方法传进去两个参数，其中第一个options我们发现了： Module._nodeModulesPaths(fromDir)这个方法，这个方法的作用是生成node_modules的可能路径。 在对这个方法源码进行学习前，我们预先从老师那了解到了这个方法的实现逻辑： 然后我们进入到Module._nodeModulesPaths方法中： Module._nodeModulePaths = function(from) { // Guarantee that 'from' is absolute. from = path.resolve(from); // Return early not only to avoid unnecessary work, but to *avoid* returning // an array of two items for a root: [ '//node_modules', '/node_modules' ] if (from === '/') return ['/node_modules']; // note: this approach *only* works when the path is guaranteed // to be absolute. Doing a fully-edge-case-correct path.split // that works on both Windows and Posix is non-trivial. const paths = []; for (let i = from.length - 1, p = 0, last = from.length; i >= 0; --i) { const code = from.charCodeAt(i); if (code === CHAR_FORWARD_SLASH) { if (p !== nmLen) paths.push(from.slice(0, last) + '/node_modules'); last = i; p = 0; } else if (p !== -1) { if (nmChars[p] === code) { ++p; } else { p = -1; } } } // Append /node_modules to handle root paths. paths.push('/node_modules'); return paths; }; 分析以上代码，这里我们的from是：/Users/liumingzhou/Documents/imoocCourse/Web前端架构师/lerna 然后通过上面算法计算，最后得到的结果是： [/Users/liumingzhou/Documents/imoocCourse/Web前端架构师/lerna/node_modules, /Users/liumingzhou/Documents/imoocCourse/Web前端架构师/node_modules, /Users/liumingzhou/Documents/imoocCourse/node_modules, /Users/liumingzhou/Documents/node_modules, /Users/liumingzhou/node_modules, /Users/node_modules, /node_modules] 将这个数组返回后，我们继续分析Module._resolveFilename这个方法的源码： 同样在对这个方法源码进行学习前，我们也预先从老师那了解到了这个方法的实现逻辑： 4-14 Node模块加载核心方法_resovleFileName源码深入解析 首先，关于Module._resolveFileName的源码分析要更为复杂，这是因为算法部分较多。 Module._resolveFilename这个方法的源码为如下(代码逻辑添加注释)： Module._resolveFilename = function(request, parent, isMain, options) { if (NativeModule.canBeRequiredByUsers(request)) { //判断是否为可加载的内置模块 return request; } let paths; if (typeof options === 'object' && options !== null) { //我们在这传入的options是 undefined，因此之间跳过到else中---即执行Module._resolveLookupPaths(request, parent); if (ArrayIsArray(options.paths)) { const isRelative = request.startsWith('./') || request.startsWith('../') || ((isWindows && request.startsWith('.\\\\')) || request.startsWith('..\\\\')); if (isRelative) { paths = options.paths; } else { const fakeParent = new Module('', null); paths = []; for (let i = 0; i 0) { message = message + '\\nRequire stack:\\n- ' + requireStack.join('\\n- '); } // eslint-disable-next-line no-restricted-syntax const err = new Error(message); err.code = 'MODULE_NOT_FOUND'; err.requireStack = requireStack; throw err; }; Module._resolveLookupPaths这个方法的源码为如下(代码逻辑添加注释)： 主要功能就是将paths和环境变量node_modules合并 Module._resolveLookupPaths = function(request, parent) { if (NativeModule.canBeRequiredByUsers(request)) { // 先判断是否为内置模块 debug('looking for %j in []', request); return null; } // Check for node modules paths. if (request.charAt(0) !== '.' || (request.length > 1 && request.charAt(1) !== '.' && request.charAt(1) !== '/' && (!isWindows || request.charAt(1) !== '\\\\'))) { let paths = modulePaths; //环境变量中存储的一些node_modules目录 if (parent != null && parent.paths && parent.paths.length) { paths = parent.paths.concat(paths); // 与之前传进来的paths进行合并 } debug('looking for %j in %j', request, paths); return paths.length > 0 ? paths : null; // 将合并的paths返回 } // In REPL, parent.filename is null. if (!parent || !parent.id || !parent.filename) { // Make require('./path/to/foo') work - normally the path is taken // from realpath(__filename) but in REPL there is no filename const mainPaths = ['.']; debug('looking for %j in %j', request, mainPaths); return mainPaths; } debug('RELATIVE: requested: %s from parent.id %s', request, parent.id); const parentDir = [path.dirname(parent.filename)]; debug('looking for %j', parentDir); return parentDir; }; Module._findPath要解决的问题是在paths中解析模块的真实路径， 同样在对这个方法源码进行学习前，我们也预先从老师那了解到了这个方法的实现逻辑： 源码如下： Module._findPath = function(request, paths, isMain) { const absoluteRequest = path.isAbsolute(request); //判断是否为绝对路径 if (absoluteRequest) { paths = ['']; } else if (!paths || paths.length === 0) { return false; } // 通过 \\x00 生成一大段的cacheKey const cacheKey = request + '\\x00' + (paths.length === 1 ? paths[0] : paths.join('\\x00')); const entry = Module._pathCache[cacheKey]; if (entry) return entry; let exts; // trailingSlash判断request是否已 / 结尾的 let trailingSlash = request.length > 0 && request.charCodeAt(request.length - 1) === CHAR_FORWARD_SLASH; // 若不是以 / 结尾， if (!trailingSlash) { //会以正则进行匹配，这里的正则在下下节专门学习，这里暂时略过，这里的结论：该正则表示的结果为 是否是以“/..、/.、.. 、 . ”结尾 trailingSlash = /(?:^|\\/)\\.?\\.$/.test(request); } // For each path for (let i = 0; i 4-15 fs模块toRealPath源码深入解析 ** 我们到toRealPath方法后，webStorm的node调试工具，点击继续 Step Into到该方法中，代码如下： // 通过代码，我们知道toRealPath的方法实现，正如上面的逻辑图显示的，使用的是 fs.realpathSync这个模块。 function toRealPath(requestPath) { // 该方法传入两个参数，一个路径地址 requestPath，以及一个options // realpathCache为一个chche，表示的是当前已经做过路径判断的所有路径缓存，绝大多数的key值与value值是一样的，并没有软链接，但是也存在少量的有软连接的：key与value值不同 return fs.realpathSync(requestPath, { [internalFS.realpathCacheKey]: realpathCache }); } 同样的，我们在进去toRealPath这个方法，看到fs.realpathSync实现之前，我们先从老师哪里有拿到逻辑图，并根据图进行分析学习该代码里面的逻辑： 然后我们继续 Step Into到fs.realpathSync这个方法中，源码如下： // options 为Symbol function realpathSync(p, options) { if (!options) options = emptyObj; else options = getOptions(options, emptyObj); p = toPathIfFileURL(p); // 如果不是string格式的，进行格式转换 if (typeof p !== 'string') { p += ''; } //判断该路径是否为有效路径 validatePath(p); //pathModule 与我们直接引用的path模块没有区别：相对路径转为绝对路径 p = pathModule.resolve(p); // cache为一个map对象 const cache = options[realpathCacheKey]; // 查找缓存 const maybeCachedResult = cache && cache.get(p); // 是否查到了缓存，如果查到直接返回，如果没有查到，继续向后 if (maybeCachedResult) { return maybeCachedResult; } // 定义所有软连接的缓存，ObjectCreate(null)创建的对象没有原型链，好处为它是一个纯粹的对象，节约内存空间 const seenLinks = ObjectCreate(null); const knownHard = ObjectCreate(null); //将传入的path保存下来，做了一个缓存，这里的p相当于缓存中的key(若是软连接，则为软连接路径)，original相当于value(实际路径)，这么做的原因为：这里的p我们后面可能会发生改变 const original = p; // 然后下面代码，进入到上图流程图中的路径是否存在/这个流程 // Current character position in p let pos; // The partial path so far, including a trailing slash if any let current; // The partial path without a trailing slash (except when pointing at a root) let base; // The partial path scanned in the previous round, with slash let previous; // Skip over roots // 找到p中的根路径 current = base = splitRoot(p); pos = current.length; // On windows, check that the root exists. On unix there is no need. // 这里是windows系统的逻辑，我们是mac的，所以可以先跳过 if (isWindows && !knownHard[base]) { const ctx = { path: base }; binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx); handleErrorFromBinding(ctx); knownHard[base] = true; } // Walk down the path, swapping out linked path parts for their real // values // NB: p.length changes. // 然后开始循环 由上文得知，我们的pos长度为1，p的长度为传入的path的长度 while (pos 0 这里我们找到的是第一个“/”的位置，如果我们想找第二个“/”位置 // \"/xxx/yyy\".indexOf('/',1) => 4,这里的1指的是跳过第一个元素，从第二个元素开始寻找 const result = nextPart(p, pos); previous = current; if (result === -1) { const last = p.slice(pos); current += last; base = previous + last; pos = p.length; } else { current += p.slice(pos, result + 1); base = previous + p.slice(pos, result); pos = result + 1; } // 判断一下在cahe中是否存在 // Continue if not a symlink, break if a pipe/socket if (knownHard[base] || (cache && cache.get(base) === base)) { // 判断是否为一个file if (isFileType(statValues, S_IFIFO) || isFileType(statValues, S_IFSOCK)) { break; } continue; } let resolvedLink; // 判断是不是软链接，从缓存中去拿 const maybeCachedResolved = cache && cache.get(base); if (maybeCachedResolved) { resolvedLink = maybeCachedResolved; } else { // Use stats array directly to avoid creating an fs.Stats instance just // for our internal use. // 没有拿到，然后做处理 const baseLong = pathModule.toNamespacedPath(base); const ctx = { path: base }; // stats可以打印出 文件在操作系统下的各种信息/ dev_t:文件的设备编号 ino_t:文件在此设备的唯一标识 const stats = binding.lstat(baseLong, false, undefined, ctx); handleErrorFromBinding(ctx); // 判断是否为一个软连接 if (!isFileType(stats, S_IFLNK)) { // 如果不是软连接，将判断过的路径放入到 knowHard当中 knownHard[base] = true; if (cache) cache.set(base, base); continue; } // 判断到该路径是一个软连接，然后继续执行下面的代码 // Read the link if it wasn't read before // dev/ino always return 0 on windows, so skip the check. //linkTarget 软连接实际的路径地址 let linkTarget = null; let id; // 判断是否为window操作系统 if (!isWindows) { // 拿到stat的0号元素，即我们上面注释提到的文件设备编号 const dev = stats[0].toString(32); // 拿到stat的7号元素，即我们上面注释提到的文件唯一标识 //拿到这两个是想生成一个唯一键：这个文件在当下PC系统下的唯一键 const ino = stats[7].toString(32); id = `${dev}:${ino}`; // 通过这两个唯一键生成的唯一键作为 seenLinks的唯一键 // 下面代码为在seenLinks中查找是否有这个id，如果有就直接拿出来 if (seenLinks[id]) { linkTarget = seenLinks[id]; } } // 没有这个软连接的实际路径地址 if (linkTarget === null) { const ctx = { path: base }; binding.stat(baseLong, false, undefined, ctx); handleErrorFromBinding(ctx); // 拿到软连接的实际路径 linkTarget = binding.readlink(baseLong, undefined, undefined, ctx); handleErrorFromBinding(ctx); } resolvedLink = pathModule.resolve(previous, linkTarget); if (cache) cache.set(base, resolvedLink); if (!isWindows) seenLinks[id] = linkTarget; } // Resolve the link, then start over // 将path真实路径重新生成 p = pathModule.resolve(resolvedLink, p.slice(pos)); // Skip over roots current = base = splitRoot(p); pos = current.length; // On windows, check that the root exists. On unix there is no need. if (isWindows && !knownHard[base]) { const ctx = { path: base }; binding.lstat(pathModule.toNamespacedPath(base), false, undefined, ctx); handleErrorFromBinding(ctx); knownHard[base] = true; } } if (cache) cache.set(original, p); return encodeRealpathResult(p, options); } 4-16 讲一个高难度的正则表达式（想挑战的点进来） trailingSlash = /(?:^|\\/).?.$/.test(request); console.log(/(?:^|\\/).?.$/.test('a')) --> false console.log(/(?:^|\\/).?.$/.test('..')) --> true console.log(/(?:^|\\/).?.$/.test('/..')) --> true console.log(/(?:^|\\/).?.$/.test('/Users')) --> false '\\' 转译字符 在正则表达式中 ‘.‘ 是有含义的，表示匹配任意一个字符： const str = 'a'; console.log(a.match(/./)) --> ['a', index:0, input:'a', groups:undefined] 因此在正则表达式中要匹配 . 的话，需要加一个 反斜杠 ‘\\’，因此‘.’ 匹配的就是一个点 console.log(a.match(/./)) --> null '?':表示匹配0个或1个字符 '$':表示最后的匹配样式 ():表示需要返回匹配结果，分组 (?: ) 表示非匹配分组,不把()中分组的内容显示出来 ^:表示非的符号：[!.]表示的是匹配没有. 符号的，需要加[]，但是上文的正则没有[]，上文表示的是匹配一个空格， '|' : 或 ** 4-17 大招：如何快速拿到面试“一血” 简历简介 简历中简介部分至关重要，因为它位于简历的第一屏，是面试官最容易关注的部分，所以我们应该在简介部分充分突出我们的个人特长和优势 认真学完本章内容后应该怎么修改简历？ 熟悉yargs脚手架开发框架 熟悉多Package管理工具lerna的使用方法和使用原理 深入理解Node.js模块路径解析流程 面试官问起细节后如何回答？ 如何通过yargs开发一个脚手架？ 答：比如vue-cli的脚手架为：vue create myProjectName 脚手架的构成一般由三个部分构成： 第一个部分就是： 主命令，也就是bin，它是在packag.json中配置的，通过npm link 进行本地安装 第二个部分 ：command：命令 第三个部分：options 参数 然后需要的一点是主命令bin的配置指向的主文件中，需要在文件顶部加上 #!/usr/bin/env node,就是说在环境变量中找到node命令来执行。 脚手架的初始化流程 第一步：首先是直接调用Yargs的构造函数，直接去生成一个脚手架 第二步：会调用一系列的Yargs提供的常用方法，对脚手架功能进行一个增强。 比如 yargs.usage(用法)、 yargs.options(注册一些脚手架参数熟悉)、 可以调用yargs.group(来对脚手架参数熟悉进行分组)、 yargs.fail(对脚手架异常进行监听)， 还有包括yargs尾部结语的设置yargs.elipogue()、 脚手架窗口设置yargs.wrap() 以及yargs.decomandrecommed(至少输入一个参数) 以及yargs.recommedCommands()推荐命令的提示等 第三步：需要对脚手架的参数进行一些解析：hideBin(process.argv),其实也就是直接取出从第三个开始的参数.调用的时候直接 yargs.argv 还有一种解析方式就是通过yargs.parse(argv,options)的方法 第四步：当脚手架的参数解析完成之后，我们要进行命令注册 命令注册我们使用的是yargs.command()方法。 command的注册方式有两种：第一种是一次传参(command,describe,builder,handler),还有一种方式就是传入一个对象，对象属性与第一种方式传入的相同。 熟悉多Package管理工具lerna的使用方法和使用原理 答：首先lerna是基于一个 git + npm的多package，也就是多包的项目管理工具，像一些开源的大型库：vue-vcli/create-react-app/babel等都是基于lerna进行多包管理的。他的作用就是降低包的管理操作成本，提高开发效率。像包的安装、依赖的添加、依赖的解除以及包的发布、打标签等功能。 实现原理： 首先就是通过 import-local这个库优先调用lerna的本地命令， 然后通过yargs生成一个脚手架、生成脚手架后生成一些全局参数、然后注册命令，通过yargs.parse方法进行参数解析。 需要注意的是lerna的命令注册过程中，需要传入builder以及handler两个方法，builder命令用于注册命令专属的options，而handelr用来处理命令的业务逻辑。 有一点非常值得学习的内容就是lerna它是通过配置本地依赖的方式进行开发的，具体写法就是在package.json的依赖当中通过file的格式书写，在lerna publish的时候再将该路径替换。 对Node.js模块路径解析流程的一个理解 第一：首先Node.js模块的路径解析是通过 require.resolve()方法来实现的 第二：这个resolve方法就是Module._resolveFileName()方法 它的作用就是我们给定一个模块名称的时候，查找处这个模块的真实路径。 然后，他的核心实现流程有三点： 在执行流程中判断当前路径是否为内置模块，若是内置模块直接返回 若不是内置模块，它会继续调用自身的Module._resolveLookupPaths()方法生成node_modules的所有可能路径 最后再通过Module._findPath()去查询模块的真实路径。 这里关于Module._findPaths()方法的核心实现流程有四步 查询缓存(将request[模块名称]和paths[上面返回的所有可生成的node_modules路径]通过\\x00合并成cacheKey) 缓存查不到，就会遍历paths，将每一个path与request结合组成文件路径basePath 然后判断这个basePath路径是否存在，如果存在会调用 fs.realPathSync()方法获取文件的真实路径，不存在就会继续遍历。 同时，将文件的真实路径缓存到Module._pathcache()中。 这里关于fs.realPathsync()方法的核心流程有三点： 仍然是查询缓存，缓存的key就是我们的path，即basePath， 如果这个key没有找到，就会将这个key从左到右开始遍历，通过/进行循环遍历，拆分路径，然后判断这个路径是否为软链接，如果是软链接，就去查询它的真实路径，并生成新的path路径，这个新的path路径继续传入这个遍历函数，继续往后遍历，(这里有一个细节需要注意的是：遍历过程中生成的子路径base会缓存在knowHard和ache中，避免重复查询)。 遍历完成后，就会得到模块的真实路径，并且将原始路径，也就是我们说的软连接路径作为key值，将真实值作为值，保存在缓存中 在require中还有一个方法是 require.resolve.paths()方法，这个方法的作用是用于获取所有node_modules可能存在的路径，他的核心内容就是Module._resolveLookupPaths() Module._resolveLookupPaths()的实现原理有两点 第一点，如果是 /路径，就在后面加入 node_modules 第二点，将路径从后往前遍历，如果查询到 / ，就拆分路径，在后面加上node_modules,一直遍历到查找不到 /路径，就会返回这个paths数组。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/03.脚手架核心流程开发.html":{"url":"pages/六个周/03.脚手架核心流程开发.html","title":"03.脚手架核心流程开发","keywords":"","body":"Week3-脚手架核心流程开发 第一章：本周导学 1-1 本周整体内容介绍和学习方法 标题 脚手架需求分析和架构设计，核心流程开发 收获 架构设计和技术方案设计全过程 脚手架核心流程和commander框架 如何让Node项目支持ES Module 主要内容 脚手架需求分析和架构设计 脚手架模块拆分策略和core模块技术方案 脚手架执行准备过程实现 脚手架命令注册实现(基于commander) 加餐 Node项目如何支持ES Module 第二章：脚手架整体架构设计 2-1 大厂是如何做项目的 2-2 前端研发过程中的痛点和需求分析 2-3 加餐：大厂的git操作规范是怎样的？ clone下来的项目 master分支是不做开发的，我们会新建一个dev分支，上线以后会新建一个release分支。 2-4 高端操作：脚手架架构设计+绘制架构图 / 2-5 架构设计图绘图技巧分享 第三章 脚手架模块拆分策略和core模块技术方案 3-1 脚手架模块拆分策略 核心流程：core 命令： commands 【初始化、发布、清除缓存】 模型层： models 【Command命令 、 Project项目 、 Component组件 、 Npm模块 、 Git仓库】 支撑模块：utils 【Git操作 、 云构建 、 工具方法 、 API请求、 Git API】 3-2 core模块技术方案 准备阶段： 第四章：脚手架执行准备过程实现 4-1 脚手架框架代码拆包+import-local应用 mkdir cloudscope-cli cd cloudscope-cli npm init -y 添加 .gitignore文件 lerna init lerna create cli & lerna create utils mkdir commands & mkdir models & mkdir core & mkdir utils 将packages下core移到外层core、utils移到外层utils,删除packages目录 修改lerna.json文件： { \"packages\": [ \"core/*\", \"commands/*\", \"models/*\", \"utils/*\" ], \"version\": \"1.0.4\" } 在cloudscope-cli/core/cli下新建bin/index.js文件 修改 cloudscope-cli/core/cli下的package.json配置文件，添加如下代码 …… \"bin\": { \"cloudscope-cli\": \"bin/index.js\" }, …… \"dependencies\": { \"@cloudscope-cli/utils\": \"file:../../utils/utils\", \"import-local\": \"^3.0.2\", \"npmlog\": \"^4.1.2\" }, cd core/cli npm install 在cloudscope-cli/core/cli/bin/index.js下添加如下代码： #! /usr/bin/env node const importLocal = require('import-local') if(importLocal(__filename)){ require('npmlog').info('cli','正在使用 cloudscope-cli 本地版本') }else{ require('../lib')(process.argv.slice(2)) } 在cloudscope-cli/core/cli/lib/index.js 文件中添加一行日志文件 npm link cloudscope-cli:即可看到输出日志 git代码提交扩展 我将此代码通过分支的形式，对每一次的代码提交，都在一个特殊的分支进行代码提交。 本节提交到该分支： lesson01 下面是分支提交小记录。 git checkout -b lesson01 git add . && git commit -m 'lesson01 for init ' && git push origin lesson01 git checkout main git merge lesson01 git push 删除本地分支 git branch -D lesson01 如果后面我们想要修改该分支代码并提交到该分支，我们就可以： git checkout -b temp origin/lesson01 4-2 检查版本号功能开发（require加载资源类型讲解+npmlog封装) 从本节开始本地新建分支 lesson02，最后将此分支代码推送至远程仓库cloudscope-cli。 本节代码开发过程中在命令行用到的命令： utils下新建log包： lerna create @cloudscope-cli/log utils log下安装npmlog包： lerna add npmjs utils/log 其它记录的小知识点 require加载资源的类型： .js ： 必须输出一个module.exports || exports. .json : 会通过JSON.parse()对该文件进行解析，并输出一个对象 .node ： c++的一个插件，它的实现原理是通过 process.dlopen去打开一个c++插件，通常不使用。 any ：会通过.js引擎进行解析 npmlog源码： default level: info，可以通过传入的参数进行level定制。 源码中存在的 log.addLevel()才可以打印，我们也可以通过这个方法定制自己的打印设置。（可以设置名字、value值大小，字体色、背景色等） 可以通过 log.heading定制输日志输出的前置。同时可以通过headingStyle做样式修改。 4-3 最低Node版本检查功能开发 检查Node版本号的原因以及解决办法： 这是因为一些低版本的Node API在低版本是不支持的，因此要设置一个最低的Node版本号。 拿到本地版本号的方法为：process.version 版本号比对：第三方库 semver。 抛出异常颜色输出：第三方库 colors:引用'colors/safe',使用：colors.red('') 4-4 root账号启动检查和自动降级功能开发 检查账号权限原因以及解决方法： 如果是使用root权限，一些文件就没有可读或者修改权限，因此需要对用户进行查询与降级处理 通过process.geteuid() 获取登录用户的ID ,501为普通用户，0 为超级管理员(root) 检查第三方库：root-check。使用方法引入一下调用即可降级。 root-check实现原理：调用downgrade-root 库 -> 判断是否为root权限 -> 若是通过process.env.SUDO_UID或者默认 defaultUid() 获取各个操作系统的uid 4-5 用户主目录检查功能开发 user-home:可以实现跨操作系统获取用户主目录的功能。 path-exists:判断文件目录是否存在 user-home实现：调用os-homedir库，再调用os库，若os库有homedir直接返回，若没有直接拿process.env.home(),还是没有就拼接 ‘/Users/'+process.env.USER path-exists实现：直接调用fs的accessSync(path)方法。 4-6 入参检查和debug模式开发 这里就进行如参检查，是要判断是否进入调试模式，如果带有 --debug参数，我们要进行log的level设置。 实现方式：使用minimist第三方库。 查看是否包含debug参数，直接：require('minimist')(process.argv.slice(2)).debug即可。 若上值为true，直接修改log.level即可。 4-7 环境变量检查功能开发 检查环境变量，我们使用第三方库：dotenv。 用法：require('dotenv').config({ path: '' }) ：若不传参数，我们在当前目录下拿到.env文件中的变量，之后就可以直接在process.env中使用了。支持传入path变量。 环境变量其实就是一个全局变量,如果我们有很多的环境变量需要使用，可以直接在.env文件宏进行配置 4-8 通用npm API模块封装 | 4-9 npm全局更新功能开发 准备阶段的最后一个功能：检查我们的这个脚手架是否为最新版本 步骤： 获取当前版本号与模块名: pkg.version | pkg.name 调用npm API获取所有模版号： npm提供了这样一个API: https://registry.npmjs.org/cloudscope-cli/core ,可以获得该包的所有版本号,要从这里拿到所有版本号，我们需要使用第三方库 axios,同时我们也需要添加一个用来url拼接的库：url-join，可以帮助我们进行多参数的拼接，以及我们进行版本对比的第三方库 semver。 获取所有版本号，比对哪些版本号是大于当前版本号 获取最新的版本号，提示用户更新到此版本。 将以上代码提交支仓库远程cloudscope-cli的分支 lesson02，并合并至main分支。** 第五章：脚手架命令注册实现(基于commander） 5-1 快速实现一个commander脚手架 ｜ 5-2 commander脚手架全局配置 之前在学习命令注册的时候，使用的是yrags，本节使用另一个库 commander去实现命令注册 本节代码提交至：liugezhou-yargs-demo 其中 bin/yargs.js是之前学习yargs的demo代码。 bin/commander.js是本节关于commander的代码。 我们在这个库的基础上，学习commander的简单用法. 首先，安装npm i -S commander 然后，在bin/index.js中： #!/usr/bin/env node const commander = require('commander') const pkg = require(\"../package.json\") // 获取commander的单例 // const {program} = commander // 手动实例化一个Command示例 const program = new commander.Command() program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false) .option('-e, --envName ' , '环境变量') .parse(process.argv); const options = program.opts() console.log(options.debug) program.outputHelp() //打印出帮助信息 liugezhou-test -V,即可看到输入版本号。 liugezhou-test -d // true 5-3 commander脚手架命令注册的两种方法 课程所讲内容：commander命令注册有两种方式： comman API注册命令 addCommand API 注册命令 现在默认安装commander时，已更新到7.0.0，sam老师写法还是6.X，可参考 commader for git 配置。本节内容就是对官方文档更新用法之后的学习笔记： Commander.js : 完整的node.js命令行解决方法 声明commander变量 为简化声明，Commander提供了一个全局对象 const { program } = require('commander') program.version('0.0.1') 若程序较为复杂，用户需要以多种方式来使用Commander，如单元测试等，可采用创建本地Commander对象的方法 const {Command } = require('commander') const program = new Command(); program.version('0.0.1') 3.选项 program //Commander 使用.option() 方法来定义选项，同时可以附加选项的简介 .option('-d,--debug','booelan') //选项可以设置一个默认值。 .option('-c, --cheese ', 'add the specified type of cheese', 'blue'); //必填选项 .requiredOption('-n, --name ', 'name must have cheese'); //通过program.parse(arguments)方法处理参数 program.parse(process.argv) const ret = program.opts() const debug = ret.debug 4.命令 program. //参数支持必须<>,可选[] command('clone [destination]') //在参数名后加上...来声明可变参数，且只有最后一个参数支持这种用法 program .command('rmdir ') .action(function (dirs) { dirs.forEach((dir) => { console.log('rmdir %s', dir); }); }); 5-4 commander注册命令的两种高级用法 ｜5-5 再讲3条commander的高级用法 监听所有命令输入 : arguments 脚手架串行使用 program .command('install [name]','install package',{ executableFile:'vue'， isDefault:true, hidden:true //command的隐藏 }) .alias('i') 高级定制help信息` program.outputHelp() program.helpInformation() = function(){}_ program.on('--help'),function(){ console.log('your help information'}_ 高级定制debug模式program.on('optins:debug',function(){ if(program.debug){ process.env.LOG_LEVEL = 'verbose' } } 对未知命令监听二：program.on('command:*',function(obj){ console.log(obj) console.log('未知的命令：' + obj[0]) const avaliableCommands = program.commands.map( cmd => cmd.name()) console.log('可用命令：'+ avaliableCommands.join(',')) }) 第6章 Node项目如何支持ES Module【加餐】 6-1 通过webpack完成ES Module资源构建 模块化 CMD/AMD/require.js CommonJS: 加载：require(), 输出：module.exports() || exports.x ES Module: 加载： import, 输出 export.default || export function || export const 实现 npm i -D webpack webpack-cli touch webpack-config.js //webpack-config.js const path = require('path') module.exports = { entry: './bin/core.js', output:{ path:path.join(__dirname,'/dist'), filename:'core.js' }, mode:'development' } // index.js #! /usr/bin/env node require('./core') // core.js import utils from './utils' utils() // utils module.exports = function(){ console.log('kskaksk') } 在package.json中添加两个script，分别为 \"build\":\"webpack\"和\"dev\":\"webpack -w\" 上面代码通过 npm run build 打包后，将上面index.js中的require修改为 require(\"../dist/core.js\") 执行 liugezhou-test 看到构建成功。 6-2 通过webpack target属性支持Node内置库 webpack的target使用 // npm i -S path-exists // bin/utils.js import pathExists from 'path-exists' export function exists(p){ return pathExists.sync(p) } // bin/core.js import path from 'path' import {exists} from './utils' console.log(path.resolve('.')) console.log(exists(path.resolve('.'))) // webpack.config.js ... target:\"node\" core.js代码添加 (async function(){ await new Promise(resolve => setTimeout( resolve,1000)); console.log('ok') })() 6-3 webpack loader配置babel-loader支持低版本node 配置一个最简单babel-loader,需要安装的库 npm i -D babel-loader @babel/core @babel/preset-env @babel/plugin-transform-runtime @babel/runtime-corejs3 const path = require('path') module.exports = { entry:'./bin/core.js', output:{ path: path.join(__dirname,'/dist'), filename:'core.js' }, mode:'development', //开发模式 // target: 'web'//默认 target:'node', // 识别内置库 module:{ rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets:['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs:3, regenerator:true, useESModules:true, helpers: true } ] ] } } } ] } } 6-4 通过Node原生支持ES Module 将node版本升级到14.x，代码中将引用的文件，改写后缀名为 .mjs即可。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/04.脚手架命令注册和执行过程开发.html":{"url":"pages/六个周/04.脚手架命令注册和执行过程开发.html","title":"04.脚手架命令注册和执行过程开发","keywords":"","body":"Week4-脚手架命令注册和执行过程开发 本Week代码提交支：lesson04 第一章：本周导学 1-1 本周整体内容介绍和学习方法 标题 基于Commander完成脚手架命令注册和命令执行过程开发 收获 如何设计高性能脚手架 Node多线程开发 javascript面向对象编程的实战技巧 内容 图解高性能脚手架架构设计方法 封装通用的Package和Command类 基于缓存 + Node 多进程 实现动态命令加载和执行 将业务逻辑和脚手架逻辑彻底解耦 加餐 Node多进程开发进阶--child_process源码解析 深入Node源码看清spawn/exec/execFile/fork的本质区别，彻底搞懂Node多进程原理。 第二章：imooc-cli脚手架命令注册 2-1 imooc-cli脚手架初始化+全局参数注册 (本节有代码编写) 本节的主要内容为使用commander这个库在全局添加注册命令 cd core/cli npm i -S commander // core/cli/lib/index 添加全局注册命令方法 //命令注册 function registerCommand(){ program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false); // 开启debug模式 program.on('option:debug',function(){ if(program.opts().debug){ process.env.LOG_LEVEL='verbose' }else{ process.env.LOG_LEVEL='info' } log.level = process.env.LOG_LEVEL }) // 对未知命令监听 program.on('command:*',function(obj){ const availableCommands = program.commands.map(cmd => cmd.name()) console.log(colors.red('未知的命令：'+obj[0])) if(availableCommands.length > 0){ console.log(colors.red('可用命令为：'+availableCommands.join(','))) } }) program.parse(program.argv) if(program.args && program.args.length 2-2 imooc-cli脚手架命令注册 (本节有代码编写) 本节的主要内容为添加第一个comman操作：'init',并在commands文件夹下创建新的init包 // core/cli/lib/index ...... const init = require('@cloudscope-cli/init') ...... program .command('init [projectName]') .option('-f,--force','是否强制更新项目') .action(init) ...... 第三章：高性能脚手架架构设计和缓存结构设计 3-1 当前imooc-cli脚手架架构痛点分析 **(本节无代码编写) 当前的代码架构如图： 3-2 高性能脚手架架构设计 (本节无代码编写) 对以上架构(之前代码编写)的主要优化点有以下三个方面 将init命令做成了一个动态加载的形式 动态加载的脚手架通过缓存形式进行存储：执行哪个命令下载哪个命令 动态加载的时候，通过node多进程进行执行：深挖cpu性能 3-3 脚手架命令动态加载功能架构设计 (本节无代码编写) 上图架构初看有些难度，在代码编写之后再去回顾，会有更深理解。 本节简单讲述了两点： require加载文件的用法: require('/xxx/yyy/index.js') ---- 加载绝对路径 require('./index.js')----加载相对路径 require('fs') ---- 加载内置模块 require('npmlog') ---- 加载第三方包 node执行模块两种方式 node 执行文件: node core/cli/bin/index.js node -e '字符串'：node -e \"require(./core/cli/bin/index.js)\" 第4章 通用 npm 模块类 Package 封装 4-1 脚手架命令本地调试功能支持 (本节有代码编写) 通过前面画图了解，我们要实现的第一步是initCommand的动态命令加载,即3-3章节所示图。 是否执行本地代码，我们通过一个属性来进行标识：targetPath //core/cli/lib/index.js program. .option('-tp, --targetPath ','是否指定本地调试文件路径','') //指定targetPath program.on('option:targetPath',function(){ process.env.CLI_TARGET_PATH = program.opts().targetPath }) // commands/init/lib/index.js 'use strict'; function init(projectName,options,command) { console.log('init',projectName,command.opts().force,process.env.CLI_TARGET_PATH) } module.exports = init; 本节需要注意的一点是如果commander版本低于7.0.0，那么 program.action()中传入的参数为两个。 7.0.0版本以上的传入的参数为三个(name.options,cmd) 另外，访问targetPath这个参数的时候，需要program.opts().targetPath访问。 4-2 动态执行库exec模块创建 (本节有代码编写) core下新建包文件： lerna create @cloudscope-cli/exec core/ 然后在core/cli/lib/index.js文件中将exec包引入，将action(init)此处改为action(exec) 4-3 创建npm模块通用类Package (本节有代码编写) 首先讲解了exec模块逻辑 targetPath -> modulePath modulePath -> Package(npm模块) Package.getRootFile(获取入口文件) Package.update / Package.install 代码实现： 在model文件下创建新的模块Package：lerna create @cloudscope-cli/package 在core/exec/lib/index.js文件中引入：const Package = require('@cloudscope-cli/package') 4-4 Package类的属性、方法定义及构造函数逻辑开发 (本节有代码编写) 本节主要有三处代码讲解 core/exec中创建一个Package对象 model/package中Package类的构造方法 utils/utils中添加isObject方法：判断一个属性是否为对象 代码分别如下： // core/exec/lib/index.js 'use strict'; const Package = require('@cloudscope-cli/package') const log = require('@cloudscope-cli/log') const SETTINGS = { init: '@cloudscope-cli/init' } function exec() { // 1. targetPath -> modulePath // 2. modulePath -> Package(npm模块) // 3. Package.getRootFile(获取入口文件) // 4. Package.update / Package.install' let targetPath = process.env.CLI_TARGET_PATH const homePath = process.env.CLI_HOME_PATH let storeDir =''; let pkg; log.verbose('targetPath', targetPath); log.verbose('homePath', homePath); const cmdObj = arguments[arguments.length - 1]; const cmdName = cmdObj.name(); const packageName = SETTINGS[cmdName]; const packageVersion = 'latest'; pkg = new Package({ targetPath, storeDir, packageName, packageVersion }) console.log(pkg) } module.exports = exec; //models/package/lib/index.js 'use strict'; const { isObject } = require('@liugezhou-cli-dev/utils'); class Package { constructor(options){ if( !options){ throw new Error('Package类的options参数不能为空！') } if( !isObject(options) ){ throw new Error('Package类的options参数必须为对象！') } // package路径 this.targetPath = options.targetPath // package的存储路径 this.storeDir = options.storeDir // package的name this.packageName = options.packageName // package的version this.packageVersion = options.packageVersion; } // 判断当前Package是否存在 exists(){} // 安装Package install(){} //更新Package update(){} //获取入口文件路径 getRootFilePath(){} } module.exports = Package; //utils/utils/lib/index.js 'use strict' function isObject(obj){ return Object.prototype.toString.call(obj).slice(8,-1) === 'Object' } module.exports = { isObject } 4-5 Package类获取入口文件路径功能开发（pkg-dir应用+解决不同操作系统路径兼容问题） (本节有代码编写)本节主要实现models/package/lib/index.js中获取入口文件路径的方法实现getRootfile() 思路： 获取package.json的所在目录--通过安装pkg-dir库 读取package.json 寻找main/lib 路径的兼容macOS/windows --新建包：utils/format-path，且新建路径兼容方法 核心代码为: //core/exec/lib/index.js ………… // 1. 获取package.json所在目录 const dir = pkgDir(targetPath); if (dir) { // 2. 读取package.json const pkgFile = require(path.resolve(dir, 'package.json')); // 3. 寻找main/lib if (pkgFile && pkgFile.main) { // 4. 路径的兼容(macOS/windows) return formatPath(path.resolve(dir, pkgFile.main)); } } return null; ………… 'use strict'; const path = require('path') function formatPath(p) { const sep = path.sep; if(p && typeof p === 'string'){ if(sep !=='/'){ return p.replace(/\\\\/g,'/') } } return p } module.exports = formatPath; 4-6 利用npminstall库安装npm模块 (本节有代码编写) 本节实现的内容为exec中的install方法,通过npminstall这个库。 使用之前现在测试项目下使用之：测试代码。 const npminstall = require('npminstall') const path = require('path') const userHome = require('user-home') npminstall({ root: path.resolve(userHome,'.cli-test'), //模块路径 storeDir: path.resolve(userHome,'.cli-test','node_modules') , registry:'https://registry.npmjs.org', pkgs:[ {name:'foo',version:'~1.0.0'} ] }) 首先，我们的项目在开发过程中可能会有错误，有的需要去看执行栈，有的不需要，因此我们在core/cli/lib/index中的core方法中，catch语句中加入如下代码(debug模式下显示执行栈错误) if(program.opts().debug){ console.log(e) } 2.在core/exec/lib/index.js文件中，我们修改代码如下(主要加入了如果不存在targetPath的逻辑梳理)： 'use strict'; const path = require('path') //新添加 const Package = require('@cloudscope-cli/package') const log = require('@cloudscope-cli/log') const SETTINGS = { //新添加 init: '@imooc-cli/init' } const CATCH_DIR = 'dependencies' //新添加 async function exec() { let targetPath = process.env.CLI_TARGET_PATH const homePath = process.env.CLI_HOME_PATH let storeDir =''; let pkg; log.verbose('targetPath', targetPath); log.verbose('homePath', homePath); const cmdObj = arguments[arguments.length - 1]; const cmdName = cmdObj.name(); const packageName = SETTINGS[cmdName]; const packageVersion = 'latest'; if(!targetPath){ //生成缓存路径 targetPath = path.resolve(homePath,CATCH_DIR); //新添加 storeDir = path.resolve(targetPath,'node_modules') //新添加 log.verbose('targetPath:',targetPath) //新添加 log.verbose('storeDir:',storeDir) //新添加 pkg = new Package({ //新添加 targetPath, storeDir, packageName, packageVersion }); if(await pkg.exists()){ //新添加 // 更新package log.verbose('更新package') await pkg.update(); }else{ // 安装package await pkg.install(); } }else{ pkg = new Package({ targetPath, packageName, packageVersion }) const rootFile = pkg.getRootFilePath(); if(rootFile){ //新添加 require(rootFile).apply(null,arguments); } } } module.exports = exec; model/package包中文件主要加入了安装package这个方法,使用了npminstall这个库。 //models/package/lib/ibdex.js async install(){ await this.prepare() return npminstall({ root: this.targetPath, storeDir: this.storeDir, registry:getDefaultRegistry(), pkg:{ name:this.packageName, version:this.packageVersion } }) } 4-7 Package类判断模块是否存在方法开发 本节的主要内容是实现package/lib/index.js中的exists方法，代码实现如下： ………… // package的缓存目录前缀 this.cacheFilePathPrefix = this.packageName.replace('/', '_') ………… get cacheFilePath() { return path.resolve(this.storeDir,`_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}`) } async prepare(){ if(this.storeDir && !pathExists(this.storeDir)){ fse.mkdirpSync(this.storeDir) } if(this.packageVersion === 'latest'){ this.packageVersion = await getNpmLatestVersion(this.packageName); } } async exists(){ if(this.storeDir){ await this.prepare() return pathExists(this.cacheFilePath); }else{ return pathExists(this.targetPath); } } 4-8 Package类更新模块逻辑开发 (本节有代码编写) 本节内容主要为如果Package包有升级，那么需要去更新，主要实现代码为： // models/package/lib/index.js ………… getSpecificCacheFilePath(packageVersion){ return path.resolve(this.storeDir,`_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}`) } //更新Package async update(){ //获取最新的npm模块版本号 const latestPackageVersion = await getNpmLatestVersion(this.packageName); // 查询最新版本号对应的路径是否存在 const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion) // 如果不存在，则直接安装最新版本 if(!pathExists(latestFilePath)){ await npminstall({ root:this.targetPath, storeDir:this.storeDir, registry:getDefaultRegistry(), pkgs:[{ name:this.packageName, version:latestPackageVersion } ] }) this.packageVersion = latestPackageVersion }else{ this.packageVersion = latestPackageVersion } return latestFilePath; } 4-9 Package类获取缓存模块入口文件功能改造 //获取入口文件路径 getRootFilePath(){ function _getRootFile(targetPath) { // 1. 获取package.json所在目录 const dir = pkgDir(targetPath); if (dir) { // 2. 读取package.json const pkgFile = require(path.resolve(dir, 'package.json')); // 3. 寻找main/lib if (pkgFile && pkgFile.main) { // 4. 路径的兼容(macOS/windows) return formatPath(path.resolve(dir, pkgFile.main)); } } return null; } if (this.storeDir) { return _getRootFile(this.cacheFilePath); } else { return _getRootFile(this.targetPath); } } ps：关于项目的代码以上就结束了，代码提交至：lesson04 第五章：预备知识：Node 多进程开发入门 5-1 进程的基本概念(讲解在操作系统中如何查看进程的嵌套关系) 官方文档中文版： http://nodejs.cn/api/child_process.html 进程：进程(Process)是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单元，是操作系统结构的基础。 概念主要两点： 第一，进程是一个实体。每一个进程都有它自己的地址空间。 第二，进程是一个“执行中的程序”，存在嵌套关系 Node进程存在的感知： 终端中输入：ps -ef | grep node 命令。 UID是当前用户获取权限的ID PID是当前进程ID PPID是当前进程ID的父ID 使用webstorm调试一个node程序的图示如下： 5-2 child_process异步方法使用教程（exec&execFile） child_process用法: 异步用法 exec execFile fork spawn 同步用法 execSync execFileSync spawnSync //exec使用方法demo const cp = require('child_process') cp.exec('ls -al',function(err,stdout,stderr){ console.log(err) console.log(stdout) console.log(stderr) }) //execFile使用方法demo cp.execFile('ls',['-al'],function(err,stdout,stderr){ console.log(err) console.log(stdout) console.log(stderr) }) 小结：exec和execFile在输出上看不出来区别。 exec主要用来执行一个shell命令，本质是execFile，只是参数不同，不支持传入arguments参数。 execFile只能执行一个文件，且加入一些命令，不能使用管道符。 5-3 child_process spawn用法以及与exec&execFile的区别 exec、execFile、fork底层都是使用的spawn。 spawn使用的时候，没有回调，需要监听获取结果。新建一个test.shell文件的时候，如果要读取这个文件，那么需要添加权限：chmod +x test.shell const cp = require('child_process') const path = require('path') const child = cp.spawn(path.resolve(__dirname,'test.shell'),['-al','-bl'],{ cwd:path.resolve('..') }); // console.log(child.pid,process.pid) child.stdout.on('data',function(chunk){ console.log('stdout',chunk.toString()) }) child.stderr.on('data',function(chunk){ console.log('stderr',chunk.toString()) }) spawn:耗时任务(比如 npm install)： 不断打印日志 exec/execFile:耗时、开销比较小的任务: 一次性返回结果。 fork：多进程、多线程的下载。 5-4 child_process fork用法及父子进程通信机制讲解 fork主要是使用node来执行我们的命令。 fork会执行两个进程 主进程与子进程。 fork的本质也是调用spawn。 // index.js const cp = require('child_process') const path = require('path') const child = cp.fork(path.resolve(__dirname,'child.js')) child.send('hello child process！',()=>{ // child.disconnect() }) console.log('main pid:',process.pid) child.on('message',msg =>{ console.log(msg) child.disconnect() }) //child.js console.log('child pid：',process.pid) process.on('message', (msg)=>{ console.log(msg) }) process.send('hello main process!') 5-5 child_process同步方法使用教程 execSync execFileSync spawnSync const cp = require('child_process') //execSync const ret = cp.execSync('ls -al | grep index.js') console.log(ret.toString()) //execFileSync const ret2 = cp.execFileSync('ls', ['-al']) console.log(ret2.toString()) //spawnSync const ret3 = cp.spawnSync('ls',['-al']) console.log(ret3.stdout.toString()) 第六章 基于 Node 多进程构建高性能脚手架 6-1 通过脚手架命令Command类封装 (本节有代码编写) 在 model文件夹下安装Command包：lerna create @cloudscope-cli/command 在commands/init 的package.json中引入上面新创建的包command，继承它作为它的子类。 然后我们来到新建的command包的lib/index文件中,添加如下代码(同时删除core/cli/lib/index.js中关于checNodeVersion方法的代码)： 'use strict'; const semver = require('semver') const colors = require('colors/safe') const LOWEST_NODE_VERSION = '12.0.0' class Command { constructor(argv){ this._argv = argv let runner = new Promise((resolve,reject)=>{ let chain = Promise.resolve() chain = chain.then(()=> this.checkNodeVersion()) chain.catch(e =>{ console.log(e.message) }) }) } checkNodeVersion(){ const currentNodeVersion = process.version const lowestNodeVersion = LOWEST_NODE_VERSION if(semver.ltr(currentNodeVersion, lowestNodeVersion)) { throw new Error(colors.red(`cloudscope-cli 需要安装 v${lowestNodeVersion}以上版本的node.js`)) } } init(){ throw Error('init必须实现') } exec(){ throw Error('exec必须实现') } } module.exports = Command; 接着，我们来到commands/init/lib/index.js文件中，进行代码的改写： 'use strict'; const Command = require('@cloudscope-cli/command') class InitCommand extends Command { } // function init(projectName,options,command) { // console.log('init',projectName,command.opts().force,process.env.CLI_TARGET_PATH) // } function init(argv) { return new InitCommand(argv) } module.exports = init module.exports.InitCommand = InitCommand; 这里的argv参数传递是从 exec/lib/index.js中的require传递过来的，因此参数传递修改 require(rootFile).apply(null,arguments); //修改为 require(rootFile).call(null,Array.from(arguments)); 6-2 脚手架参数初始化方法开发 (本节有代码编写) 首先在command包中引入log包，用于chain的catch错误打印(上节代码已更新) 其次，对于class Comman需要对传入的参数argv进行一个判断， 如果为空需要抛出异常，这里需要注意抛出的异常在core/cli/lib/index.js中并没有捕获，需要在core/exec/lib/index.js中require的这个targetPath文件进行try catch捕获。 对argv这个参数进行是否对数组的判断。 对argv是否为空数组进行判断 if(!argv){ throw new Error('argv参数不能为空') } if(!Array.isArray(argv)){ throw new Error('argv参数必须为数组') } if(argv.length 在chain里面实现initArgs方法：主要用来进行参数的分解，将argv最后一个参数与之前的参数装到两个参数中去。 //chain逻辑 let chain = Promise.resolve() chain = chain.then(()=> this.checkNodeVersion()) chain = chain.then(()=> this.initArgs()) chain = chain.then(()=> this.init()) chain = chain.then(()=> this.exec()) chain.catch(e =>{ log.error(e.message) }) initArgs(){ const len = this._argv.length - 1 this._cmd = this._argv[len].opts() //commander版本号为7.0.0需要加opts() this._argv = this._argv.slice(0,len) } chain中的init方法与exec均抛出异常，需要由子类去实现：即commands/init/lib/index.js. 6-3 利用Node多进程动态执行命令（stdio的inherit属性讲解） 我们回到exec/lib/index.js中，其中之前的那行代码 require(rootFile).call(null,Array.from(arguments)); 是在当前进程中调用的，我们需要修改为在node进程中进行调用，这便是本节的重点。 我们通过本周第五章的内容，已经知道了如何使用child_process下的同步或者异步方法进行子进程的执行，这里我有两种方法可以使用 const cp = require('child_process') // cp.fork() //这里因为fork没有回调，需要通过通信的方式来获取结果，所以这里不推荐 //之所以不用spawnSync是因为，我们在执行这里的时候是需要不断的用户交互的，需要不断的收到数据打印结果，不要一次性 const child = cp.spawn('node',['-e',code],{ cwd:process.cwd(), stdio:'inherit' // 加入这行代码，下面的就可以注释掉了 }) // child.stdout.on('data',(chunk =>{ // })) // child.stderr.on('data',(chunk =>{ // })) // 当然存在错误的情况，我们还是需要添加两个监听事件 child.on('error', e =>{ log.error(e.message); process.exit(1); }) child.on('exit', e=>{ log.verbose('命令执行成功' + e); process.exit(e); }) spawn方法中的参数stdio默认值为'pipe'管道，pipe使得主进程与子进程会产生通信通道，因此需要通过on这种方式去进行监听。 stdio还有一个值为'inherit'，它将相应的stdio传给父进程或者从父进程传入。也就是说：直接将process.stdin、process.stdout、process.stderr直接和父进程进行绑定，这样就无须去监听结果，可以直接将结果打印出来。 6-4 生成Node多进程动态执行代码 通过上一节的学习，我们通过代码const args = Array.from(arguments) const cmd = args[args.length - 1]可以知道，现在需要做的就是拼成上面spawn在执行时所需的code 我们之前的代码为 _require(rootFile).call(null,Array.from(arguments));也就是兼容 conse code = require(rootFile).call(null,Array.from(arguments));rootfile -> ${rootfile},难点是 Array.from(arguments)的传入。 const args = Array.from(arguments) const cmd = args[args.length - 1] // 拿到command，且进行瘦身，对不需要的参数进行过滤 const o = Object.create(null) Object.keys(cmd).forEach(key=>{ if(cmd.hasOwnProperty(key) && !key.startsWith('_')&& key!=='parent'){ o[key]=cmd[key] } }) args[args.length-1] = o const code = `require('${rootFile}').call(null,${JSON.stringify(args)})` 注：由于我使用的commander是7.0.0的，低于此版本传入的参数为两个，但7.0.0版本传入参数为3个，因此上面的代码，我这里直接写成(不知道后续是否还会有错误)： let args = Array.from(arguments).splice(0,2) const code = `require('${rootFile}').call(null,${JSON.stringify(args)})` 到这里，使用node多进程执行代码的功能就完成了。 6-5 windows操作系统spawn执行命令兼容 windows操作系统与macOS关于spawn的执行是不一样的，本节解决的就是windows操作系统下的兼容 将本方法封装在utils/utils包中：通过process.platform来判断操作系统 function exec(command,args,options){ const win32 = process.platform === 'win32'; const cmd = win32 ? 'cmd': command const cmdArgs = win32 ? ['/c'].concat(command,args) : args; return require('child_process').spawn(cmd, cmdArgs,options || {}) } 到以上为止，我们完成了动态命令的加载和执行。 第七章 加餐：Node 进阶： child_process 源码分析 7-1 Node多进程child_process库exec方法源码执行流程分析 疑问和收获： exec和execFile到底有什么区别？ 为什么exec/execFile/fork都是通过spawn实现的，spawn的作用到底是什么？ 为什么spawn调用后没有回调，而exec和execFile能够回调？ 为什么spawn调用后需要手动调用child.stdout.on('data',callback),这里的child.stdout/child.stderr到底是什么？ 为什么有data/error/exit/close这么多种回调，他们的执行顺序到底是怎样的？ exec源码粗略分析 在未学习exec源码之前，我们先对上面的拓扑图进行一个简单的学习，看到exec内部的执行流程 不难看到exec执行的是execlFile这个方法，且不同的地方就是传入的参数不同，而execFile执行的是spawn这个方法，且spawn这个方法调用的是node内部库的一个child_process方法。 我们在webstorm中打开一个项目 // /bin/process/index.js const cp = require('child_process') const path = require('path') cp.exec('ls -al|grep node_modules ',function(err,stdout,stderr){ console.log(err) console.log(stdout) console.log(stderr) }) 第五行代码打断点，配置webstorm调试设置后，执行命令(我这里是liugezhou-test)，进入到exec源码 function exec(command, options, callback) { const opts = normalizeExecArgs(command, options, callback); return module.exports.execFile(opts.file, opts.options, opts.callback); } 正如上面拓扑图画的那样，首先执行一个normalLizeExecArgs方法，然后调用execFile这个方法 function execFile(file /* , args, options, callback */) { ……………… const child = spawn(file, args, { cwd: options.cwd, env: options.env, gid: options.gid, uid: options.uid, shell: options.shell, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!options.windowsVerbatimArguments }); ……………… function exithandler(code, signal) { ……………… callback(ex, stdout, stderr); } function errorhandler(e) { ……………… exithandler(); } if (child.stdout) { ……………… } if (child.stderr) { ……………… } child.addListener('close', exithandler); child.addListener('error', errorhandler); return child; } 上面代码的4行，我们看到调用了spawn方法。 function spawn(file, args, options) { const opts = normalizeSpawnArguments(file, args, options); const child = new ChildProcess(); …………………… child.spawn({ file: opts.file, args: opts.args, cwd: options.cwd, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!options.windowsVerbatimArguments, detached: !!options.detached, envPairs: opts.envPairs, stdio: options.stdio, uid: options.uid, gid: options.gid, serialization: options.serialization, }); return child; } spawn方法的第2行如拓扑图所示，对参数执行了normalizeSpawnArguments方法，这里通过调试查看参数，发现，opts这个对象的file为 'bin/sh'，这里涉及到一个重要的知识点: shell的使用 直接执行shell文件： /bin/sh test.shell 直接执行shell语句： /bin/sh -c \"ls -al|grep node_modules\" spawn方法的第3行 const child = new ChildProcess 通过分析，我们知道这个ChildProcess调用的是内部库 internal/child_process的this._handler,再进一步如拓扑图所示，调用的是c++文件，不做继续跟踪。 继续往后该方法第6行，spwan方法调用的child.spwan如拓扑图所示，真正调用的是internal/child_process中的spawn-->this._hanlde.spawn方法，该方法执行完毕后，子进程便开启了. 在spwan最后返回child后，我们再返回到execFile中，发现child.stdout与child.stderr方法的输出，以及回调f unction exithandler和errorhandler 上面就是对exec源码的略读过程。 7-2 高能：child_process库exec源码精度 上一节我们阅读了exec源码的第一遍，对答题流程有了认识，这节开始阅读第二遍，进行细节的解读。 首先进入到exec的normalizeExecArgs方法，逻辑简单。 function normalizeExecArgs(command, options, callback) { if (typeof options === 'function') { //判断options是否为function，这一步是对参数的兼容以及参数左移动 callback = options; options = undefined; } // Make a shallow copy so we don't clobber the user's options object. options = { ...options }; options.shell = typeof options.shell === 'string' ? options.shell : true; return { file: command, options: options, callback: callback }; } 然后我们进入到execFile中，分析流程写入到下面代码之中： // liugehou:此方法只接受了一个参数file，后面的参数通过arguments获取 function execFile(file /* , args, options, callback */) { // liugezhou:参数初始化 let args = []; let callback; let options; // Parse the optional positional parameters. let pos = 1; //liugezhou:意图为拿到arguments的第一个参数，即options，且需满足options为数组时(显然exec进来不满足这个条件) if (pos 上面代码走到51行后，进入spawn源码 function spawn(file, args, options) { // liugezhou：继续对进来的参数进行一个解析，主要就是参数的处理解析 const opts = normalizeSpawnArguments(file, args, options); //liugezhou：这里进入到internal/child_process文件下，重点执行this.handle = new Process() const child = new ChildProcess(); options = opts.options; debug('spawn', opts.args, options); //liugezhou：又一个重点，这里的源码底层实现，分析在下一节 child.spawn({ file: opts.file, args: opts.args, cwd: options.cwd, windowsHide: !!options.windowsHide, windowsVerbatimArguments: !!options.windowsVerbatimArguments, detached: !!options.detached, envPairs: opts.envPairs, stdio: options.stdio, uid: options.uid, gid: options.gid, serialization: options.serialization, }); return child; } 7-3 深度分析child_process库spawn底层实现 接着上一节代码块中走到了child.spawn： 第一步是通过getValidStdio去生成pipe，创建一个管道实例：第一个是输入，第二个是输出，第三个是error(只是生成了管道，但是还没创建socket的通信) 第二步对spawn的一些参数进行处理：下面代码未贴 第三步通过this._handle.spawn 子进程被创建出来 第四步通过createSocket方法，将之前的pipe和子进程与socket绑定。 ChildProcess.prototype.spawn = function(options) { ……………… //liugezhou:'pipe'管道从这里创建，这里面的代码就不贴了，该代码可以： //1. stdio可以传入ignore，静默执行，没有输出 stdio = getValidStdio(stdio, false); ……………… //liugezhou:经过这步后，子进程立即被创建出来 const err = this._handle.spawn(options); …………… // liugezhou:此循环非常重要，建立起来了父进程与子进程的socket通信 for (i = 0; i 0); //liugezhou:到这里就得到了一个socket事例 if (i > 0 && this.pid !== 0) { this._closesNeeded++; stream.socket.on('close', () => { maybeClose(this); }); } } } ……………… return err; }; 然后我们再返回到execFile中，接着往下走： function execFile(file /* , args, options, callback */) { ……………… let encoding; //liugezhou：等待输入输出流全部执行完毕后，最后生成内容的数组，这个_stdout是一次性push给我们的，所以这也是我们前面学习说为什么进行耗时任务的时候，不要使用execFile const _stdout = []; const _stderr = []; if (options.encoding !== 'buffer' && Buffer.isEncoding(options.encoding)) { encoding = options.encoding; } else { encoding = null; } //定义了一些变量 ……………… function exithandler(code, signal) { if (exited) return; exited = true; if (timeoutId) { clearTimeout(timeoutId); timeoutId = null; } if (!callback) return; // merge chunks let stdout; let stderr; if (encoding || ( child.stdout && child.stdout.readableEncoding )) { stdout = _stdout.join(''); } else { stdout = Buffer.concat(_stdout); } if (encoding || ( child.stderr && child.stderr.readableEncoding )) { stderr = _stderr.join(''); } else { stderr = Buffer.concat(_stderr); } if (!ex && code === 0 && signal === null) { callback(null, stdout, stderr); return; } if (args.length !== 0) cmd += ` ${args.join(' ')}`; if (!ex) { // eslint-disable-next-line no-restricted-syntax ex = new Error('Command failed: ' + cmd + '\\n' + stderr); ex.killed = child.killed || killed; ex.code = code 0) { ……………… } if (child.stdout) { if (encoding) child.stdout.setEncoding(encoding); child.stdout.on('data', function onChildStdout(chunk) { const encoding = child.stdout.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; stdoutLen += length; if (stdoutLen > options.maxBuffer) { const truncatedLen = options.maxBuffer - (stdoutLen - length); _stdout.push(chunk.slice(0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stdout'); kill(); } else { _stdout.push(chunk); } }); } if (child.stderr) { if (encoding) child.stderr.setEncoding(encoding); child.stderr.on('data', function onChildStderr(chunk) { const encoding = child.stderr.readableEncoding; const length = encoding ? Buffer.byteLength(chunk, encoding) : chunk.length; stderrLen += length; if (stderrLen > options.maxBuffer) { const truncatedLen = options.maxBuffer - (stderrLen - length); _stderr.push(chunk.slice(0, truncatedLen)); ex = new ERR_CHILD_PROCESS_STDIO_MAXBUFFER('stderr'); kill(); } else { _stderr.push(chunk); } }); } child.addListener('close', exithandler); child.addListener('error', errorhandler); return child; } 7-4 child_process事件应用方法详解 ** 本节我们进入到child_process源码的第三轮，彻底搞懂process的回调流程，也是child_process中最复杂的部分。同样，我们通过processOn图对流程进行梳理一遍： 在分析了上面流程后，我们先写一些测试代码以理解上面的流程。 const cp = require('child_process') const path = require('path') const child = cp.exec('ls -al|grep node_modules',function(err,stdout,stderr){ console.log('callback--------start') console.log(stdout) console.log('callback--------end') }) child.stdout.on('data',(chunk)=>{ console.log('stdout data:',chunk) }) child.stderr.on('data',(chunk)=>{ console.log('stderr data:',chunk) }) child.stderr.on('close',()=>{ console.log('stderr close') }) child.on('exit',(exitCode)=>{ console.log('exit:',exitCode) }) child.on('close',()=>{ console.log('close!') }) 7-5 高难度：深度解析child_process库spawn方法回调原理 这一章完全听的懵逼了。略过。。。。。。。 7-6 child_process库fork执行流程分析 略。。。。。。。 7-7 精化：Node多进程源码总结 exec/execFile/spawn/fork的区别 exec: 原理是调用/bin/sh -c 执行我们传入的shell脚本，底层调用略execFile execFile：原理是直接执行我们传入的file和args，底层调用spawn创建和执行子进程，并建立略回调，一次性将所有的stdout和stderr结果返回 spawn:原理是调用略internal/child_process,实例化略ChildProcess子进程对象，再调用child.spawn创建 子进程并执行命令，底层是调用了child.)handle.spawn执行process_wrap中的spwan方法，执行过程是异步的，执行完毕后再通过PIPE进行单向数据通信，通信结束后子进程发起onexit回调，同时Socket会执行close回调。 fork:原理是通过spawn创建子进程和执行命令，采用node执行命令，通过setupchannel创建IPC用于子进程和父进程之间的双向通信。 data/error/exit/close回调的区别 data：用于主进程读取数据过程中通过onStreamRead发起的回调 error: 命令执行失败后发起的回调 exit: 子进程关闭完成后发起的回调 close：子进程所有Socket通信端口全部关闭后发起的回调 stdout close/stderr close:特定的PIPE读取完成后调用onReadableStreamEnd关闭Socket时发起的回调。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/05.脚手架创建项目流程设计和开发.html":{"url":"pages/六个周/05.脚手架创建项目流程设计和开发.html","title":"05.脚手架创建项目流程设计和开发","keywords":"","body":"Week5-脚手架创建项目流程设计和开发 本周代码提交分支至：lesson05 第一章：本周导学 1-1本周整体内容介绍和学习方法 收获 完成脚手架创建项目流程开发 命令行交互方法 服务端框架egg.js应用和API开发方法 egg.js集成mongodb 第二章 脚手架项目创建功能架构设计 2-1 脚手架创建项目功能架构背后的思考 架构背后的思考 可扩展：能够快速复用到不同团队，适用不同团队的差异。 低成本：在不改动脚手架源码的基础上，新增模版，且新增模板的成本很低。 高性能：控制存储空间，安装时充分利用Node多进程提升安装性能。 2-2 项目创建前准备阶段架构设计 init 2-3 下载项目模板阶段架构设计 downloadTemplate 第三章 项目基本信息获取功能开发（详解命令行交互） 3-1 项目创建准备阶段——判断当前目录是否为空功能开发 本周代码从commands/init/lib/index.js文件中的exec方法开始启动。 根据上面的两小节分析，exec方法的代码逻辑为： 准备阶段 【this.prepare()】 下载模版 安装模版(下周实现) prepare方法的代码逻辑为： 判断当前目录是否为空 是否强制清空 选择创建项目或组件 获取项目/组件的基本信息 本节主要实现的代码是判断当前目录是否为空 prepare(){ if(!this.isCwdEmpty()){ // 询问是否继续创建 } } isCwdEmpty(){ const localPath = process.cwd(); let fileList = fs.readdirSync(localPath) // 文件过滤逻辑 fileList = fileList.filter((file)=>{ !file.startsWith('.') && ['node_modules'].indexOf 本节知识点： 拿到当前目录的方法一：process.cwd() 拿到当前目录的方法二: path.resolve('.') path.resolve(__dirname):拿到的是当前执行代码的目录 读取当前目录下的文件列表：fs.readdirSync() 3-2 inquirer基本用法和常用属性入门 继续写代码前，首先在测试项目里体验inquirer const inquirer = require('inquirer') inquirer .prompt([{ type:'input', name:'name', message:'your name:', default:'liugezhou', validate:function(v){ //对输入的参数进行校验，检验通过可进行下一步 return typeof v === 'string' }, filter:function(v){ //对用户输入的内容进行优化返回 return v+'!' }, transformer: function(v){ //相当于一个placeholder显示作用 return 'name :'+ v } },{ type:'number', // inquirer可以传入数组 name:'age', message:'your age:', default:'18' }]) .then(answers => { console.log(answers.name) console.log(answers.age) }) .catch(error => { if(error.isTtyError) { console.log('error') } else { // Something else when wrong } }); 3-3 inquirer其他交互形式演示 本节主要对list、rawlist、expand、confirm、checkbox等进行了功能与代码测试 测试代码提交至 inquirer 3-4 强制清空当前目录功能开发 本节主要是清空当前目录，进行清空下，使用命令行交互inquirer问询，以及用 force这个参数添加业务逻辑，进行目录的清空判断 清空目录功能主要是使用了第三方库fs-extra的emptyDirSync(localPath)方法。 3-5 获取项目基本信息功能开发 本节使用inquirer进行了项目或者组件的选择询问、以及版本号控制台输入功能，但未对输入内容进行校验 这里调整好代码逻辑即可。 3-6 项目名称和版本号合法性校验 本节的主要内容为合法项目名称的正则校验 function isValidName(v) { // 规则一：输入的首字符为英文字符 // 规则二：尾字符必须为英文或数字 // 规则三：字符仅允许-和_两种 // \\w=a-zA_Z0-9_ return /^[a-zA-Z]+([-][a-zA-Z][a-zA-Z0-9]*|[_][a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])*$/.test(v) } 正则表达式规则：首字符：^ 尾字符：$ \\w=a-zA-Z0-9 首字符必须为英文字符：/^[a-zA-Z]$/中间可以为英文数字或者-:/^[a-zA-Z]+[\\w-]/ 尾字符必须为英文或者数字:/^[a-zA-Z][\\w-]*[a-zA-Z]$/.test(v) 以上表达式规则，没有处理当项目名称为一个的时候的问题 给出不合法的命名有：1,a-,a,a1,a-1/^[a-zA-Z]+([-][a-zA-Z][a-zA-Z0-9]*|[][a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])$/.test(v)_ PS:3-6这里关于检验性输错后依旧报错的问题，没有得到解决，先暂缓了！ 第4章 预备知识：egg.js + 云 mongodb 快速入门 4-1 下载项目模板功能实现流程分析+egg.js简介 上一节我们获得了项目信息，这一节通过获得的项目信息进行模板的下载 通过项目模版API获取项目模版信息 通过egg.js搭建一套后台系统 (4-2 至 4-5) 通过npm存储项目模版 将项目模版信息存储到mongodb数据库中 通过egg.js获取mongodb中的数据并且通过API将其返回 在进行egg.js快速搭建后台系统前，对egg.js + 云mongodb进行一个快速的入门学习。 egg基于koa2生成的一个企业级框架。 4-2 cloudscope-cli-server后端项目创建 快速搭建项目 mkdir cloudscope-cli-server cd cloudscope-cli-server npm init egg --type=simple npm i npm run dev 这里需要注意的一点是：npm init egg 实际执行的是 create-egg这个包。 4-3 通过egg.js框架添加新的API 本节主要多egg脚手架进行了简单演示，将原路由home以及文件删除，新建了project/template路由以及controller。 路由在app/router.js中 'use strict'; /** * @param {Egg.Application} app - egg application */ module.exports = app => { const { router, controller } = app; router.get('/project/template', controller.project.getTemplate); }; controller of project 'use strict'; const Controller = require('egg').Controller; class ProjectController extends Controller { async getTemplate() { const { ctx } = this; ctx.body = 'get template'; } } module.exports = ProjectController; 4-4 云mongodb开通+本地mongodb调试技巧讲解 本地安装mongodb：https://www.runoob.com/mongodb/mongodb-osx-install.html 启动： 终端输入：mongod 报错，提示找不到/data/db目录 添加dbpath： 在本地新建 /Users/liugezhou/data/db目录 同步启动方式：mongod --dbpath=/Users/liugezhou/data/db 异步启动：在后面添加 --fork 注：由于我本地之前已经配好了，所以我本地的启动方式为：mongod --config /usr/local/etc/mongod.conf 查看mongodb.conf文件，我本地的dbpath路径为：/usr/local/var/mongodb 安装第三方工具：Robot 3T 连接到本地后： create database （liugezhou-cli) create collection (project) insert Doucument (添加数据) add user (cloudscope/cloudscope) 4-5 egg.js接入mongodb方法 本地mongodb数据库创建完成后，开始连接我们的本地数据库。 回到上节新创建的项目,sam老师安装的第三方依赖为 app下新建utils/mongo.js npm i -S @pick-star/cli-mongodb 由于@pick-star/cli-mongodb代码较少，我这里选择不安装，本地敲一遍代码： cnpm i -S npmlog mpngodb 在utils目录下新建log.js 'use strict' const npmlog = require('npmlog') log.level = process.env.LOG_LEVEL ? process.env.LOG_LEVEL : 'info'; log.headingStyle = { fg: 'red', bg: 'white' }; log.heading = 'liugezhou'; log.addLevel('success', 2500, { fg: 'green' }); module.exports = log; 在utils目录下新建mongodb.js(@pick-star/cli-mongodb源码) 'use strict'; const MongoClient = require('mongodb').MongoClient; const logger = require('./log'); class Mongo { constructor(url) { this.url = url; } connect() { return new Promise((resolve, reject) => { MongoClient.connect( this.url, { useNewUrlParser: true, useUnifiedTopology: true, }, (err, client) => { if (err) { reject(err); } else { const db = client.db(); resolve({ db, client }); } }); }); } connectAction(docName, action) { return new Promise(async (resolve, reject) => { const { db, client } = await this.connect(); try { const collection = db.collection(docName); action(collection, result => { this.close(client); logger.verbose('result', result); resolve(result); }, err => { this.close(client); logger.error(err.toString()); reject(err); }); } catch (err) { this.close(client); logger.error(err.toString()); reject(err); } }); } query(docName) { return this.connectAction(docName, (collection, onSuccess, onError) => { collection.find({}, { projection: { _id: 0 } }).toArray((err, docs) => { if (err) { onError(err); } else { onSuccess(docs); } }); }); } insert(docName, data) { return this.connectAction(docName, (collection, onSuccess, onError) => { collection.insertMany(data, (err, result) => { if (err) { onError(err); } else { onSuccess(result); } }); }); } remove(docName, data) { return this.connectAction(docName, (collection, onSuccess, onError) => { collection.deleteOne(data, (err, result) => { if (err) { onError(err); } else { onSuccess(result); } }); }); } update() { } close(client) { client && client.close(); } } module.exports = Mongo; utils/mongo.js 代码修改： 'use strict'; const Mongodb = require('./mongodb'); const { mongoDbName } = require('../../config/db'); function mongo() { return new Mongodb(mongodbUrl); } module.exports = mongo; 接着，在mongo.js暴露出去 'use stirct' const Mongodb = require('./mongodb') const { mongoDbUrl,mongodbName} = require('../../config/db') // 配置这两个参数 function mongo(){ return new Mongodb(mongoDbUrl,mongodbName) } // config/db.js 'use strict'; // Mondodb const mongodbUrl = `mongodb://${user}:${pass}@liugezhou.com:27017/${database}`; module.exports = { mongodbUrl, }; 最后，在Controller的project中访问： const mongo = require('./mongo.js') async getTemplate(){ const { ctx } = this; const data = await mongo().query('project'); ctx.body = data; } 第五章 项目模板开发 + 获取项目模板 API 开发 5-1 脚手架初始化项目模版开发 模版项目代码提交至：liugezhou-cli-dev-template 项目模板建好后，npm publish发布至npm。 5-2 脚手架请求项目模板API开发 回到脚手架项目 在utils下创建包： lerna create @cloudscope-cli/request cd utils npm i -S axios // utils/request/lib.index const axios = require('axios') const baseURL = process.env.CLI_URL?process.env.CLI_URL:'https://liugezhou.com:7001' const request = axios.create({ baseURL, timeout:5000 }) request.interceptors.response.use({ response =>{ return response.data }, error =>{ return Promise.reject(error) } }) module.exports = request commands/init引入@cloudsope-cli/request包 新建 lib/getProjectTemplate const request = require('@cloudscope-cli/request') modules.exports = function(){ return request({ url:'/project/template' }) } // commands/init/lib/index.js const getProjectTemplate = require('./getProjectTemplate') const template = getProjectTemplate() 最后在测试项目下测试，打印template，成功。 5-3 通过环境变量配置默认URL+选择项目模板功能开发 本章内容回顾了process.env的配置，以及inquirer新添加询问需要选择的项目模版是什么。 5-4 基于vue-element-admin开发通用的中后台项目模板 5-1 中已将项目模版更新至git仓库，且已发布到npm中。 只需要在mongodb数据库将后台模版name、npmName、version添加后即可。 第六章 脚手架项目模板下载功能开发 6-1 脚手架下载项目模板功能开发 本节的主要内容为项目模版的安装 // commands/init/lib/index.js async downloadTemplate(){ const {projectTemplate} = this.projectInfo const templateInfo = this.template.find(item=> item.npmName === projectTemplate) const targetPath = path.resolve(userHome,'.cloudscope-cli','template') const storeDir = path.resolve(userHome,'.cloudscope-cli','template','node_modules') const {npmName,version} = templateInfo const templatePkg = new Package({ targetPath, storeDir, packageName:npmName, packageVersion:version }) if(await templatePkg.exists()){ // 更新package log.verbose('更新template') await templatePkg.update(); }else{ // 安装package log.verbose('安装template') await templatePkg.install(); } } 6-2 通过spinner实现命令行loading效果 首先在utils/utils中添加spinnerStart和sleep方法 // utils/utils/lib/index.js function spinnerStart(msg,spinnerString ='|\\-\\\\'){ const Spinner = require('cli-spinner').Spinner const spinner = new Spinner(`${msg} %s`) spinner.setSpinnerString(spinnerString) spinner.start() return spinner } function sleep(timeout = 1000){ return new Promise(resolve => setTimeout(resolve,timeout)) } 然后在commands/init/lib/index.js中将spinner引入使用、测试。 6-3 项目模板更新功能调试 本节主要是安装功能的测试，以及第一次安装模版不存在时，关于spinner.stop的finnal处理。 第七章：本周加餐：inquirer源码解析：彻底搞懂命令行交互原理 7-1 本章学习路径和目标 掌握 readline/events/stream/ansi-escapes/rxjs 掌握命令行交互的实现原理，并实现一个可交互的列表 分析inquirer源码掌握其中的关键实现 7-2 readline的使用方法和实现原理 readline是Node.js中的一个内置库，主要是用来管理输入流的 const readline = require('readline') const rl = readline.createInterface({ input:process.stdin, output:process.stdout }) rl.question('your name:',(answer =>{ console.log('your name is:'+answer) rl.close() })) 源码分析： 强制将函数转为构建函数 function Interface(input, output, completer, terminal) { if (!(this instanceof Interface)) { return new Interface(input, output, completer, terminal); } ………… } 获得事件驱动能力：EventEmitter.call(this); 监听键盘事件： emitKeypressEvents(input, this); // `input` usually refers to stdin input.on('keypress', onkeypress); input.on('end', ontermend); 7-3 高能：深入讲解readline键盘输入监听实现原理 略 7-4 秀操作：手写readline核心实现 typescript function setpread(callback){ function onkeypress(s){ output.write(s); line += s switch (s) { case '\\r': input.pause(); callback(line) break; default: break; } } const input = process.stdin; const output = process.stdout; let line ='' emitKeypressEvents(input) input.on('keypress',onkeypress) input.setRawMode(true) //进入原生模式 input.resume() } function emitKeypressEvents(stream){ function onData(chunk){ g.next(chunk.toString()) } const g = emitKeys(stream) g.next() stream.on('data',onData) } function* emitKeys(stream){ while (true) { let ch = yield; stream.emit('keypress',ch) } } setpread(function(s){ console.log('answer:',s) }) 7-5 命令行样式修改的核心原理：ansi转义序列讲解 ansi-escape-code:ansi转义序列 定义的一个规范，终端通过转义字符实现特殊操作。 通过这里查询：https://handwiki.org/wiki/ANSI_escape_code // 固定格式为：( \\x1B[ ) + ('通过上面网站查询出来的参数') console.log('\\x1B[31m\\x1B[4m%s','your name:') console.log('\\x1B[20G%s','test') 7-6 讨论readline 7-7 响应式库rxjs快速入门 rxjs是一个异步的库，和我们的Promise是非常相似的。readline源码大量使用了这个库。 // npm install rxjs const range = require('rxjs').range; const { map, filter } = require('rxjs/operators'); const pipe = range(1, 200) .pipe( filter(x => x % 2 === 1), map(x => x + x), filter(x => x%3 === 0), filter(x => x%5 === 0) ) pipe.subscribe(x => console.log(x)); 7-8& 7-9 放大招：手写命令行交互式列表组件 const EventEmitter = require('events'); const readline = require('readline'); const MuteStream = require('mute-stream'); const { fromEvent } = require('rxjs'); const ansiEscapes = require('ansi-escapes'); const option = { type: 'list', name: 'name', message: 'select your name:', choices: [{ name: 'sam', value: 'sam', }, { name: 'shuangyue', value: 'sy', }, { name: 'zhangxuan', value: 'zx', }], }; function Prompt(option) { return new Promise((resolve, reject) => { try { const list = new List(option); list.render(); list.on('exit', function(answers) { resolve(answers); }) } catch (e) { reject(e); } }); } class List extends EventEmitter { constructor(option) { super(); this.name = option.name; this.message = option.message; this.choices = option.choices; this.input = process.stdin; const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; this.rl = readline.createInterface({ input: this.input, output: this.output, }); this.selected = 0; this.height = 0; this.keypress = fromEvent(this.rl.input, 'keypress') .forEach(this.onkeypress); this.haveSelected = false; // 是否已经选择完毕 } onkeypress = (keymap) => { const key = keymap[1]; if (key.name === 'down') { this.selected++; if (this.selected > this.choices.length - 1) { this.selected = 0; } this.render(); } else if (key.name === 'up') { this.selected--; if (this.selected { if (!this.haveSelected) { let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choice, index) => { if (index === this.selected) { // 判断是否为最后一个元素，如果是，则不加\\n if (index === this.choices.length - 1) { title += '\\x1B[36m❯ ' + choice.name + '\\x1B[39m '; } else { title += '\\x1B[36m❯ ' + choice.name + '\\x1B[39m \\n'; } } else { if (index === this.choices.length - 1) { title += ' ' + choice.name; } else { title += ' ' + choice.name + '\\n'; } } }); this.height = this.choices.length + 1; return title; } else { // 输入结束后的逻辑 const name = this.choices[this.selected].name; let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; return title; } }; clean() { const emptyLines = ansiEscapes.eraseLines(this.height); this.output.write(emptyLines); } close() { this.output.unmute(); this.rl.output.end(); this.rl.pause(); this.rl.close(); } } Prompt(option).then(answers => { console.log('answers:', answers); }); 7-10 inquirer源码执行流程分析 略 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/06.脚手架项目和组件初始化开发.html":{"url":"pages/六个周/06.脚手架项目和组件初始化开发.html","title":"06.脚手架项目和组件初始化开发","keywords":"","body":"Week6-脚手架项目和组件初始化开发 第一章：本周导学 1-1 本周整体内容介绍和学习方法 重点：脚手架安装 项目/组件 功能开发。 技术栈：ejs模版渲染(项目模板安装)和glob文件筛选。 加餐：ejs源码解析、require源码解析。 第二章：脚手架安装模版功能架构设计 2-1 脚手架安装项目模板架构设计 installTemplate 2-2 脚手架组件初始化架构设计 与项目大体过程没有改变。 tiny change： 文本提示名称 项目名称format 组件需要填写描述信息 第三章 脚手架模板安装核心实现：ejs 库功能详解 3-1 ejs模板引擎的三种基本用法 ejs主要用于模版渲染的。jsp、php是之前模版渲染的代表。ejs的实现与jsp非常类似。 ejs.compile(html,options)(data) const ejs = require('ejs') const path = require('path') //第一种方法 const html ='' const options = {} const data ={ user:{ name:'liugezhou' } } const template = ejs.compile(html,options) //// 返回一个用于解析html中模板的 function const compileTemplate = template(data) console.log(compileTemplate) //liugezhou //第二种用法 const renderTemplate = ejs.render(html,data,options) console.log(renderTemplate) //第三种用法 const renderFile = ejs.renderFile(path.resolve(__dirname,'template.html'),data,options) renderFile.then(file => console.log(file)) 3-2 ejs模板不同标签用法详解 liugehou,那么输出的就是这样的格式。 -%>: 删除紧随其后的换行符 _%>: 删除后面空格字符 3-3 ejs模板几种特殊用法 本节主要介绍ejs另外比较常用的三个辅助功能 包含: include 自定义分隔符: 我们上面默认使用的是%，我们只需要在options参数中定义 delimiter这个参数即可 自定义文件加载器: 在使用ejs.renderFile读取文件之前，可以使用ejs.fileLoader做一些操作 ejs.fileLoader = function(filePath){ const content = fs.readFileSync(filePath) return '' + content } 3-4 glob用法小结 glob最早是出现在类Unix系统的命令中的，用来匹配文件路径。 const glob = require('glob') glob('**/*.js',{ignore:['node_modules/**','webpack.config.js']},function(err,file){ console.log(file) }) 第四章：脚手架项目模板安装功能开发 4-1 引入项目模板类型和标准安装逻辑开发 本节代码较少，主要是梳理流程，上一大周写到了下载模版到本地缓存，本节接着上周进度： 接着便需要安装模版，新建了安装模版 installTemplate()方法，并对拿到模版的type进行判断， 若为normal，则执行安装标准模版方法：installNormalTemplate() 若为custom，则执行安装自定义模版方法：installCustomTemplate() 4-2 拷贝项目模板功能开发 async installNormalTemplate(){ //拷贝模板代码至当前目录 const spinner = spinnerStart('正在安装模板...') await sleep() try { // 去缓存目录中拿template下的文件路径 const templatePath = path.resolve(this.templateNpm.cacheFilePath,'template') //当前执行脚手架目录 const targetPath = process.cwd() fse.ensureDirSync(templatePath)//确保使用前缓存生成目录存在，若不存在则创建 fse.ensureDirSync(targetPath) //确保当前脚手架安装目录存在，若不存在则创建 fse.copySync(templatePath,targetPath) //将缓存目录下文件copy至当前目录 } catch (error) { throw error } finally{ spinner.stop(true) log.success('模板安装成功') } } 4-3 项目模板安装依赖和启动命令 | 4-4 白名单命令检测功能开发 在上一节，模板copy成功之后，紧接着： //依赖安装 const { installCommand,startCommand } = this.templateInfo //依赖安装 await this.execCommand(installCommand,'依赖过程安装失败！') //启动命令执行 await this.execCommand(startCommand,'启动命令执行失败失败！') const WHITE_COMMAND =['npm', 'cnpm'] async execCommand(command,errMsg){ let ret if(command){ const cmdArray=command.split(' ') const cmd = this.checkCommand(cmdArray[0]) if(!cmd){ throw new Error(errMsg) } const args = cmdArray.slice(1) ret = await execAsync(cmd,args,{ stdio:'inherit', cwd:process.cwd() }) if(ret !== 0){//执行成功 throw new Error('依赖安装过程失败') } return ret } } checkCommand(cmd){ if(WHITE_COMMAND.includes(cmd)){ return cmd } return null; } 4-5 项目名称自动格式化功能开发 本节使用了kebab-case这个库，将手动填入的项目名称保存在projectInfo中，以供后续package.json中的ejs渲染使用。 //生成className if(projectInfo.projectName){ projectInfo.name = projectInfo.projectName projectInfo.className = require('kebab-case')(projectInfo.projectName).replace(/^-/,''); } if(projectInfo.projectVersion){ projectInfo.version = projectInfo.projectVersion } 4-6 本章核心：ejs动态渲染项目模板 首先将vue2模版中package.json文件中的name以及version使用和替代，并发布新的版本至npm。 commands/init模块安装 ejs和glob库。 核心代码如下(在4-4节中依赖安装前，ejs动态渲染) async ejsRender(options){ const dir = process.cwd() const projectInfo = this.projectInfo return new Promise((resolve,reject)=>{ glob('**',{ cwd:dir, ignore:options.ignore || '', nodir:true //不输出文件夹，只输出文件 },(err,files) =>{ if(err){ reject(err) } Promise.all(files.map(file=>{ const filePath = path.join(dir,file) return new Promise( (resolve1,reject1) => { ejs.renderFile( filePath,projectInfo,{},(err,result) => { if(err){ reject1(err) } fse.writeFileSync(filePath,result) resolve1(result) }) }) })).then(()=>{ resolve() }).catch(err=>{ reject(err) }) }) }) } 4-7 init命令直接传入项目名称功能支持 本节完成的是 对命令行中传入项目名称的一个支持 通过判断脚手架命令是否传入项目名称，对inquirer中的prompt进行动态push。 第五章 组件模板开发及脚手架组件初始化功能支持 5-1 慕课乐高组件库模板开发 维护组件库发布至npm，然后在mongodb数据库中进行配置。 5-2 项目和组件模板数据隔离+动态配置ejs ignore 这部分完整代码如下 //1.选取创建项目或组件 const { type } = await inquirer.prompt({ type:'list', name:'type', message:'请选择初始化类型', default:TYPE_PROJECT, choices: [{ name: '项目', value: TYPE_PROJECT, }, { name: '组件', value: TYPE_COMPONENT, }] }) // 数据隔离核心代码 this.template = this.template.filter(template =>template.tag && template.tag.includes(type)) const title = type === TYPE_PROJECT ? '项目':'组件' const projectNamePrompt = { type:'input', name:'projectName', message:`请输入${title}的名称`, default:'', validate:function(v){ const done = this.async() setTimeout(function(){ if(!isValidName(v)){ done(`请输入合法的${title}名称`) return; } done(null,true) }, 0); }, filter:function(v){ return v } } const projectPrompt = [] if (!isProjectNameValid) { projectPrompt.push(projectNamePrompt); } projectPrompt.push({ type:'input', name:'projectVersion', default:'1.0.0', message:`请输入${title}版本号`, validate:function(v){ const done = this.async(); // Do async stuff setTimeout(function() { if (!(!!semver.valid(v))) { done(`请输入合法的${title}版本号`); return; } done(null, true); }, 0); }, filter:function(v){ if(semver.valid(v)){ return semver.valid(v) } else { return v } }, },{ type:'list', name:'projectTemplate', message:`请选择${title}模板`, choices: this.createTemplateChoice() }) 5-3 获取组件信息功能开发 完整核心代码如下,添加了 descriptionPrompt else if (type === TYPE_COMPONENT){ // 获取组件的基本信息 const descriptionPrompt = { type:'input', name:'componentDescription', message:'请输入组件描述信息', default:'', validate:function(v){ const done = this.async() setTimeout(() => { if(!v){ done('请输入组件描述信息') return } done(null,true) }, 0); } } projectPrompt.push(descriptionPrompt) const component = await inquirer.prompt(projectPrompt) projectInfo = { ...projectInfo, type, ...component } } …… if(projectInfo.componentDescription){ projectInfo.description = projectInfo.componentDescription } 5-4 解决组件库初始化过程中各种工程问题 ** 慕课乐高组件库，在发布到npm包时，安装出现问题，问题原因是 package.json中，需要将 \"files\":['dist'] 这行代码去除，这是因为files这里限定了上传发布到npm后只有dist这个目录。 第六章 脚手架自定义初始化项目模板功能开发 6-1 自定义项目模板开发 发布自定义模版 liugezhou-cli-dev-template-custom-vue2 mongodb中配置自定义模版数据。 6-2 自定义模板执行逻辑开发 6-3 自定义模板上线 async installCustomTemplate(){ //查询自定义模版的入口文件 if(await this.templateNpm.exists()){ const rootFile = this.templateNpm.getRootFilePath() if(fs.existsSync(rootFile)){ log.verbose('开始执行自定义模板') const templatePath = path.resolve(this.templateNpm.cacheFilePath, 'template'); const options = { templateInfo: this.templateInfo, projectInfo: this.projectInfo, sourcePath: templatePath, targetPath: process.cwd(), }; const code = `require('${rootFile}')(${JSON.stringify(options)})` await execAsync('node', ['-e', code], {stdio:'inherit',cwd: process.cwd()}) log.success('自定义模版安装成功') }else{ throw new Error('自定义模板入口文件不存在') } } } 第七章 本周加餐：ejs 库源码解析 —— 彻底搞懂模板动态渲染原理 7-1 ejs.compile执行流程分析 ejs模版渲染的思路值得我们学习，于是我们就开始了了ejs的源码的学习。 本节内容较简单，我们打开webstore，从下面的代码开始调试（11行 打断点） const ejs = require('ejs') const html = '' const options = {} const data = { user:{ name:'liugezhou' } } const template = ejs.compile(html,options) const compiletemplate = template(data) //ejs.js exports.compile = function compile(template, opts) { var templ; if (opts && opts.scope) { //我们的opts传进来的参数为空，暂不看此判断逻辑 …… } templ = new Template(template, opts); return templ.compile(); }; templ = new Template(template,opts) 我们继续进去源码，重要的有两点 this.templateText = text this.regex = this.createRegex() 下节开始 templ.compile() function Template(text, opts) { opts = opts || {}; var options = {}; this.templateText = text; //⭐️⭐️⭐️ this.mode = null; this.truncate = false; this.currentLine = 1; this.source = ''; options.client = opts.client || false; options.escapeFunction = opts.escape || opts.escapeFunction || utils.escapeXML; options.compileDebug = opts.compileDebug !== false; options.debug = !!opts.debug; options.filename = opts.filename; options.openDelimiter = opts.openDelimiter || exports.openDelimiter || _DEFAULT_OPEN_DELIMITER; options.closeDelimiter = opts.closeDelimiter || exports.closeDelimiter || _DEFAULT_CLOSE_DELIMITER; options.delimiter = opts.delimiter || exports.delimiter || _DEFAULT_DELIMITER; options.strict = opts.strict || false; options.context = opts.context; options.cache = opts.cache || false; options.rmWhitespace = opts.rmWhitespace; options.root = opts.root; options.includer = opts.includer; options.outputFunctionName = opts.outputFunctionName; options.localsName = opts.localsName || exports.localsName || _DEFAULT_LOCALS_NAME; options.views = opts.views; options.async = opts.async; options.destructuredLocals = opts.destructuredLocals; options.legacyInclude = typeof opts.legacyInclude != 'undefined' ? !!opts.legacyInclude : true; if (options.strict) { options._with = false; } else { options._with = typeof opts._with != 'undefined' ? opts._with : true; } this.opts = options; this.regex = this.createRegex(); // ⭐️⭐️⭐️：该方法是对ejs标识符号%与开始结尾符号<>，进行定制化操作 } 7-2 深入讲解ejs编译原理 上一节我们看到了 return templet.compile()处，源代码如下 compile: function () { var src; var fn; var opts = this.opts; var prepended = ''; var appended = ''; var escapeFn = opts.escapeFunction; var ctor; var sanitizedFilename = opts.filename ? JSON.stringify(opts.filename) : 'undefined'; if (!this.source) { this.generateSource(); //⭐️⭐️⭐️⭐️⭐️ prepended += ' var __output = \"\";\\n' + ' function __append(s) { if (s !== undefined && s !== null) __output += s }\\n'; if (opts.outputFunctionName) { prepended += ' var ' + opts.outputFunctionName + ' = __append;' + '\\n'; } if (opts.destructuredLocals && opts.destructuredLocals.length) { var destructuring = ' var __locals = (' + opts.localsName + ' || {}),\\n'; for (var i = 0; i 0) { destructuring += ',\\n '; } destructuring += name + ' = __locals.' + name; } prepended += destructuring + ';\\n'; } if (opts._with !== false) { prepended += ' with (' + opts.localsName + ' || {}) {' + '\\n'; appended += ' }' + '\\n'; } appended += ' return __output;' + '\\n'; this.source = prepended + this.source + appended; } if (opts.compileDebug) { src = 'var __line = 1' + '\\n' + ' , __lines = ' + JSON.stringify(this.templateText) + '\\n' + ' , __filename = ' + sanitizedFilename + ';' + '\\n' + 'try {' + '\\n' + this.source + '} catch (e) {' + '\\n' + ' rethrow(e, __lines, __filename, __line, escapeFn);' + '\\n' + '}' + '\\n'; } else { src = this.source; } if (opts.client) { src = 'escapeFn = escapeFn || ' + escapeFn.toString() + ';' + '\\n' + src; if (opts.compileDebug) { src = 'rethrow = rethrow || ' + rethrow.toString() + ';' + '\\n' + src; } } if (opts.strict) { src = '\"use strict\";\\n' + src; } if (opts.debug) { console.log(src); } if (opts.compileDebug && opts.filename) { src = src + '\\n' + '//# sourceURL=' + sanitizedFilename + '\\n'; } try { if (opts.async) { try { ctor = (new Function('return (async function(){}).constructor;'))(); } catch(e) { if (e instanceof SyntaxError) { throw new Error('This environment does not support async/await'); } else { throw e; } } } else { ctor = Function; } fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src); } catch(e) { // istanbul ignore else if (e instanceof SyntaxError) { if (opts.filename) { e.message += ' in ' + opts.filename; } e.message += ' while compiling ejs\\n\\n'; e.message += 'If the above error is not helpful, you may want to try EJS-Lint:\\n'; e.message += 'https://github.com/RyanZim/EJS-Lint'; if (!opts.async) { e.message += '\\n'; e.message += 'Or, if you meant to create an async function, pass `async: true` as an option.'; } } throw e; } var returnedFn = opts.client ? fn : function anonymous(data) { var include = function (path, includeData) { var d = utils.shallowCopy({}, data); if (includeData) { d = utils.shallowCopy(d, includeData); } return includeFile(path, opts)(d); }; return fn.apply(opts.context, [data || {}, escapeFn, include, rethrow]); }; if (opts.filename && typeof Object.defineProperty === 'function') { var filename = opts.filename; var basename = path.basename(filename, path.extname(filename)); try { Object.defineProperty(returnedFn, 'name', { value: basename, writable: false, enumerable: false, configurable: true }); } catch (e) {/* ignore */} } return returnedFn; }, generateSource：（最终拿到结果this.source） generateSource: function () { var opts = this.opts; // Slurp spaces and tabs before this.templateText = this.templateText.replace(/[ \\t]*[ \\t]*/gm, '_%>'); var self = this; var matches = this.parseTemplateText(); //⭐️⭐️⭐️⭐️⭐️ var d = this.opts.delimiter; var o = this.opts.openDelimiter; var c = this.opts.closeDelimiter; if (matches && matches.length) { matches.forEach(function (line, index) { //⭐️⭐️⭐️⭐️⭐️ var closing; if ( line.indexOf(o + d) === 0 // If it is a tag && line.indexOf(o + d + d) !== 0) { // and is not escaped closing = matches[index + 2]; if (!(closing == d + c || closing == '-' + d + c || closing == '_' + d + c)) { throw new Error('Could not find matching close tag for \"' + line + '\".'); } } self.scanLine(line); ////⭐️⭐️⭐️⭐️⭐️ }); } }, 7-3 动态生成Function+with用法讲解 上一节代码没有继续追踪，根据自己的源码一步一步调试，生一节调试到的代码为： // ejs.js line662 fn = new ctor(opts.localsName + ', escapeFn, include, rethrow', src); 代码讲解： const ctor = Function; const fn = new ctor('a,b','console.log(a,b)') fn(1,2) 我们回到7-1节中基础代码，在optons加入参数debug为true，控制台输出内容为： var __line = 1 , __lines = \"\" , __filename = undefined; try { var __output = \"\"; function __append(s) { if (s !== undefined && s !== null) __output += s } with (locals || {}) { ; __append(\"\") ; __append(escapeFn( user.name)) ; __append(\"\") } return __output; } catch (e) { rethrow(e, __lines, __filename, __line, escapeFn); } 通过代码，我们看到了‘with’，现在前端with的使用已经很不常见且不推荐使用了，这里简单了解下： const ctx = { user:{ name:'liugezhou' } } with(ctx){ console.log(user.name) } 7-4 ejs compile函数执行流程分析 apply简要解释 function test(a,b,c){ console.log(a,b,c) console.log(this.a) } test(1,2,3) //通常调用 // 1 2 3 test.apply({a:'applt'},[2,3,4]) // 2 3 4 test.call({a:'call',2,3,4) // 2 3 4 7-5 ejs.render和renderFile原理讲解 ejs.render的代码执行流程为： const renderTemplate = ejs.render(html,data,options) exports.render ==> handleCache(opts, template) handleCache ==> return exports.compile(template, options); handleCache(opts, template)(data) renderFile的原理讲解 const renderFile = ejs.renderFile(path.resolve(__dirname,'template.html'),data,options) exports.renderFile tryHandleCache(opts, data, cb) handleCache(options)(data) 第八章 加餐：require源码解析，彻底搞懂 npm 模块加载原理 8-1 require源码执行流程分析 require使用场景 加载模块类型 加载内置模块： require('fs') 加载node_modules模块：require('ejs') 加载本地模块：require('./utils') 支持加载文件 js json node mjs 加载其它类型 require执行流程 我们在调试这行代码的时候，在执行栈中可以看到，之前也执行了很多代码，这里的流程以及上面分析的使用场景，我们可以先引出一些思考： CommonJS模块的加载流程 require如何加载内置模块？ loadNativeModule require如何加载node_modules模块？ require为什么会将非js/json/node文件视为js进行加载 require源码 我们从 require('./ejs') 这行代码在webStorm中开始调试。（点击step into ） 打开 Scripts --> no domain --> internal --> modules --> cjs --> helpers.js return mod.require(path); ----> line of 77 [helpers.js] 这里的mod就是指Module对象，调试后每个字段含义为： id：源码文件路径 path:源码文件对应的文件夹,通过path.dirname(id)生成 exports：模块输出的内容，默认为{} parent：父模块信息 filename:源码文件路径 loaded：是否已经加载完毕 children：子模块对象集合 paths：模块查询范围 继续step into到下一步，进去Module对象的require方法 代码如下: (校验参数为 string类型且不为空) Module.prototype.require = function(id) { validateString(id, 'id'); if (id === '') { throw new ERR_INVALID_ARG_VALUE('id', id, 'must be a non-empty string'); } requireDepth++; try { return Module._load(id, this, /* isMain */ false); } finally { requireDepth--; } }; Module._load(id,this,false) : id：传入的字符串 this：Module对象 isMain:flase表示加载的不是一个主模块 Module._load = function(request, parent, isMain) { let relResolveCacheIdentifier; if (parent) { debug('Module._load REQUEST %s parent: %s', request, parent.id); relResolveCacheIdentifier = `${parent.path}\\x00${request}`; const filename = relativeResolveCache[relResolveCacheIdentifier]; if (filename !== undefined) { const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) { updateChildren(parent, cachedModule, true); return cachedModule.exports; } delete relativeResolveCache[relResolveCacheIdentifier]; } } // ✨✨✨ // Module._resolveFilename是require.resolve()的核心实现，在lerna源码讲解时学过--> Module._resolveLookupPaths() const filename = Module._resolveFilename(request, parent, isMain); const cachedModule = Module._cache[filename]; if (cachedModule !== undefined) { updateChildren(parent, cachedModule, true); return cachedModule.exports; } //✨✨✨ // loadNativeModule 中 加载内置模块，进入该源码:通过NativeModule.map我们可以看到所有的内置模块 const mod = loadNativeModule(filename, request, experimentalModules); if (mod && mod.canBeRequiredByUsers) return mod.exports; // 不是内置模块，new Module，其中children在new的时候完成 const module = new Module(filename, parent); if (isMain) { process.mainModule = module; module.id = '.'; } Module._cache[filename] = module; if (parent !== undefined) { relativeResolveCache[relResolveCacheIdentifier] = filename; } let threw = true; try { if (enableSourceMaps) { try { module.load(filename); } catch (err) { rekeySourceMap(Module._cache[filename], err); throw err; /* node-do-not-add-exception-line */ } } else { // &#x1F31F;&#x1F31F;&#x1F31F;：模块加载 module.load(filename); } threw = false; } finally { if (threw) { delete Module._cache[filename]; if (parent !== undefined) { delete relativeResolveCache[relResolveCacheIdentifier]; } } } return module.exports; }; 8-2 require加载模块原理详解 上一节我们走到了Module._load(filename) Module.prototype.load = function(filename) { debug('load %j for module %j', filename, this.id); assert(!this.loaded); // this.filename为上一节new的时候定义的filename this.filename = filename; // 从这个文件的文件目录开始查到，拿到所有的可能有node_modules的路径 this.paths = Module._nodeModulePaths(path.dirname(filename)); // 拿到该文件名的后缀：进入该方法可以看到定义的加载的后缀名有四种：js json node mjs const extension = findLongestRegisteredExtension(filename); // allow .mjs to be overridden if (filename.endsWith('.mjs') && !Module._extensions['.mjs']) { throw new ERR_REQUIRE_ESM(filename); } // 这里就是require模块加载的真正逻辑，包含 js node json,源码内容见下 Module._extensions[extension](this, filename); this.loaded = true; if (experimentalModules) { const ESMLoader = asyncESM.ESMLoader; const url = `${pathToFileURL(filename)}`; const module = ESMLoader.moduleMap.get(url); // Create module entry at load time to snapshot exports correctly const exports = this.exports; // Called from cjs translator if (module !== undefined && module.module !== undefined) { if (module.module.getStatus() >= kInstantiated) module.module.setExport('default', exports); } else { // Preemptively cache // We use a function to defer promise creation for async hooks. ESMLoader.moduleMap.set( url, // Module job creation will start promises. // We make it a function to lazily trigger those promises // for async hooks compatibility. () => new ModuleJob(ESMLoader, url, () => new ModuleWrap(url, undefined, ['default'], function() { this.setExport('default', exports); }) , false /* isMain */, false /* inspectBrk */) ); } } }; Module._extensionsextension Module._extensions['.js'] = function(module, filename) { if (filename.endsWith('.js')) { const pkg = readPackageScope(filename); // Function require shouldn't be used in ES modules. if (pkg && pkg.data && pkg.data.type === 'module') { const parentPath = module.parent && module.parent.filename; const packageJsonPath = path.resolve(pkg.path, 'package.json'); throw new ERR_REQUIRE_ESM(filename, parentPath, packageJsonPath); } } //content内容就是我们加载的ejs/index.js问的内容，这里返回一个字符串 const content = fs.readFileSync(filename, 'utf8'); // 拿到ejs.index.js中的内容，Module原型链上执行_compile,代码如下： module._compile(content, filename); }; Module.prototype._compile = function(content, filename) { let moduleURL; let redirects; if (manifest) { moduleURL = pathToFileURL(filename); redirects = manifest.getRedirector(moduleURL); manifest.assertIntegrity(moduleURL, content); } maybeCacheSourceMap(filename, content, this); const compiledWrapper = wrapSafe(filename, content, this); var inspectorWrapper = null; if (getOptionValue('--inspect-brk') && process._eval == null) { if (!resolvedArgv) { // We enter the repl if we're not given a filename argument. if (process.argv[1]) { try { resolvedArgv = Module._resolveFilename(process.argv[1], null, false); } catch { // We only expect this codepath to be reached in the case of a // preloaded module (it will fail earlier with the main entry) assert(ArrayIsArray(getOptionValue('--require'))); } } else { resolvedArgv = 'repl'; } } // Set breakpoint on module start if (resolvedArgv && !hasPausedEntry && filename === resolvedArgv) { hasPausedEntry = true; inspectorWrapper = internalBinding('inspector').callAndPauseOnStart; } } const dirname = path.dirname(filename); const require = makeRequireFunction(this, redirects); let result; const exports = this.exports; const thisValue = exports; const module = this; if (requireDepth === 0) statCache = new Map(); if (inspectorWrapper) { result = inspectorWrapper(compiledWrapper, thisValue, exports, require, module, filename, dirname); } else { result = compiledWrapper.call(thisValue, exports, require, module, filename, dirname); } hasLoadedAnyUserCJSModule = true; if (requireDepth === 0) statCache = null; return result; }; 8-3 require加载内置模块和四种文件类型原理 加载内置模块：流程到 loadNativeModule结束。 加载node_modules模块：通过 Module._resolveFilename(request, parent, isMain)找到路径。 加载不存在模块：Module._resolveFilename中抛出异常。 加载.js/.json/.node/mjs文件：Module._extensions['XXX' ] 加载其它文件后缀名：默认按js执行 8-4 require缓存机制解析和CommonJS加载主模块原理 连续加载两次同一个文件，require是如何处理的？ A: require的缓存机制，使得在第二次加载相同的文件时，不会再次执行源文件，直接从缓存中去拿。 CommonJS加载主模块流程： require('internal/modules/cjs/loader').Module.runMain(process.argv[1]); Module._load(main, null, true); module.load(filename); Module._extensionsextension; module._compile(content, filename); 与require的区别为：isMain为true，parent为null 8-5 require原理总结和回顾 relativeResolveCache[relResolveCacheIdentifier]查询缓存路径 Module._cache[filename]查询缓存模块 Module._resolveFilename查询模块的真实路径 Module._resolveFilename查询模块的真实路径 new Module实例化 Module 对象 module.load(filename)加载模块 findLongestRegisteredExtension获取文件后缀 Module._extensions[extension](this, filename)解析模块并执行模块 module._compile编译模块代码 compileFunction将模块代码生成可执行函数 exports, require, module, filename, dirname生成入参 compiledWrapper.call执行模块函数 return module.exports 输出模块返回结果 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六个周/99.整体架构设计文档范本V0.1.html":{"url":"pages/六个周/99.整体架构设计文档范本V0.1.html","title":"99.整体架构设计文档范本V0.1","keywords":"","body":"Week0-整体架构设计文档范本V0.1 需求 将需求链接或者内容摘录至此 范围(背景描述/目的) 整体设计、架构设计、没有细节 模块设计 模块的拆分和关系图，结果 模块的关键功能、职责等描述 特殊的模块重点说明： 组件库、独立第三方，同时用于编辑和H5. 自研统计服务，为何自研 作品的数据结构 vuex store的结构、解释 数据流转关系图 扩展性保证 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 vnode 扩展页面的配置 （讨论、集思广益） 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六玥/":{"url":"pages/六玥/","title":"六玥","keywords":"","body":"六玥学习分享 2021年的全新征程 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六玥/01-第一周笔记和作业.html":{"url":"pages/六玥/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"需求 乐高编辑器 范围 整体设计，架构设计，没有细节 C端用户使用的手机端H5 C端用户通过H5端可以通过作品了解详情，并且可以进行转发分享，通过埋点可以了解相关的数据统计。 开发方式：SSR B端用户或者个人所使用的PC端编辑器 B端用户或者个人可以通过乐高编辑器编辑、发布自己想要的广告海报和宣传页，生成对应的H5链接供C端用户使用 开发方式：前后端分离，前端：editor-fe，后端：editor-server 管理员使用的后台管理系统 B端用户和个人可以在后台管理系统进行作品的管理，如发布、下线、用户权限的管理、相关数据的统计等， 开发方式：前后端分离，前端：admin-fe，后端：admin-server 模块设计 特殊的模块重点说明： 组件库 独立第三方，同时用于编辑器和H5，因为编辑器画布使用的组件的渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 作品的数据结构 思路： 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store的数据结构 { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter的数据结构 // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 数据流转关系图 见模块设计 扩展性保证 扩展组件，数据结构层面 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面配置，如增加多语言、设置背景 扩展其他功能，如大数据分析和计算等 开发提效 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 流量大时，基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/六玥/02-第二周笔记和作业.html":{"url":"pages/六玥/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"站在前端研发的视角，分析开发脚手架的必要性 研发效能 脚手架的核心目标是：提升前端研发效能 大厂研发架构图： 脚手架核心价值 将研发过程： 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 和自动化构建工具的区别 问题：Jenkins、Travis等自动化构建工具已经比较成熟了，为什么还需要自研脚手架？ 不满足需求：Jenkins、Travis通常在git hooks中触发，需要在服务端执行（仅仅只能覆盖云构建端的操作），无法覆盖研发人员本地的功能，如：创建项目自动化，本地git操作自动化等 定制复杂：Jenkins、Travis定制过程需要开发插件，其过程较为复杂，需要使用java语言，对前端同学不够友好 从使用角度理解什么是脚手架 脚手架简介 脚手架本质是一个操作系统的客户端，它通过命令执行，比如： vue create vue-test-app 上面命令由3个部分组成： 主命令：vue command：create command的params：vue-test-app 他表示创建一个vue的项目，项目的名称为vue-test-app，以上是一个较为简单的脚手架命令，但实际场景往往更加复杂，比如： 当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装vue项目，此时我们就可以输入 vue create vue-test-app --force 这里的--force叫做option，用来辅助脚手架确定在特定场景下用户的选择（可以理解为配置）。还有一种场景： 通过vue create创建项目时，会自动执行npm install帮用户安装依赖，如果我们希望使用淘宝源来安装，可以使用命令： vue create vue-test-app --force -r https://registry.npm.taobao.org 这里的-r也叫做option，它与--force不同的是它使用-，并且使用了简写，这里的-r也可以替换成--registry，如果不知道vue create支持的所有options，可以使用： vue create --help -r https://registry.npm.taobao.org后面的https://registry.npm.taobao.org成为option的param，其实--force可以理解为：--force true，简写为：--force或-f 脚手架执行原理 脚手架的执行原理如下： 在终端输入vue create vue-test-app 终端解析出vue命令 终端在环境变量中找到vue命令 终端根据vue命令链接到实际文件vue.js 终端利用node执行vue.js vue.js解析command/options vue.js执行command/options 执行完毕，退出执行 从应用角度看如何开发一个脚手架 这里以vue-cli为例： 开发npm项目，该项目中应包含一个bin/vue.js文件，并将这个项目发布到npm 将npm项目安装到node的lib/node_modules 在node的bin目录下配置vue软连接指向lib/node_modules/@vue/cli/bin/vue.js 这样我们在执行vue命令的时候就可以找到vue.js进行执行 疑问解答 为什么全局安装@vue/cli后会添加的命令为vue？ npm install -g @vue/cli 答：在/usr/local/lib/node_modules/@vue/cli文件夹下的package.json的 \"bin\":{ \"vue\": \"bin/vue.js\" } 这个软连接的名称就是vue，所以添加后的命令为vue 全局安装@vue/cli时发生了什么？ 答：先把@vue/cli下载到/usr/local/lib/node_modules中，然后根据@vue/cli下的package.json，根据bin中的定义去/usr/local/bin/下去定义@vue/cli的软连接vue 执行vue命令时发生了什么？为什么vue指向一个js文件，我们却可以直接通过vue命令去执行它？ 答：1.终端在环境变量中找vue指令（相当于which vue命令），看有没有被注册，未注册则返回command not found,注册了则去找vue指令软连接指向的地址/usr/local/lib/node_modules/@vue/cli/bin/vue.js，去执行vue.js文件中的代码 ​ 2.因为这个js文件的顶部写了#!/usr/bin/env node,标识在环境变量中查找node，告诉系统使用node去执行这个js文件 脚手架原理进阶 为什么说脚手架本质是操作系统的客户端？它和我们在PC上安装的应用/软件有什么区别？ 1.node在window中是一个node.exe，在Mac中是一个可执行文件（node*）,因为node是操作系统的一个客户端，脚手架的本质是通过node去执行js文件，所以也可以说脚手架的本质是操作系统的客户端。 2.本质来说没有区别，PC安装的应用只是提供了一个GUI，脚手架是通过命令的形式 如何为node脚手架命令创建别名？ 进入/usr/local/bin目录 ln -s ./imooc-test-cai imooc-test-cai2 描述脚手架命令执行的全过程。 脚手架开发流程 开发流程 创建npm项目 创建脚手架入口文件，最上方添加： #!/usr/bin/env node 配置package.json，添加bin属性 编写脚手架代码 将脚手架发布到npm 使用流程 安装脚手架 npm install -g your-own-cli 使用脚手架 your-own-cli 脚手架开发难点解析 分包：将复杂的系统拆分成若干个模块 命令注册：例 vue create vue add vue invoke 参数解析： vue command [options] options全称：--version、--help options简写：-V、-h 带params的options：--path /Users/caimengxin/Desktop/vue-test 帮助文档： global help Usage Options Commands 示例：vue的帮助信息： Usage: vue [options] Options: -V, --version output the version number -h, --help output usage information Commands: create [options] create a new project powered by vue-cli-service add [options] [pluginOptions] install a plugin and invoke its generator in an already created project invoke [options] [pluginOptions] invoke the generator of a plugin in an already created project inspect [options] [paths...] inspect the webpack config in a project with vue-cli-service serve [options] [entry] serve a .js or .vue file in development mode with zero config build [options] [entry] build a .js or .vue file in production mode with zero config ui [options] start and open the vue-cli ui init [options] generate a project from a remote template (legacy API, requires @vue/cli-init) config [options] [value] inspect and modify the config outdated [options] (experimental) check for outdated vue cli service / plugins upgrade [options] [plugin-name] (experimental) upgrade vue cli service / plugins migrate [options] [plugin-name] (experimental) run migrator for an already-installed cli plugin info print debugging information about your environment Run vue --help for detailed usage of given command. 还有很多，比如： 命令行交互 日志打印 命令行文字变色 网络通信：HTTP、WebSocket 文件处理 等等...... 脚手架本地link标准流程 链接本地脚手架： cd your-cli-dir npm link 链接本地库文件： cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件： cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解npm unlink： npm link your-lib：将当前项目中的node_modules下指定的库文件链接到node全局node_modules下的库文件 npm link：将当前项目链接到node全局node_modules中作为一个库文件，并解析bin配置创建可执行文件 理解npm unlink： npm unlink：将当前项目从node全局node_modules中移除 npm unlink your-lib：将当前项目中的库文件依赖移除 原生脚手架开发痛点分析 痛点一：重复操作 多Package本地link 多Package依赖安装 多Package单元测试 多Package代码提交 多Package代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互依赖版本升级 package越多，管理复杂度越高 Lerna简介 Lerna is a tool that optimizes the workflow around managing multi-package repositories with git and npm. Lerna是一个优化基于git+npm的多package项目的管理工具 优势 大幅减少重复操作 提升操作的标准化 Lerna是架构优化的产物，它揭示了一个架构真理：项目复杂度提升后，就需要对项目进行架构优化。架构优化的主要目标往往都是以效能为核心。 官网 官网：https://lerna.js.org/ 案例 使用Lerna管理的大型项目： babel：https://github.com/babel/babel vue-cli：https://github.com/vuejs/vue-cli create-react-app：https://github.com/facebook/create-react-app lerna开发脚手架流程（重点） Lern使用细节（重点） lerna init: 会自动完成git初始化，但不会创建.gitignore文件，这个必须要手动添加，否则会将node_modules目录都上传到git，如果node_modules已经加入到git stage，可使用： git reset HEAD 执行unstage操作，如果文件已经被git监听到变更，可使用： git checkout -- 将变更作废，记得在执行操作之前将文件加入：.gitignore lerna add： 第一个参数：添加npm包名 第二个参数：本地package的路径 选项： --dev：将依赖安装到devDependencies，不加时安装到dependencies lerna add [loc] --dev lerna link： 如果未发布上线，需要手动将依赖添加到package.json，再执行npm link lerna clean： 只会删除node_modules，不会删除package.json中的依赖 lerna exec和lerna run： --scope属性后添加的是包名，而不是package的路径，这点和lerna add用法不同 lerna publish 发布时会自动执行：git add package-lock.json，所以package-lock.json不要加入.gitignore文件 先创建远程仓库，并且同步一次master分支 执行lerna publish前先完成npm login 如果发布的npm包名为：@xxx/yyy的格式，需要先在npm注册名为：xxx的organization，否则可能会提交不成功 发布到npm group时默认为private，所以我们需要手动在package.json中添加如下设置 \"publishConfig\":{ \"access\":\"public\" } yargs使用 #! /usr/bin/env node const yargs = require('yargs') const dedent = require('dedent') const pkg = require('../package.json') const cli = yargs() const argv = process.argv.slice(2) const context = { imoocVersion: pkg.version } cli // 配置 第一行的使用提示 .usage('Usage: imooc-cli-cai [command] ') // 配置 提示用户脚手架最少要接收一个命令 .demandCommand(1,'A command is required. Pass --help to see all available commands and options.') // 配置 命令输入错误或者没有此命令的时候可以根据输入推荐合适的命令 .recommendCommands() // 配置 命令错误时执行的方法 .fail((err,msg)=>{ console.log(err) }) // 配置 help和version的别名 .alias('v','version') .alias('h','help') // 配置 终端宽度 .wrap(cli.terminalWidth()) // 配置 尾部的提示文字 .epilogue(dedent` when a command fails,all logs are written to lerna-debug.log in the current working directory. For more information,find our manual at https://github.com/lerna/lerna `) // 配置 debug命令 .options({ debug:{ type: \"boolean\", describe: \"Bootstrap debug mode\", alias: \"d\" } }) // 配置 registry命令 .option('registry',{ type: \"string\", describe: \"Define global registry\", alias: 'r' }) // 配置 分组 .group(['debug'],'Dev Options') .group(['registry'],'Extra Options') // 配置 命令，当执行 init [name] 命令的时候一系列的行为 .command('init [name]', 'Do init a project',(yargs)=>{ yargs .option('name',{ type: 'string', describe: 'Name of a project', alias: 'n' }) },(argv)=>{ console.log(argv) }) // 配置 命令的第二种方法 .command({ command: 'list', aliases: ['ls','ll','la'], describe: 'List local packages', builder:(yargs)=>{}, handler: (argv)=>{ console.log(argv) } }) // 配置 严格模式，最后一行提示命令错误，如：无法识别的选项：lis .strict() // 解析参数 .parse(argv,context) lerna原理（还未深入理解） 通过import-local来优先调用本地lerna命令 通过Yargs初始化脚手架，然后注册全局属性，再注册命令，最后通过parse方法解析参数 lerna命令注册时需要传入build和handler两个函数，build用来注册命令专属的options，handler用来处理命令的业务逻辑 lerna通过配置npm本地依赖的方式进行本地开发，具体写法是在package.json中写入：file:your-locale-module-path,在lerna publish的时候会自动替换路径 这一周的从4-8到最后有很多不理解的地方，需要学习了node之后再深入学习 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/凹凸曼/":{"url":"pages/凹凸曼/","title":"凹凸曼","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/凹凸曼/01-Week01-作业.html":{"url":"pages/凹凸曼/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"整体架构设计 V1.0 需求 需求稳定 体验地址 范围 从需求来看，可以简单拆分成以下几个大的模块 B端和编辑器 采用前后端分离，因此可以划分为两个代码仓库 biz-editor-FE biz-editor-server 通过可视化平台拖拽等方式，可以生成作品，然后发布。 C 端 面向用户群体，因此可以高性能(使用SSR)，可以对作品进行分享，提升业务增长。 管理后台 admin-FE admin-server 平台管理，负责作品的审核，发布，以及对用户的管理等待。 独立的组件库 提升开发效率和复用，独立的 npm 包，供编辑器端和H5端使用 统计服务 单独拆分，以报表等形式展示，可以清晰的看到 PV/UV，用户人数活跃度，增长等。 需求关系 模快设计 核心数据结构 单个组件应该使用vnode规范，使用业界统一规范有助于我们少踩一些坑，并能得到扩展性较强的组件结构。vuex store 的大概结构如下： { // 作品 work: { title: '作品标题', setting: { /* 拓展配置： 如配置渠道 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据流转核心 根据组件的位置生成相应的数据结构 JSON，进行入库，然后在 C 端在根据对应的 JSON 对组件进行渲染 扩展性保证 预留一些字段， 后期可能多人协作开发 自定义事件的加入 研发提效 脚手架的搭建，创建发布 组件平台，方便复用 前端开发流程 运维保障 线上服务和运维服务 安全 监控与报警 服务拓展性: 基于云服务,可以随时拓展机器和配置 愿景 保证业务增长，服务于当前的业务。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/凹凸曼/02-Week02-作业.html":{"url":"pages/凹凸曼/02-Week02-作业.html","title":"Week02 作业","keywords":"","body":"脚手架原理和基本搭建 什么是脚手架 脚手架本质是一个操作系统的客户端，它通过命令执行，如： vue create vue-test-app 上面命令由三部分组成 主命令：Vue command:create command 的 parm：vue-test-app 执行此命令后，就会在对应目录下创建一个叫做 vue-test-app 的项目，并自动执行 npm install 按照对应的依赖，通常可以输入下面的命令就可以看到 vue create 支持的所有 options vue create --help 为什么要研发脚手架? 开发脚手架的核心目标就是：提升前端研发效率 在大的开发团队中，提升研发效率是非常有必要的，减少重复操作劳动，统一代码风格和结构。我们通过脚手架讲研发过程： 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚操作 数据化：研发过程系统化、数据化、使得研发过程可量化 脚手架的执行原理 脚手架的执行原理如下： 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command/options vue.js 执行 command 执行完毕退出执行 疑问&#x1F914;️ 为什么全局安装了 @vue/cli 后会添加的命令为 vue? npm install -g @vue/cli 全局安装 @vue/cli 时发生了什么？ 执行 vue 命令时发生了什么？为什么 vue 指向一个 js 文件，我们却可以通过 vue 命令去执行? 带着问题我们来一一刨析! 这里以我本地 create-react-app 脚手架为演示，在执行命令时，终端首先会执行如下命令进行查找： which create-react-app 如图，可以看到在环境变量 /usr/local/bin 目录下创建一个了叫做 create-react-app 的软链接 OK，现在让我们进入到对应的目录，看看 在对应目录下我们看到了 create-react-app 项目的目录结构，查看 pack.json 的 bin 属性，发现如下 \"bin\": { \"create-react-app\": \"./index.js\" }, 同样 @vue/cli 也是该原理，到此，我们就可以回到前面两个问题。 在全局安装 @vue/cli 、create-react-app 时，首先会创建一个软链接，然后指向它真是所在的项目目录，通过上面的图可以看到，通过全局安装会被放在 /yarn/global/node_modules/.bin/ 目录下 通过配置文件 pack.json 的 bin 文件，设置命令的名字，如 vue、create-react-app，cli 就会去执行对应的文件。我们打开 create-react-app 对应的 ./index.js 看看，在头部我们发现这么一行代码 #!/usr/bin/env node 这段代码的作用就是在环境变量中查找 node，然后用 node 去执行，到此基本回到了上面三个问题，下面来进阶一下脚手架原理 脚手架原理进阶 为什么说脚手架的本质操作系统的客户端?它和我们在PC上安装的应用/软件有什么区别？ 如何为 Node 脚手架创建别名？ 我们知道编写的脚手架JS 文件，必须在 Node 环境中运行，我们找到安装 Node 的目录发现，Node 本身就是一个可执行文件，只不过没有 GUI 可视化的操作页面，它和我们在PC上安装的应用本质没有任何区别 可以通过创建软链接的方式给脚手架创建别名 ln -s ./create-react-app create-react-app2 新起的名字叫做 create-react-app2 会指向 create-react-app，create-react-app 会指向真实的地方 用一张图总结脚手架执行的全过程. 脚手架开发流程 在之前文章 从零创建自己的脚手架 中实现了一个脚手架的简单搭建和发布，那么有那些难点没有解决呢？ 脚手架开发难点解析 分包：将复杂的系统分开成若干个模块 注册命令 vue add vue create 参数解析 optinos全称：--version、--help options简写：-V、-h 带params的optinos：--path /Users/xikun/Aotu 示例代码: vue commadn [options] 帮助文档 globale help 以 create-react-app 示例： sage: create-react-app [options] Options: -V, --version output the version number --verbose print additional logs --info print environment debug info --scripts-version use a non-standard version of react-scripts --template specify a template for the created project --use-npm --use-pnp -h, --help output usage information Only is required. A custom --scripts-version can be one of: - a specific npm version: 0.8.2 - a specific npm tag: @next - a custom fork published on npm: my-react-scripts - a local path relative to the current working directory: file:../my-react-scripts - a .tgz archive: https://mysite.com/my-react-scripts-0.8.2.tgz - a .tar.gz archive: https://mysite.com/my-react-scripts-0.8.2.tar.gz It is not needed unless you specifically want to use a fork. A custom --template can be one of: - a custom template published on npm: cra-template-typescript - a local path relative to the current working directory: file:../my-custom-template - a .tgz archive: https://mysite.com/my-custom-template-0.8.2.tgz - a .tar.gz archive: https://mysite.com/my-custom-template-0.8.2.tar.gz If you have any problems, do not hesitate to file an issue: https://github.com/facebook/create-react-app/issues/new 还有很多，比如： 命令行交互 日志打印 命令行文字颜色 网络通信：HTTP/WebSocket 文件处理 等等。。。 原生脚手架开发痛点分析 痛点一：重复操作 多Pageage本地link 多Pageage依赖安装 多Pageage单元测试 多Pageage代码提测 多Pageage代码发布 痛点二：版本一致性 发布时版本一致性 发布后相互依赖版本升级 Pageage 越多，管理复杂度越高 脚手架本地link标准流程 链接本地脚手架 cd your-cli-dir npm link 链接本地库文件 cd your-lib-dir npm link cd your-cli-dir npm link your-lib 取消链接本地库文件 cd your-lib-dir npm unlink cd your-cli-dir # link存在 npm unlink your-lib # link不存在 rm -rf node_modules npm install -S your-lib 理解 npm link npm link your-lib：将当前项目中的 node_modules 下指定的库文件链接到 node 全局 node_modules 下的库文件 npm link：将项目当前链接到 node 全局 node_modules 中作为一个库文件，并解析 bin 配置创建可执行文件 理解 npm unlink npm unlink：将当前项目从 node 全局 node_modules 移除 npm unlink your-lib：将当前项目的库文件依赖移除 Lerna 简介 Learn 是一个优化基于 git + npm 的多 pageage 项目管理的工具，像 bable、vue-cli、create-react-app 都使用 Lerna 进行管理 Lerna 开发脚手架流程 基于Lerna创建脚手架 全局安装 Lerna npm install -g lerna 在项目目录执行 lerna 初始化命令 lerna init 发现会生成一个 lerna.json 文件和 packages 目录，并且为我们初始化了 git 仓库 使用 Lerna 创建一个 package lerna create core lerna create utils 在输入 package 的 name，我们选择使用 npm 包组织管理默认，如 @aotu-cli/core、@aotu-cli/utils 如下图在 npm 上注册一个命令 aotu-cli 的组织，这样我们所有的包文件都在它下面 使用 Lerna 添加依赖 // 给所有package依赖依赖 lerna add loadash // 给指定package依赖依赖 lerna add loadash packages/core 使用 Lerna 移除所有依赖 lerna add loadash 只会删除 node_modules，不会删除 package.json 中的依赖 使用 Lerna 执行所有命令 lerna run test 使用 Lerna 进行批量发布 lerna publish 初次执行会报错，提示告诉我们 执行 git commit ok，首先在 github 上创建工程并链接到本地进行推送，再次执行 lerna publish 告诉我们需要先进行 npm 登陆，我们执行 npm login 进行登陆，输入账户密码，发现又出现新的报错 这个错误是 npm 要求在发布的时候要求设置环境为原地址，执行以下命令 npm config set registry http://registry.npmjs.org 再次执行 lerna publish，又发现报错 这个错误是因为 Lerna 的项目默认都是私有项目，在每个 packages 的 package.json 里面添加配置 \"publishConfig\": { \"access\": \"public\" } 再次执行 lerna publish 如图发布成功，在 npm 进行搜索，找到了我们刚才发布的两个包 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/凹凸曼/03-Week03-作业.html":{"url":"pages/凹凸曼/03-Week03-作业.html","title":"Week03 作业","keywords":"","body":"脚手架核心开发流程 脚手架架构图 gitFlow 脚手架拆分策略 拆分原则 根据模块的功能来拆分： core: 核心模块 命令模块：commands 模型模块：models 工具模块：utils 拆分结果为以下 核心流程：core 命令：commands 初始化 发布 清除缓存 模型层：models Command 命令 Project 项目 Component 项目 Npm 模块 Git 仓库 支撑模块:utils Git 操作 云构建 工具方法 API请求 Git Api 命令执行流程 检测版本号 直接输出当前 package.json 信息 function checkPkgVersion() { log.info('cli', pkg.version) } 检查 Node 版本 获取系统的 Node版本，然后和我们预定的版本进行对比 function checkNodeVersion() { // 获取当前Node版本 const currentVersion = process.version; const lowestVersion = constant.LOWEST_NODE_VERSION; // 比对最低版本号 if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`aotu-cli 需要安装 v${lowestVersion} 以上版本的 Node.js`)) } } 检查是否 root 启动 利用 root-check 来帮忙我们快速实现，如果是 root 启动，会帮我们进行降级 function checkRoot() { // root 启动的目录无法操作，需要进行降级 // sudo 启动 打印就是 0 正常就是 501 const rootCheck = require('root-check') rootCheck() } 检测用户主目录 const userHome = require('user-home') const pathExists = require('path-exists').sync function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前用户主目录不存在，请检查!')) } } 检测入参 根据输入参数是否开启 debug 模式 function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs() } function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL; } 检查环境变量 function checkEnv() { const dotenv = require('dotenv'); const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量', process.env.CLI_HOME_PATH) } function createDefaultConfig() { const cliConfig = { home: userHome }; if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME); } process.env.CLI_HOME_PATH = cliConfig.cliHome; } 检测是否最新版本 async function checkGlobalUpdate() { // 获取最新版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; // 调用 API 拿到所有版本号 const { getNpmSemverVersion } = require('get-npm-info'); // 提取所有版本号，对比那些版本号大于当前版本号 const lastVersion = await getNpmSemverVersion(currentVersion, npmName); // 获取最新版本号，提示用户更新到该版本 if (lastVersion && semver.gt(lastVersion, currentVersion)) { log.warn(colors.yellow(`请手动更新 ${npmName}，当前版本：${lastVersion}，最新版本 ${lastVersion} 更新命令：npm install -g ${npmName}`)) } } Node 支持 Es Module 可以采用 Gulp 进行编译，可以参考 使用 Gulp 对 Node 进行编译 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/凹凸曼/07-Week07-作业.html":{"url":"pages/凹凸曼/07-Week07-作业.html","title":"Week07 作业","keywords":"","body":"需求初步分析 首页 导航条 未登录显示未登录按钮 已登录 显示创建设计、我的作品、还有下拉菜单（个人设置和退出) 展示列表 图片 标题 作者信息和使用人数 Hover 显示创建按钮 搜索 搜索以后有清空按钮 登录 发送验证码 登录、表单验证 模版详情页 展示图片、二维码、作者、标题 使用该模版创建 下载图片 我的作品 作品或者模版列表 编辑 统计 删除 转赠 下载图片 搜索 翻页 编辑器 左组件面板-可以添加到编辑器中的组件类型 文本 图形 形状 。。。 中画布区域-从左侧添加的组件都会呈现到编辑器 点击选中 拖动改变位置、大小 快捷键 右键菜单 右属性编辑面板-可以编辑中间组件的属性以及其他功能 元素属性 图层背景、隐藏显示、锁定解锁、拖动排序 背景设置 顶部保存、发布、预览、设置 点击保存 点击预览、弹框 左侧显示预览 右侧设置标题、描述和头图 发布-弹框 左侧显示截图 右侧显示默认渠道、并且可以进行编辑 其他-不属于界面上的一些功能（定时保存、退出提示等等） 项目难点分析 核心问题：编辑器和h5页面整体就是一系列元素组成的，自然而然就应该抽象成组件，但是组件的 属性 应该如何设计、Scheml 如何维护 组件的可扩展性 编辑器的核心功能其实就是对组件增删改查的操作，如何设计编辑器整体的状态 组件有多种，它的属性也有多种。怎么将这些属性渲染成不同的表单组件、在表单组件中、属性作出修改后、怎样实时的将值反射到组件中 编辑器有很多交互：拖动移动位置、大小、快捷键、右键菜单、缩放、重做/回滚、等等功能。他们都是核心之外的交互，那么很自然，如何把这些功能进行结偶。 业务组件库 对于上面的需求、我们有必要搭建自己的组件库、然后定义一系列特有的组件属性。 组件属性设计 组件属性大体可以分为两类：公共属性 和 特有属性，可以参考 属性 组件扩展性问题 组件在业务组件库中是没有任何问题的，这里说的扩展性是指如何在编辑器中对它进行适配，包括展示和编辑的适配。这个我们可以在编辑器中再去思考 编辑器难点解决方案 首先编辑器的设计大体如下： 左侧：组件模版库 画布 右侧属性设置 整体状态设计 编辑器其实就是围绕中间画布的元素进行一系列的操作、那么自然就是一系列的元素组件组成、我们可以把它抽象成一系列特定的数据结构 export interface EditorStore { // 供中间编辑器渲染的数组 components: ComponentData[]; // 一系列和其他状态相关的信息，应该有很多 // 当前编辑的是哪个元素，uuid currentElement: string; } interface ComponentData { // 每个元素 props 所有属性 // 我们上节课已经分析过了，是 css 属性和其他属性的混合体 // 并且我们会把这些属性完全平铺开来，其实在编辑器分析过后，你就能更感受到平铺的一个好处 props: { [key: string]: any }; // id，uuid v4 生成 id: string; // 业务组件库名称 l-text，l-image 等等 name: string; } 场景设计 将元素渲染到画布 使用 store 中 components 数据进行循环渲染 compoents.map(component => ） 渲染左侧预设组件模版 我们可以维护一个服务信息、每次拉取最新的组件。这些组件都有一个点击事件，我们可以添加 一层 wrapper 来解决，这样可以做到和内部组件隔离，互不影响 compoents.map(component => ） 添加删除组件 其实就是操作 store 中的数据即可 // 添加 components.push({type: '', props: {} }) // 删除 components = components.filter((component) => component.id !== id) 将属性映射到全部表单 用一张图来表示流程 现在我们以及完成了数据到画布的第一步、接下来就是点击画布中的某个属性需要把该组件的属性映射到右侧的表单中。 一个很容易想到的把直接表单组件写死到页面中 const currentComponentProps = { text: '123', color: '#fff' } ... 缺点： 代码冗长 对不同类型组件都需要判断 可扩展性很差 看到界面展示、我们可以想到，界面UI就是数据的抽象，所以我们可以使用特定的数据结构将它渲染成页面 const textComponentProps = { text: 'hello', fontFamily: 'HeiTi', color: '#fff' } const propsMap = { text: { component: 'input' }, fontFamily: { component: 'dropdown', }, color: { component: 'color-picker' } } // 这里我们还是循环所有属性，在每个属性中渲染对应处理这个属性的组件 map(textComponentProps, (key, value) => { }) 当没有遇到类型 Form 组件时候,我们可以进行二次开发，只要这个组件有对应 value 属性 在一定程度上满足了可扩展性，组件的属性可以扩展，对于 color 属性，我们可以二次开发一个 拾色器 组件,只需要传入 value 属性即可 我们的数据自始保持从上到下，也就是说在 Form 操作变更了数据最终还是要回到 store 中的。很明显，我们右侧表单在修改时，每个都对应有自己的 onChange 事件，我们就可以知道是那个组件、那个属性变化了，我们就去更新对应的属性值即可，这样 store 发生变更、数据流就完成了。 map(textComponentProps, (key, value) => { const handleChange = (propKey, newValue, id) => { const updatedComponent = store.components.find(component.id === id) updatedComponent.props[propKey] = newValue } } 除了上面表单的更新，中间的画布交互更新，也是一样原理。比如说我们发生拖动位置，对应就是发生 onChange 事件去更改 store 里面的值。这里需要注意的是我们在外层添加一层 Wrapper 组件，各种事件都是放在这个上面，比如拖动、改变位置后发生 onChange 事件 对于复杂组件也是如此，不管你内部逻辑有多么的复杂，添加上传图片、删除、编辑、最终发出去事件的值就是对 picture 值的变化 画布操作插件化 比如快捷键操作，它只写成普通的可重用的函数即可，在回调中，我们就可以对全局 store 进行一系列的改写，而快捷键这个功能和编辑器是没有任何关系的。 总体架构 技术栈：Vue3+TS 打包工具：vie-cli + rollup 组件库：自定义组件库 + ant-design-vue 持续集成：Travis Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/刘鲲/":{"url":"pages/刘鲲/","title":"刘鲲","keywords":"","body":"学习任务，作业、打卡、分享。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/前端菜鸟/":{"url":"pages/前端菜鸟/","title":"前端菜鸟","keywords":"","body":"作业 第一周作业：技术方案设计文档 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/前端菜鸟/1、第一周作业.html":{"url":"pages/前端菜鸟/1、第一周作业.html","title":"1、第一周作业","keywords":"","body":"技术方案设计文档 需求 xxx 范围 前端编辑器 用于创建发布作品分享等 开发方式：前后端分离 h5 ssr 对性能考虑，采用ssr 后台管理 用于管理h5内容、 数据分析等 开发方式：前后端分离 模块设计 前端编辑器、后台管理和h5可以共用一个服务端。 前端编辑器和具有相同的样式，将相同样式业务部分独立拆分成共用的组件，方便维护 数据结构 这个项目可以采用vue+vuex或react+redux实现 store中的数据格式 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 props: {}, // 页面的一些信息，如背景等 components: [ //vnode格式 { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] }, activeComponentId:0//当前选中组件的索引 } 拓展一个图层可以通过计算属性获得当前选中的的图层组件，而不是新创建一个数据。这样做可以减少数据冗余 拓展性 扩展组件，页面数据结构 扩展编辑器功能，如隐藏、锁定等 扩展页面配置 开发提效 前端工程化 使用脚手架创建项目、自动化部署项目、规范代码 组件管理 使用脚手架工具管理发布组件库运维保障 线上服务和运维保障 出错后代码可快速回滚 安全 防止xss攻击和csrf攻击 使用https 密码等敏感信息加密 监控和报警 发送短信等给管理员 服务拓展性 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/十三/":{"url":"pages/十三/","title":"十三","keywords":"","body":"十三 - 学习记录 Week01 Week01-作业-整体架构设计 V1.0 第二周作业与笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/十三/01-Week01-作业.html":{"url":"pages/十三/01-Week01-作业.html","title":"Week01 作业","keywords":"","body":"《慕课乐高》 整体架构设计 V1.0 项目需求 参见：需求文档 核心功能清单 使用者 功能 B端 模板库 作品管理 编辑器 数据统计 C端 查看作品 分享作品 管理端 用户管理 模板管理 作品管理 数据统计 目标 制定 作品制作>发布>展示 整体架构 为下一步详细方案设计提供依据 范围 根据需求进行整体架构设计，不涉及具体实现。 业务逻辑需自我循环，有始有终，有进有出。 数据流转关系图 模块设计 组件库，独立第三方，同时用于编辑器和H5 因需自定义事件统计，需自研统计服务 扩展性保证 扩展组件 扩展编辑器的功能，例如：组件隐藏、锁定 扩展页面的配置 开发提效 脚手架 组件平台 运维保障 线上服务和运维服务 备份与安全 监控和报警 服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/十三/02-Week02-作业.html":{"url":"pages/十三/02-Week02-作业.html","title":"Week02 作业","keywords":"","body":"脚手架实现原理 为什么全局安装@vue/cli后会添加vue的命令？ npm install -g @vue/cli 查看vue实际文件路径 > which vue /usr/local/bin/vue bin目录下存放的是可执行文件 > cd /usr/local/bin > ll lrwxr-xr-x 1 song admin 39B 12 28 21:48 vue -> ../lib/node_modules/@vue/cli/bin/vue.js 可以看到vue实际是一个软链接，指向：../lib/node_modules/@vue/cli/bin/vue.js 绑定管理在哪里指定的呢？ 进入到@vue/cli安装目录 > cd /usr/local/lib/node_modules/@vue/cli > ll -rw-r--r-- 1 song admin 2.5K 12 28 21:48 package.json 在package.json中有一个bin的配置 \"bin\": { \"vue\": \"bin/vue.js\" }, 这里配置了安装完之后的软链接名称，以及指向的实际文件 全局安装@vue/cli时发生了什么？ npm install -g @vue/cli 第一步：会把@vue/cli下载到node node_modules中 第二步：下载成功后会解析package.json 中的 bin 配置，有这个配置就会创建一个软链接 vue执行一个js文件，为什么可以执行它？ 执行vue命令时，系统会执行which vue在环境变量中找vue的注册并执行文件# 这两条命令执行是等价的 > vue >/usr/local/bin/vue 执行的真实文件是vue对应的软链接：../lib/node_modules/@vue/cli/bin/vue.js 直接执行一个xx.js执行不了的，vue.js又是怎么执行的呢？ js文件需要一个解释器(node)来执行 vue.js源码第一行#!/usr/bin/env node 自己创建一个js文件,test.js中第一行加入此代码，通过 ./test.js也能直接执行。 为什么能直接执行？ 这句话的意思是，告诉系统在环境变量中去找node命令，来执行此文件> /usr/bin/env node # 会将node命令执行起来，与直接执行node是一样的效果 所以./test.js等于 /usr/bin/env node test.js 等于 node test.js chmod 777 test.js 设置文件为可执行文件自定义一条命令 思路：在环境变量中创建一个软链接，执行 test.js即可 (软链接可以嵌套) 在 /usr/local/bin下执行> ln -s /test/index.js #删除软链接 rm 脚手架的开发流程 创建npm项目 创建脚手架入口文件，最上方添加：#!/usr/bin/env node 配置package.json 添加bin属性 编写脚手架代码 将脚手架发布到npm 脚手架开发难点 分包： 将复杂系统拆分成若干个模块 命令注册：vue create vue add vue invoke 参数解析vue command [options] options全称：--version、--help options简写： -V、-h 帮助文档 命令行交互 日志打印 命令行文字变色 网络通信：HTTP/WebSocket 文件处理 .... 理解npm link npm link your-lib：将当前项目中 node_modules 下指定的库文件链接到 node全局node_modules下的库文件 npm link: 将当前项目链接到node全局node_modules中作为一个库文件，并解析bin配置创建可执行文件 理解npm unlink npm unlink：将当前项目从node全局node_modules中移除 npm unlink your-li：将当前项目中的库文件依赖移除 创建一个脚手架 > mkdir cli-test # 创建一个文件夹 > npm init -y # 初始化 cli-test 目录: -- package.json -- bin |-- inde.js index.js 文件: #!/usr/bin/env node console.log('Hello cli') package.json文件： { ... \"main\": \"index.js\", \"bin\": { \"cli-test\": \"bin/index.js\" } } 将脚手架发布到npm > npm login # 登录npm > npm publish # 发布 在cli-test目录下，进行全局安装 npm install -g cli-test 就会建立一个软链接，方便进行本地调试， 通过npm link 也可。 yargs入门 Yargs通过解析参数来帮助您构建脚手架的工具。 通过yargs创建一个最简单的脚手架工具 定义文件index.js #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') const arg = hideBin(process.argv) yargs(arg) .argv 执行 > ./index.js --help 选项： --help 显示帮助信息 [布尔] --version 显示版本号 [布尔] 严格模式: strict yargs(arg) .strict() .argv 加入strict，如果有无法识别的参数，将会给出提示 用法提示: usage yargs(arg) .usage('Usage: test [command] ') .strict() .argv 使用--help将会打印出使用信息 > ./index.js --help test [command] 选项： --help 显示帮助信息 [布尔] --version 显示版本号 最少输入的command个数: demandCommand yargs(arg) .usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .argv 设置command别名: alias yargs(arg) .usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') //-h 和 --help 效果一样 .argv 设置输出内容的宽度: wrap const cli = yargs(arg) cli.usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') .wrap(cli.terminalWidth()) // terminalWidth返回当前窗口的宽度 .argv 设置结尾显示的内容: epilogue cli.usage('Usage: test [command] ') .demandCommand(1, '最少输入一个参数') .strict() .alias('h', 'help') .wrap(cli.terminalWidth()) .epilogue('结尾显示的话') .argv 为全局command添加选项: options cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { // 添加的选项名 type: 'boolean', describe: 'debug mode', alias: 'd' // 别名 } }) .argv // options('name', {}) 一个一个设置的用法 执行效果 > ./index.js -h Usage: test [command] 选项： --version 显示版本号 [布尔] -d, --debug debug mode [布尔] -h, --help 显示帮助信息 [布尔] 将选项分组: group cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { type: 'boolean', describe: 'debug mode', alias: 'd' } }) .group(['debug'], 'Dev Options:') .argv 执行效果 > ./index.js -h Usage: test [command] Dev Options: -d, --debug debug mode [布尔] 选项： --version 显示版本号 [布尔] -h, --help 显示帮助信息 [布尔] 命令纠错提示：recommendCommands() 会根据当前输入的command去找最相似的进行提示 自定义错误信息: fail((err,msg) => {...}) dedent库 去除每行顶部空格，方便多行字符串的输出 const dedent = require('dedent') console.log(dedent` 第一行， 第二行 `) // 将会订购显示输出 /** 第一行， 第二行 */ 自定义命令 官方示例 #!/usr/bin/env node const yargs = require('yargs/yargs') const { hideBin } = require('yargs/helpers') yargs(hideBin(process.argv)) .command( 'serve [port]', // serve 脚手架后面输入的名，[port]定义的option 'start the server', // 描述 (yargs) => { //builder，在执行这个command之前做的事情 yargs .positional('port', { describe: 'port to bind on', default: 5000 }) }, (argv) => { // handler，执行comand 的行为 if (argv.verbose) console.info(`start server on :${argv.port}`) serve(argv.port) } ) .option('verbose', { alias: 'v', type: 'boolean', description: 'Run with verbose logging' }) .argv 自定义 cli.usage('Usage: test [command] ') .alias('h', 'help') .options({ debug: { type: 'boolean', describe: 'debug mode', alias: 'd' } }) .group(['debug'], 'Dev Options:') .command('init [name]', '初始化的命令', (yargs) => { yargs.option('name', { type: 'string', describe: 'init的option', alias: 'n' }) }, (argv) => { console.log(argv) }) .argv 执行效果 > ./index.js init { _: [ 'init' ], '$0': 'index.js' } > ./index.js init -h ndex.js init [name] 初始化的命令 Dev Options: -d, --debug debug mode [布尔] 选项： --version 显示版本号 [布尔] -n, --name init的option [字符串] -h, --help 显示帮助信息 [布尔] 使用对象方式定义 ... .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'list 的描述', builder: (yargs) => { }, handler: (argv) => { console.log(argv) } }) .argv parse 解析命令参数，合并传入的参数，合并完作为一个新的参数注入到脚手架中 #!/usr/bin/env node const yargs = require('yargs/yargs') const pkg = require('../package.json') const argv = process.argv.splice(2) const context = { testVersion: pkg.version } yargs() .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'list 的描述', builder: (yargs) => {}, handler: (argv) => { console.log(argv) } }) .parse(argv, context) 执行效果 > ./index.js list { _: [ 'list' ], testVersion: '1.0.5', '$0': 'index.js' } Lerna初始化过程 npm本地包引用方法 除了npm link 还可以通过file: @lerna/global-options:\"file:../global-options\" Lerna创建发布流程 项目初始化 > mkdir my-cli-dev # 创建项目文件 > npm init -y # 在项目目录下初始化 > npm i -g lerna # 全局安装lerna > lerna init # 初始化 创建package > lerna create core # package name 为 @my-cli-dev/core > lerna create utils # package name 为 @my-cli-dev/utils package.json中name为@my-cli-dev/core这种方式，my-cli-dev则为组织名称，需要在npm上创建一个对应的组织，可以避免名字的重复。若包发布不上去检查下这个组织是否已经建立。 core/package.json 中dependencies 添加@my-cli-dev/utils的依赖。 通过lerna link链接到本地库 发布前的准备 1、创建git仓库 > git remote add origin https://xx/cli.git # 添加仓库的链接 # 代码提交到仓库 > git add . > git commit -m 'init' > git push origin master --set-upstream 2、需要npm login 3、根目录下添加LICENSE.md文件 4、package.json中添加publishConfig设置为公有库 发布 > lerna publish 错误问题 lerna ERR! E403 [no_perms] Private mode enable, only admin can publish this module 出现原因：使用的是淘宝源cnpm,登陆到的是cnpm 解决方法：切换到npmjs的网址，代码如下 npm config set registry http://registry.npmjs.org/ 切换过去之后记得npm login import-lcoal执行流程 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/夏宇sunshine/01-week01-技术方案设计文档.html":{"url":"pages/夏宇sunshine/01-week01-技术方案设计文档.html","title":"Week01 技术方案设计文档","keywords":"","body":"技术方案设计文档 需求 浅层需求 应用模板通过h5编辑器编辑生成自己的作品 深层需求 作品管理 作品统计 作品发布 范围 整体设计 用例 架构设计 模块设计 模块的拆分和关系图，结果 模块的关键功能，职责等 特殊的模块重点说明 组件库 作品的数据结构 vuex store { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 扩展组件 素材类型扩展 图片 SVG 动图 字体/艺术字体 动画 视频数据结构层面 扩展编辑器功能 例如：组件隐藏、锁定、vnode扩展页面的配置 开发提效 脚手架 CICD Git Flow工作流 DOCKER容器部署/发布部署组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性:QPS 总结 待补充 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/奕初/":{"url":"pages/奕初/","title":"奕初","keywords":"","body":"奕初--学习笔记 整体架构设计 V1.0 02-脚手架开发入门知识 03-脚手架开发流程详解 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/奕初/01-整体架构设计 V1.0.html":{"url":"pages/奕初/01-整体架构设计 V1.0.html","title":"整体架构设计 V1.0","keywords":"","body":"架构方案设计文档 需求背景 https://www.yuque.com/imooc-lego/zlz87z 功能范围 本系统作为多身份应用平台，存在多个身份角色，暂时分为三种角色 分别为： 前台：C端用户使用的 H5 中台：运营人员使用的业务编辑器 平台：管理员使用的管理系统 H5 端（前台） 使用者和用途：C端普通用户，可以对作品进行操作分享。 开发方式：H5 SSR 的方式。 业务端（中台） 使用者和用途：运营人员、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 管理系统（平台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计。 开发方式：前后端分离的方式由 admin-fe + admin-server 构成。 模块设计 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/奕初/02-脚手架开发入门知识.html":{"url":"pages/奕初/02-脚手架开发入门知识.html","title":"脚手架开发入门知识","keywords":"","body":"脚手架开发入门知识 脚手架简介 脚手架本质是一个操作系统的客户端，它通过命令行执行，比如： vue create project 上面这条命令由 3 个部分组成： 主命令: vue command: create (类似向脚手架发送一个请求，让脚手架执行一个动作 ) command 的 param: project 它表示创建一个 vue 项目，项目的名称为 project，以上是最一个较为简单的脚手架命令。 脚手架的执行原理 脚手架的执行原理如下： 在终端输入vue create project 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command / options vue.js 执行 command / options 执行完毕，退出执行 如何开发一个脚手架 这里以 vue-cli 为例 开发一个项目文件，该项目中应包含一个 bin/vue.js 文件，使用npm进行初始化，打开package.json 配置bin字段，创建一个命令，指向bin/index.js； 将这个项目发布到 npm 将 npm 项目上的项目全局安装到 node 的 lib/node_modules 在 node 的 bin 目录下配置 vue 软链接指向 lib/node_modules/@vue/cli/bin/index.js 这样我们使用第一步中bin字段中配置的命令来使用脚手架，如：执行 vue 命令的时候就可以找到 vue.js 进行相关操作 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置去在 node 的安装目录下的 bin 目录下，创建一个软连接，连接到软件包中，软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value， 指向的文件中需要设置 #! /usr/bin/env node 来标识文件执行的方法 为什么全局安装@vue/cli后会添加命令为vue? 因为安装后会自动在node的bin目录下建立vue的软链接文件, 这个软链接文件指向了node/lib/node_modules/@vue对应vue.js。 全局安装 @vue/cli 时发生了什么？ 执行过程如下： 解析执行文件到node/lib/node_modules下 在node/bin目录下创建vue的软链接连接到node/lib/node_modules对应vue.js文件 执行vue命令时发生了什么 参考上面的执行原理 为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？ .主要是 #!/usr/bin/env node 这句话，添加了执行该文件的环境变量。 #!/usr/bin/env node #!/usr/bin/node //第一种是在环境变量种找 node //第二种是直接执行 /usr/bin/ 目录下的 node Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/奕初/03-脚手架开发流程详解.html":{"url":"pages/奕初/03-脚手架开发流程详解.html","title":"脚手架开发流程详解","keywords":"","body":"脚手架开发流程详 开发流程 创建项目，使用npm初始化这个项目 创建脚手架入口文件，第一行写如下代码： #!/usr/bin/env node 配置package.json文件，添加bin属性 编写脚手架代码 将脚手架发布到npm 发布到npm的流程 打开npm的官网,注册一个账号、创建相关的代码组织库； npm login 输入账号、密码和邮箱进行登录； npm publish 将项目发布上去。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/左子穆/":{"url":"pages/左子穆/","title":"左子穆","keywords":"","body":"子穆 --我是一个测试 学习课程目的 了解前端框架设计，方便后软件测试层反推存进更好的与web开发沟通，同时提升自己的前端设计的理解。 （个人非开发，拓展自己知识边界） 札记目录 第一周学习札记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/左子穆/01-自我学习-web第一周札记.html":{"url":"pages/左子穆/01-自我学习-web第一周札记.html","title":"自我学习 Web第一周札记","keywords":"","body":"文档资料：https://www.imooc.com/wiki/weban 技术永远都是要为业务服务 技术是实现业务增长。 架构师： 不要过多的关注细节，要看整体，看范围。 不要确定内容需要调研设计 设计需要考虑复杂度，越简单越好。 以架构师的思考-分析业务需求 项目-浅层需求 项目-深层需求 没有业务场景无需求架构设计，需要有具体解决方案才需要有架构设计。 前端研发流程： 以架构师的思维来分析需求 核心点：需要分析潜在需求，需要全局的把握思维，需要为用户增长负责。 全面、完整、闭环-三个关键点。 参考业务理解能力：设计测试一个h5抽奖界面，你作为主要测试负责人，你会具体思考哪些需求点（常规、隐形），以 测试过程中可能会涉及到前端实现的技术方案。 -需要通过流程图的完善业务--初级架构师。 浅层需求分析 需求指导设计、设计指导开发 深层需求分析 不容易一眼看出来，但却很重要的。 架构师-需要深度理解业务，技术要为业务增长负责。 功能存在必要性，服务业务增长。 业务闭环，其中统计与统计分销很重要，c端方面渠道分销需要着重统计。 架构设计-全局的结构设计 不同角色，基于角色功能列表，每个功能单个闭环。 pm的关系：统一战线，对业务负责。 技术方案设计 ssr的使用场景需要考虑-b端、c端？需要考虑场景toc 可以考虑ssr使用。 前后端代码库设计。 业务组件库？ 画布什么内容映射到c端h5就是什么样子，render 渲染的逻辑需要一致的。（业务组件-独立第三方内容 ，各个模块都是组件进行应用） 统计服务 日常pv/uv,每个页面的访问、uv每个用户的访问 具体事件-需要一定自定义事件。 项目分析与项目之间依赖关系 前端项目 h5ssr项目 后端项目 统计服务-提供openapi内容（面对用户，面对admin） 脚手架 脚手架-创建项目 脚手架-组件 数据结构的设计 数据的存取与抽象内容。 数据存取结构 画布与同步修改 图层？div? 技术方案 阐述自己的思路，流程，处理方案，流程图，数据流，判断逻辑，库表设计。 也是工作内容的产出。 技术方案整体策略 产品需求 范围：整体设计，架构设计，没有细节 模块设计 模块拆分与关系图，结果 模块的关键功能，职责（组件功能） 特殊的模块重点说明 组件库，独立第三方，用于编辑器 自主研发的统计服务 做的数据结构 Vuex的 结构届时 数据结构关系图 扩展性保证 扩展组件，数据结构层面 扩张选编辑器的功能 扩展页面的配置 （可以进行具体讨论操作，集思广益） 开发提效 脚手架 组件平台 运维平台 线上服务检测 安全 监控和报警 服务扩展性；流量大 大厂自己研发，小厂的第三方运维。 作业打卡 http://homework.imooc-lego.com/ 输入/输出。 学习的思考：浅层学习看输入，深层学习涮出。 技术方案的理解 技术方案是必要的，在日常项目管理也是督促完成方案设计，同时有具体方案可以与产品，测试进行沟通学习。 技术方案是沉淀自己思想的途径。 技术实现（业务） h5抽奖为例 从一个架构师思考： 功能完整性：安全设计需要补充。 网站技术方案流程图 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/当那一天来临我/":{"url":"pages/当那一天来临我/","title":"当那一天来临我","keywords":"","body":"当那一天来临我 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/当那一天来临我/01-第一周学习笔记.html":{"url":"pages/当那一天来临我/01-第一周学习笔记.html","title":"第一周学习笔记","keywords":"","body":"第一周学习笔记 学习内容 慕课乐高项目的需求分析和架构设计 学习收获 以架构师思维分析项目需求，要以全局思维分析需求，不用关注具体技术细节，挖掘出项目的深度需求，与PM共舞，对项目的业务可持续增长负责 了解了慕课乐高项目的整体架构设计 明白技术方案文档的重要性总结 以往的工作都是在重复搬砖中度过，还老是抱怨工作内容对技术没有成长，学完本周课程真的是收获很多，并开始给工作中的项目写技术方案文档，画业务流程图，看视频觉得老师操作起来很轻松，也能听明白，但自己动手起来发现其实并不容易，在这方面还要多加练习，学以致用。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/":{"url":"pages/彩笔/","title":"彩笔","keywords":"","body":"彩笔 - 学习分享 学如逆水行舟，不进则退。可我越学越觉得自己离终点越远。 第一周作业 第二周作业 第三周作业 第四周作业 第五周作业 第六周作业 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-01-架构方案设计文档.html":{"url":"pages/彩笔/作业-01-架构方案设计文档.html","title":"作业 01 架构方案设计文档","keywords":"","body":"慕课乐高架构方案设计文档 需求 https://www/yuque.com/imooc-lego/zlz87z 范围 根据需求分化出了三个方面的内容：用户端(前台)、企业端(中台)、后台管理(后台) 用户端(前台) 主要用来展示通过编辑器编辑出来的 H5 海报。 由于 移动端 性能上的局限，所以可以考虑使用 SSR H5-server 企业端(中台) 主要提供可产出H5海报模板的功能，以及一系列相关的功能 biz-editor-fe biz-editor-server 后台管理(后台) 主要用来管理 企业端的用户 以及 海报模板 ，掌控全局 admin-fe admin-server 模块设计 如下图所示 其中因为 用户端 和 企业端都会用到 组件库 所以可以独立出一个组件平台。统计服务由于第三方要么是功能不齐全，要么是性价比很低，因此考虑自研一个统计服务。 核心数据结构 { scene: { name: '场景名称', setting: {}, // 扩展性保证 options: {}, // 扩展性保证 }, components: [ { id: '1', name: '组件名1', type: 'text', attr: { w: 50, h: 50, z: 1, }, options: { value: 'xxx' color: 'red', fontSize: 16 }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } }, { id: '2', name: '组件名2', type: 'image', attr: { w: 50, h: 50, z: 1, }, options: { src: 'xxx.png', alt: 'xxx' }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } } ] } 扩展性保证 保证编辑器未来的扩展性 场景的扩展性 scene: { name: '场景名称', setting: {}, // 扩展性保证 options: {}, // 扩展性保证 } 组件的扩展性 { id: '1', name: '组件名1', type: 'text', attr: { w: 50, h: 50, z: 1, }, options: { value: 'xxx' color: 'red', fontSize: 16 }, formatter: { // 扩展性保证 isShow: '', isControl: '', isLook: '' } }, 开发提效 脚手架组件平台 脚手架 可以开发快速创建 项目 原型的脚手架，来省去配置项目初始化的时间。 可以开发快速发布 项目 上线的脚手架，来省去发布项目的时间 组件平台 搭建业务组件平台，来减少代码的重复率，对业务组件进行抽象，积累业务组件，提升开发效率，减少编写重复代码的时间 运维保障 ... Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-02-脚手架架构设计和框架搭建.html":{"url":"pages/彩笔/作业-02-脚手架架构设计和框架搭建.html","title":"作业 02 脚手架架构设计和框架搭建","keywords":"","body":"脚手架架构设计和框架搭建 脚手架的作用 开发脚手架的核心目标是：提升前端研发效能 脚手架的核心价值 自动化：项目重复代码拷贝/git 操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程系统化、数据化，使得研发过程可量化 和自动化构建工具的区别 不满足需求：jenkins、travis 通常在 git hooks 中触发，需要在服务端执行，无法覆盖研发人员本地的功能，如：创建项目自动挡化、本地 git 操作自动化等 定制负责：jenkins、travis 定制过程需要开发插件，其过程较为复杂，需要使用 java 语音，对前端开发不够友好 入门 脚手架本质上来说，是一个操作系统的客户端。它通过命令行执行： vue create vue-test-app 脚手架的实现原理 通过 npm 全局安装一个 脚手架例如 @vue/cli 后，会解析 package.json 文件中的 bin 配置去在 node 的安装目录下的 bin 目录下，创建一个软连接，连接到软件包中，软连接的名称就是 bin 配置的 key，连接的文件就是 bin 配置的 value，value 指向的文件中需要设置 #! /usr/bin/env node 来标识文件执行的方法 基于 lerna 搭建自己的脚手架并且发布到 npm 安装方法 npm install -g @weilai-cli/core 执行命令 weilai-cli -h 进阶 理解 yargs 常用 API 和 开发流程 const cli = yargs(); // 创建一个基础脚手架 cli // 配置 使用提示 .usage('Usage: weilai-test-cli [command] ') // 配置 脚手架最少要接收一个命令 .demandCommand(1, \"最少需要输入一个命令。 通过 --help 查看所有可用的命令和选项。\") // 配置 命令输入错误的时候可以根据输入 推荐合适的命令 .recommendCommands() // 配置 严格的无法识别的命令也将报告为错误 .strict() // 配置 发生故障时执行的方法 .fail((err, msg) => { console.log(err) }) // 配置 help 和 version 的别名 .alias('h', 'help') .alias('v', 'version') // 配置 容器宽度 .wrap(cli.terminalWidth()) // 配置 收尾的文字 .epilogue( dedent` 哎哟，不错哟！ 小伙汁 ` ) // 配置 gameStart 配置 类型为布尔值，描述是五黑走起，别名是 g .options({ gameStart: { type: 'boolean', describe: '五黑走起', alias: 'g' } }) .option('gameEnd', { type: 'string', // hidden: true, describe: '冲冲冲', alias: 'r' }) // 配置 分组 把 gameStart 分配到 召唤师峡谷 这个组里面 .group(['gameStart'], '召唤师峡谷:') .group(['gameEnd'], '慕课网:') // 配置 命令 当执行 init [name] 命令的时候一系列的行为 .command( 'init [name]', 'Do init a project', (yargs) => { // 子命令 yargs .option('name', { type: 'string', describe: 'Name of aproject', alias: 'n' }) }, (argv) => { // 行为 console.log(argv) } ) // 配置 命令的第二种方法 .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'List local packages', builder: (yargs) => { }, handler: (argv) => { console.log(argv) } }) // 解析参数 .parse(argv, context) 理解 lerna 实现原理 已经忘掉了&#x1F603;准备二刷三刷 import-local 实现原理，理解 require.resolve 实现原理 已经忘掉了&#x1F603;准备二刷三刷 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-03-脚手架核心流程开发.html":{"url":"pages/彩笔/作业-03-脚手架核心流程开发.html","title":"作业 03 脚手架核心流程开发","keywords":"","body":"脚手架核心流程开发 标准 绘制 imooc-cli 脚手架架构设计图 实现 imooc-cli 脚手架准备过程代码 try { checkPkgVersion() checkNodeVersion() checkRoot() checkUserHome() checkInputArgs() checkEnv() await checkGlobalUpdate() } catch(error) { log.error(error.message) } // 检查是否需要全局更新 async function checkGlobalUpdate() { const currentVersion = pkg.version const npmName = pkg.name const lastVersions = await getNpmSemverVersions(npmName, currentVersion) if(lastVersions && semver.gt(lastVersions, currentVersion)) { log.warn('更新提示', colors.yellow( dedent` 请更新 ${npmName} 当前版本: ${currentVersion} 最新版本: ${lastVersions} 更新命令: npm install -g ${npmName}@${lastVersions} `)) } } // 环境变量检查 function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if(pathExists(dotenvPath)) { config = dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量:', process.env.CLI_HOME_PATH) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } process.env.CLI_HOME_PATH = cliConfig['cliHome'] = process.env.CLI_HOME ? path.join(userHome, process.env.CLI_HOME) : path.join(userHome, constant.DEFAULT_CLI_HOME) } // 入参检查 function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs(args) } // debug 模式判断 function checkArgs(args) { log.level = process.env.LOG_LEVEL = args.debug ? 'verbose' : 'info' } // 检查 用户主目录 function checkUserHome() { if(!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登陆用户主目录不存在')) } } // 检查登陆帐号的级别 以及 降级 function checkRoot() { require('root-check')() } // 检查 node 的版本 function checkNodeVersion() { const currentNodeVersion = process.version const lowestNodeVersion = constant.LOWEST_NODE_VERSION if(!semver.gte(currentNodeVersion, lowestNodeVersion)) { throw new Error(colors.red(`weilai-cli 需要安装 v${lowestNodeVersion} 以上版本的 Node.js`)) } log.notice('node', process.version) } // 检查 package 的版本 function checkPkgVersion() { log.notice('cli', pkg.version) } 通过 commander 框架实现一个脚手架，包含自定义 option 和 command 功能 #! /usr/bin/env node const commander = require('commander') const pkg = require('../package.json') // 获取 commander 的单例 // const { program } = commander // 手动实例化一个 commander 实例 const program = new commander.Command() program .name(Object.keys(pkg.bin)[0]) .usage(' [options]') .version(pkg.version) .option('-d, --debug', '是否开启调试模式', false) .option('-e, --env ', '获取环境变量名称', false) // command 注册命令 program .command('clone [destination]') .description('clone a repository') .option('-f, --force', '是否强制拷贝') .action((source, destination, cmdObj) => { console.log('do clone', source, destination, cmdObj.force) }) // addCommand 注册子命令 const service = new commander.Command('service') service .command('start [port]') .description('start service at some port') .action((prot, cmdObj) => { console.log('do server start', prot) }) service .command('stop') .description('stop service') .action(() => { console.log('do server stop') }) program.addCommand(service) // program // .command('install [name]', 'install package', { // executableFile: 'weilai-cli', // // isDefault: true, // // hidden: true // }) // .alias('i') // 高级定制：自定义help信息 // console.log(program.outputHelp()) // console.log(program.helpInformation()) program.helpInformation = () => '' program.on('--help', () => { console.log('your help information') }) program.on('option:debug', () => { console.log('debug') }) program.on('command:*', (obj) => { console.log('未知的命令', obj) const availableCommands = program.commands.map(cmd => cmd.name()) console.log('可用的命令', availableCommands) }) // program // .arguments(' [options]') // .description('test command', { // cmd: 'command to run', // options: 'options for command' // }) // .action((cmd, options) => { // console.log(cmd, 'arguments') // }) program .parse(process.argv) // console.log(program.debug) // console.log(program.env) // console.log(program.opts()) 进阶 通过 webpack 和 原生两种方式实现 node 对 ES Module 的支持 通过配置 webpack 来实现模块化(ES Module)，并且 使用 babel 进行编译，来兼容低版本的 node 设置文件后缀名为 xxx.mjs , node 版本小于 14 需要加上 --experimental-modules 来对 mjs 进行支持 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-04-脚手架命令注册和执行过程开发.html":{"url":"pages/彩笔/作业-04-脚手架命令注册和执行过程开发.html","title":"作业 04 脚手架命令注册和执行过程开发","keywords":"","body":"脚手架命令注册和执行过程开发 weilai-cli 脚手架动态命令执行代码 'use strict'; const cp = require('child_process') const path = require('path') const log = require('@weilai-cli/log') const Package = require('@weilai-cli/package') const SETTINGS = { init: '@weilai-cli/init' } const CHCHE_DIR = 'dependencies' async function exec(...argm) { let storePath, pkg let targetPath = process.env.CLI_TARGET_PATH const homePath = process.env.CLI_HOME_PATH log.verbose('targetPath', targetPath) log.verbose('homePath', homePath) const cmdObj = argm[argm.length - 1] const cmdName = cmdObj.name() const packageName = SETTINGS[cmdName] const packageVersion = 'latest' if(!targetPath) { targetPath = path.resolve(homePath, CHCHE_DIR) storePath = path.resolve(homePath, 'node_modules') log.verbose('targetPath', targetPath) log.verbose('storePath', storePath) pkg = new Package({ targetPath, storePath, packageName, packageVersion }) if(await pkg.exists()) { // 更新 log.verbose('package', '更新') await pkg.update() } else { // 安装 log.verbose('package', '安装') await pkg.install() } } else { pkg = new Package({ targetPath, packageName, packageVersion }) } const rootFile = pkg.getRootFile() if(rootFile) { try { // 当前进程 // rootFile && require(rootFile)(argm) // 子进程 const o = Object.create(null) Object.keys(cmdObj).forEach(key => { if( cmdObj.hasOwnProperty(key) && !key.startsWith('_') && key !== 'parent' ) { o[key] = cmdObj[key] } }) argm[argm.length - 1] = o const code = `require('${rootFile}')(${JSON.stringify(argm)})` const child = spawn('node', [ '-e', code ], { cwd: process.cwd(), stdio: 'inherit' // 这个属性是把子进程的输出流直接挂载到父进程 }) child.on('error', e => { log.error(e.message) process.exit(1) }) child.on('exit', e => { log.verbose('命令执行成功:', e) process.exit(e) }) } catch(err) { log.error(err.message) } } } function spawn(command, args, options) { const win32 = process.platform === 'win32' const cmd = win32 ? 'cmd' : command const cmdArgs = win32 ? ['/c'].concat(command, args) : args return cp.spawn(cmd, cmdArgs, options || {}) } module.exports = exec; // package 'use strict'; const path = require('path') const pkgDir = require('pkg-dir') const fsExtra = require('fs-extra') const npminstall = require('npminstall') const pathExists = require('path-exists') const { isObject } = require('@weilai-cli/utils') const formatPath = require('@weilai-cli/format-path') const { getDefaultRegistry, getNpmLatestVersion } = require('@weilai-cli/get-npm-info') class Package { constructor(options) { if(!options) throw new Error('Package 类的 options 参数不能为空') if(!isObject(options)) throw new Error('Package 类的 options 参数必须是对象') // 路径 this.targetPath = options.targetPath // 存储路径 this.storePath = options.storePath // 名称 this.packageName = options.packageName // 版本号 this.packageVersion = options.packageVersion // 缓存目录的前缀 this.cacheFilePathPrefix = this.packageName.replace('/', '_') } async prepare() { if(this.storePath && !pathExists.sync(this.storePath)) { fsExtra.mkdirpSync(this.storePath) } if(this.packageVersion === 'latest') { this.packageVersion = await getNpmLatestVersion(this.packageVersion) } } // 获取缓存文件的路径 get cacheFilePath() { return path.resolve( this.storePath, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}` ) } getSpecificCacheFilePath(packageVersion) { return path.resolve( this.storePath, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}` ) } // 判断当前 package 是否存在 async exists() { if(this.storePath) { await this.prepare() console.log('cacheFilePath', this.cacheFilePath) return pathExists.sync(this.cacheFilePath) } else { return pathExists.sync(this.targetPath) } } // 安装 package install() { npminstall({ root: this.targetPath, storeDir: this.storePath, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: this.packageVersion }] }) } // 更新 package async update() { await this.prepare() // 1. 获取最新的 npm 模块的版本号 const latestPackageVersion = await getNpmLatestVersion(this.packageName) // 2. 查询最新版本号对应的路径是否存在 const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion) // 3. 如果不存在，则直接安装最新版本 if(!pathExists.sync(latestFilePath)) { npminstall({ root: this.targetPath, storeDir: this.storePath, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: latestPackageVersion }] }) this.packageVersion = latestPackageVersion } } // 获取入口文件 getRootFile() { function _getRootFile(targetPath) { // 1. 获取 package.json 所在的目录 const dir = pkgDir.sync(targetPath) if(dir) { // 2. 读取 package.json const pkgFile = require(path.resolve(dir, 'package.json')) // 3. 寻找 main / bin if(pkgFile && pkgFile.main) { // 4. 路径的兼容 return formatPath(path.resolve(dir, pkgFile.main)) } } return null } return this.storePath ? _getRootFile(this.storePath) : _getRootFile(this.targetPath) } } module.exports = Package; // init 'use strict'; const log = require(\"@weilai-cli/log\") const Command = require('@weilai-cli/command') class initCommand extends Command { init() { this.projectName = this._argv[0] || '' this.force = !!this._cmd.force log.verbose('projectName', this.projectName) log.verbose('force',this.force) } exec() { // init 的业务逻辑 console.log('init 的业务逻辑') } } function init(argv) { return new initCommand(argv) } module.exports = init module.exports.initCommand = initCommand 分析 Node 多进程 execSync/execFileSync/SpawnSync 源码 待更新... Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-05-脚手架创建项目流程设计和开发.html":{"url":"pages/彩笔/作业-05-脚手架创建项目流程设计和开发.html","title":"作业 05 脚手架创建项目流程设计和开发","keywords":"","body":"脚手架创建项目流程设计和开发 完成 weilai-cli 脚手架创建项目流程开发 本期主要是 prepare/准备、downloadTemplate/下载模板 部分的内容 创建功能架构设计 首先安装模板之前，我们需要做一些准备操作，例如：判断目录是否为空、创建的项目类型、以及收集一些必要信息； 其次需要根据选择的项目类型选择下载相应的项目模板； 最后我们需要对下载的模板进行安装操作以及做一些特殊处理。 prepare/准备 首先我们需要获取模板信息，来确认是否有模板可供下载，否则填了半天信息，结果没有模板可以下载岂不尴尬; 然后我们需要判断目标目录是否为空，如果不为空要提示用户是否继续创建，如果继续创建，则要提示用户是否清空目标目录下的所有文件; 然后要求用户输入一些必要的信息，例如：名称、版本号、类型、模板 等 示例代码如下： // 准备阶段 async prepare() { const localPath = process.cwd() // 0. 判断项目模板是否存在 const spinner = spinnerStart('正在获取模板信息...') const template = this.template = await getProjectTemplate() spinner.stop(true) log.verbose('template', template) if(!Array.isArray(template) || template.length === 0) { throw new Error('项目模板不存在') } // 1. 判断当前目录是否为空 if(!this.isCwdEmpty(localPath)) { // 2. 询问是否启动强制更新 let ifContinue if(!this.force) { ifContinue = (await inquirer.prompt({ type: 'confirm', name: 'ifContinue', default: false, message: '当前文件夹不为空，是否继续创建项目？' })).ifContinue // 终止流程 if(!ifContinue) return false } if( ifContinue || this.force ) { // 二次确认 const { confirmDelete } = await inquirer.prompt({ type: 'confirm', name: 'confirmDelete', default: false, message: '是否确认清空当前目录下的文件？' }) if(confirmDelete) { // 清空当前目录 const spinner = spinnerStart('正在清空当前目录...') fsExtra.emptyDirSync(localPath) spinner.stop(true) } } } // 项目的基本信息 return this.getProjectInfo() } // 获取项目信息 async getProjectInfo() { function isValidName(v) { return /^[a-zA-Z]+([-][a-zA-Z][a-zA-Z0-9]*|[_][a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])*$/.test(v) } let projectInfo = {} // 1. 选择创建项目或者组件 const { type } = await inquirer.prompt({ type: 'list', name: 'type', message: '请选择初始化类型', default: TYPE_PROJECT, choices: [ { name: '项目', value: TYPE_PROJECT }, { name: '组件', value: TYPE_COMPONENT} ] }) log.verbose('project class', type) const title = type === TYPE_PROJECT ? '项目' : '组件' this.template = this.template.filter(template => template.tag.includes(type)) const projectPrompt = [ { type: 'input', name: 'projectName', message: `请输入${title}名称`, default: this.projectName ? this.projectName : '', validate: function(v) { const done = this.async() setTimeout(() => { // 1. 首字符必须为英文 // 2. 尾字符必须为英文和数字 // 3. 字符仅允许'-_' if(!isValidName(v)) { return done(`请输入合法的${title}名称`) } done(null, true) }) }, filter: (v) => { return v } }, { type: 'input', name: 'projectVersion', message: `请输入${title}版本号`, default: '1.0.0', validate: function(v) { const done = this.async() setTimeout(() => { if(!sermver.valid(v)) { return done(`请输入合法的版本号`) } done(null, true) }) }, filter: (v) => { if(!!sermver.valid(v)) { return sermver.valid(v) } return v } }, { type: 'list', name: 'projectTemplate', message: `请选择${title}模板`, choices: this.createTemplateChoice() } ] // 2. 获取项目的基本信息 if(type === TYPE_PROJECT) { const project = await inquirer.prompt(projectPrompt) projectInfo = { type, ...projectInfo, ...project } } else if(type === TYPE_COMPONENT) { const descriptionPrompt = { type: 'input', name: 'componentDescription', message: '请输入组件描述信息', default: '', validate: function(v) { const done = this.async() setTimeout(() => { if(!(v)) { return done('请输入组件描述信息') } done(null, true) }) } } projectPrompt.push(descriptionPrompt) const project = await inquirer.prompt(projectPrompt) projectInfo = { type, ...projectInfo, ...project } } if(projectInfo.projectName) { projectInfo.name = require('kebab-case')(projectInfo.projectName).replace(/^-/, '') } if(projectInfo.projectVersion) { projectInfo.version = projectInfo.projectVersion } if(projectInfo.componentDescription) { projectInfo.description = projectInfo.componentDescription } return projectInfo } downloadTemplate/下载模板 首先需要获取到之前收集的各种信息数据，例如：名称、版本、类型、模板; 然后在通过这些数据筛选出 模板的信息 ，并生成 目标、缓存 目录，以及其他配置项信息; 其次创建一个 Package 对象，并且判断 package 是否存在(就是在缓存中是否已经下载了该模板)，如果存在则对 Package 对象进行更新模板的操作，如果不存在则对 Package 对象进行下载操作。 示例代码如下： // 下载模板 async downloadTemplate() { const { projectTemplate } = this.projectInfo this.templateInfo = this.template.find(item => item.npmName === projectTemplate) const targetPath = path.resolve(userHome, '.weilai-cli', 'template') const storePath = path.resolve(userHome, '.weilai-cli', 'template', 'node_modules') const { npmName: packageName, version: packageVersion } = this.templateInfo const templateNpm = this.templateNpm = new Package({ targetPath, storePath, packageName, packageVersion }) // 判断 package 是否存在 let flag = await templateNpm.exists() const spinner = spinnerStart('正在下载模板...') await sleep() try { if(!flag) { // 不存在 安装 await templateNpm.install() } else { // 存在 更新 await templateNpm.update() } } catch (e) { throw e } finally { spinner.stop(true) flag ? log.success('更新模板成功') : log.success('下载模板成功') } } readline 核心元源码分析 待更新... 命令行可交互列表组件开发 命令行可交互列表组件的核心原理是依赖 readline 去开发的; 通过使用 rxjs 监听 keypress 来对命令行中显示的内容进行重绘 示例代码如下： const EventEmitter = require('events') const readline = require('readline') const MuteStream = require('mute-stream') const ansiEscapes = require('ansi-escapes') const { fromEvent } = require('rxjs') const option = { type: 'list', name: 'name', message: 'select your name:', choices: [ { name: 'sam', value: 'sam' }, { name: 'shuangyue', value: 'sy' }, { name: 'zhangxuan', value: 'zx'} ] } function Prompt(option) { return new Promise((resolve, reject) => { try { const list = new List(option) list.render() list.on('exit', (answers) => { resolve(answers) }) } catch (e) { reject(e) } }) } class List extends EventEmitter { constructor(option) { super() this.name = option.name this.message = option.message this.choices = option.choices this.input = process.stdin const ms = new MuteStream() ms.pipe(process.stdout) this.output = ms this.rl = readline.createInterface({ input: this.input, output: this.output }) this.selected = 0 this.height = 0 this.keypress = fromEvent(this.rl.input, 'keypress') .forEach(this.onKeypress) this.haveSelected = false // 是否已经选择完毕 } onKeypress = (keymap) => { const key = keymap[1] if(key.name === 'down') { this.selected++ if(this.selected >= this.choices.length) { this.selected = 0 } this.render() } else if(key.name === 'up') { this.selected-- if(this.selected { if (!this.haveSelected) { let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choice, index) => { if (index === this.selected) { if (index === this.choices.length - 1) { title += '\\x1B[36m❯ ' + choice.name + '\\x1B[39m '; } else { title += '\\x1B[36m❯ ' + choice.name + '\\x1B[39m \\n'; } } else { if (index === this.choices.length - 1) { title += ` ${choice.name} `; } else { title += ` ${choice.name} \\n`; } } }); this.height = this.choices.length + 1; return title; } else { const name = this.choices[this.selected].name; let title = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; return title; } }; render() { this.output.unmute() this.clean() this.output.write(this.getContent()) this.output.mute() } } Prompt(option) .then(answers => { console.log(answers) }) Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-06-脚手架项目和组件初始化开发.html":{"url":"pages/彩笔/作业-06-脚手架项目和组件初始化开发.html","title":"作业 06 脚手架项目和组件初始化开发","keywords":"","body":"脚手架项目和组件初始化开发 完成 weilai-cli 脚手架安装项目/组件功能开发 本期主要是 installTemplate/安装模板 部分的内容 模板安装架构设计 首先安装模板之前，我们需要做一些准备操作，例如：判断目录是否为空、创建的项目类型、以及收集一些必要信息； 其次需要根据选择的项目类型选择下载相应的项目模板； 最后我们需要对下载的模板进行安装操作以及做一些特殊处理。 项目和组件初始化 初始化的时候，首先要判断 type 类型，是标准模板还是自定义模板。然后根据不同的类型执行不同的安装方法。示例代码如下： async installTemplate() { if(this.templateInfo) { if(this.templateInfo.type === TEMPLATE_TYPE_NORMAL) { // 标准安装 await this.installNormalTemplate() } else if(this.templateInfo.type === TEMPLATE_TYPE_CUSTOM) { // 自定义安装 await this.installCustomTemplate() } else { throw new Error('项目模板信息类型无法识别') } } else { throw new Error('项目模板信息不存在') } } 标准安装 标准安装就是按照脚手架的拷贝和渲染流程处理的模板； 首先我们需要确保模板目录和目标目录是否是存在的，如果存在，就从模板目录把模板拷贝到目标目录，并且使用 ejs 进行模板渲染的处理； 最后会为模板进行依赖安装和执行启动命令。 示例代码如下: async installNormalTemplate() { log.verbose('安装标准模板') log.verbose('templateNpm', this.templateNpm) // 拷贝模板代码到当前目录 const spinner = spinnerStart('正在安装模板...') const templatePath = path.resolve(this.templateNpm.cacheFilePath, 'template') const targetPath = process.cwd() await sleep() try { fsExtra.ensureDirSync(templatePath) // 确保目录存在 fsExtra.ensureDirSync(targetPath) // 确保目录存在 fsExtra.copySync(templatePath, targetPath) // 拷贝到 targetPath 目录下 } catch (e) { throw e } finally { spinner.stop(true) log.success('模板安装成功') } const templateIgnore = this.templateInfo.ignore || [] const ignore = ['**/node_modules/**', ...templateIgnore] await this.ejsRender({ignore}) const { installCommand, startCommand } = this.templateInfo let installCmdRet, startCmdRet // 依赖安装 await this.execCommand(installCommand, '依赖安装失败') // 启动命令执行 await this.execCommand(startCommand, '启动命令执行失败') } 自定义安装 自定义安装就是模板自身提供拷贝和渲染流程处理的模板; 首先需要判断 Package 是否存在，如果存在，则获取 rootFilePath 也就是默认的执行文件，一般指向 package.json 里面的 main、bin 的配置; 其次确认该文件是否存在，存在则继续，不存在则终止; 最后通过 spawan 开启一个子进程去执行该文件，并且把收集到的信息组合成一个配置项传入，信息有 targetPath、sourcePath、templateInfo、projectInfo; 示例代码如下： async installCustomTemplate() { log.verbose('安装自定义模板') log.verbose('templateNpm', this.templateNpm) if(await this.templateNpm.exists()) { const rootFile = this.templateNpm.getRootFile() log.verbose('rootFile', rootFile) if(fs.existsSync(rootFile)) { log.notice('开始执行自定义模板安装') const templatePath = path.resolve(this.templateNpm.cacheFilePath, 'template') const options = { targetPath: process.cwd(), sourcePath: templatePath, templateInfo: this.templateInfo, projectInfo: this.projectInfo } const code = `require('${rootFile}')(${JSON.stringify(options)})` await spawnAsync('node', ['-e', code], { stdio: 'inherit', cwd: process.cwd()}) log.success('自定义模板安装成功') } else { throw new Error('自定义模板入口文件不存在！') } } } ejs 渲染模板 模板渲染，如果你经历过前后端没有分离的时代，那么你一定会有了解，例如：php, jsp 等; 简单来说，就是通过一些特殊的标签，对模板进行动态编辑; ejs 标签如下所示： 一般结束标签 -%> 删除紧随其后的换行符 _%> 将结束标签后面的空格符删除 脚手架模板渲染，首先通过 glob 获取目标目录下的所有文件，并且过滤掉一些不需要渲染的文件或文件夹，然后通过循环逐一对每个文件进行渲染，渲染后复写该文件。 示例代码如下： async ejsRender(options) { const cwd = process.cwd() return new Promise((resolve1, reject1) => { glob('**', { cwd: cwd, ignore: options.ignore || '', nodir: true }, (err, files) => { if(err) { reject1(err) } Promise.all(files.map(file => { const filePath = path.join(cwd, file) return new Promise((resolve2, reject2) => { ejs.renderFile(filePath, this.projectInfo, {}, (err, result) => { if(err) { reject2(err) } fsExtra.writeFileSync(filePath, result) resolve2(result) }) }) })).then(() => { resolve1() }).catch(err => { reject1(err) }) }) }) } 命令执行 命令执行的原理依旧是使用 spawn 通过对命令字符串的拆分并且去验证它是否是合法的命令。 示例代码如下： async execCommand(command, errMsg) { if(command) { const cmdOptions = command.split(' ') const cmd = this.checkCommand(cmdOptions[0]) const args = cmdOptions.splice(1) const ret = await spawnAsync(cmd, args, { stdio: 'inherit', cwd: process.cwd() }) if(ret !== 0) { throw new Error(errMsg) } return ret } throw new Error(`命令不存在`) } ejs 和 require 源码学习过程和感悟 吃不下了吃不下了，太顶了，我选择狗带，滑稽脸。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-07-B端项目需求分析和架构设计.html":{"url":"pages/彩笔/作业-07-B端项目需求分析和架构设计.html","title":"作业 07 B端项目需求分析和架构设计","keywords":"","body":"Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-08-前端基础技术回顾和巡礼.html":{"url":"pages/彩笔/作业-08-前端基础技术回顾和巡礼.html","title":"作业 08 前端基础技术回顾和巡礼","keywords":"","body":"前端基础技术回顾和巡礼 TypeScript 基础和进阶 安装 npm install -g typescript 编译 tsc helloworld.ts 数据类型 最新的 ECMAScript 标准定义了 8 中数据类型： 原始类型 Boolean Null Undefined Number Bigint String Symbol Object 类型定义 let a: any = 123 // 所有类型都可以 let b: boolean = false let n: null = null let u: undefined = undefined let num: number = 10 let big: bigint = 10 let s: string = 'text' let sym: symbol = Symbol() let numbers: number[] = [1, 2, 3] let tuple: [string, number] = ['str', 10] function add1(x: number, y: number, z?: number): number { return x + y } const add2 = (x: number, y: number): number => { return x + y } const add3: (x: number, y: number) => number = add2 interface interface | duck typing , 即只要满足它的条件，不管你是什么类型都可以复合条件，详情请看 LikeArray 和 FunctionWithProps interface Person { readonly id: number; // 不可变 name: string; age?: number; } let viking: Person = { id: 1, name: 'UOrb', age: 20 } interface ISum { (x: number, y: number): number } const sum = (x: number, y: number): number { return x + y } cosnt sum2: ISum = sum interface RandomMap { [propName: string]: string; } const test: RandomMap = { a: 'hello', b: 'test', c: 'word' } interface LikeArray { [index: number]: string } // 可以使用数组赋值和通过下标获取值，但是无法访问方法例如：push 等 const likeArray: LikeArray = ['1', '2', '3'] interface FunctionWithProps { (x: number): number; name: string; } const a: FunctionWithProps = (x: number) => { return x } a.name = 'abc' 类和接口 // 类的基本定义 class Animal { // 修饰符三种：public: 公共的; private: 私有的(子类不能访问); protected: 私有的(子类可以访问); public name: string; // private _name: string; // protected __name: string; constructor(name: string) { this.name = name } run() { return `${this.name} is running` } } const snake = new Animal('lily') snake.run() // 继承 class dog extends Animal { bark() { return `${this.name} is barking` } } // 类是合约绑定的效果，类必须要提供实现(implements)的 interface 的属性和方法 // 可以灵活的约定没有联系类之间有共同方法和属性时候的实现 interface ClockInterface { currentTime: number; alert(): void; } // class 有两种类型，一种是 静态类型 一种是 实例类型 // 通过 implements 约定是实例类型 // 想要约定 静态类型 ，需要进行组合约定，如下 interface ClockStatic { new (h: number, m: number): void; time: number; } interface GameInterface { play(): void; } const clock:ClockStatic = class Clock implements ClockInterface { constructor(h: number, m: number): void {} static time = 12 currentTime: number = 123 alert() {} } class CellPhone implements ClockInterface, GameInterface { currentTime: number = 123 alert() {} play() {} } 泛型 function echo(arg: T): T { return arg } function swap(tuple: [T, U]): [U, T] { return [tuple[1], tuple[0]] } interface GithubResp { name: string; count: number; } interface CountryResp { name: string; area: number; population: number; } function withAPI(url: string): Promise { return fetch(url).then(resp => resp.json()) } withAPI('github.user').then(resp => { }) withAPI('country.resp').then(resp => { }) type keys = keyof CountryResp type NameType = CountryResp['name'] type Test = { [key in keys]: any } type Test = { [p in keys]?: CountryResp[p] } // 泛型约束，约束传入的 T 必须要有 length 这个属性 interface IWithLength { length: number } function echoWithArr(arg: T): T { return arg.length } type NnoType = T extends null | undefined ? never : T declare var jQuery: (selector: string) => any type HTTPMethod = 'GET' | 'POST' declare function myFetch (url: string, method: HTTPMethod, data?: any): Promise declare namespace myFetch { const get: (url: string) => Promise; const post: (url: string, data: any) => Promise; } export = myFetch Vue3 新特性的巡礼 新特性： 支持按需引用，大大的减少了打包的体积，以及优化 vnode 的算法减少了计算时间和内存占用。 有了 Composition API 可以对代码的可读性和复用性大大的提高了 作业 clipboard.js 库写类型文件 type Selector = string | Element type OnStatus = 'success' | 'error' interface OnEvent { action: string text: string trigger: Element clearSlection(): void } interface Options { target?: (trigger: Element): Element text?: (trigger: Element): string container?: Element } declare class ClipboardJS { constructor(selector： Selector, options?: Options) on(status: OnStatus, hander: (e: OnEvent ) => void): this destroy(): void } Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩笔/作业-09-项目整体搭建.html":{"url":"pages/彩笔/作业-09-项目整体搭建.html","title":"作业 09 项目整体搭建","keywords":"","body":"研发规范 研发人员须知，重要！！ 项目编码规范 规定项目中锁遵守的编码规范和风格使用 ESLint 进行编码规范的约束 必要的规则合计 在项目中必须使用以下两种规则合集： 'extends': [ 'plugin:vue/essential', 'eslint:recommended', ], 这两个规则集合整好约束了项目对应的两种语言类型：Vue2 文件编码、JS 通用编码规范 规则详情 如果想了解规则的详情，可以参看如下的连接： vue/essential eslint recommended 推荐插件 请使用 vscode 并且安装 eslint、vetur 插件，在编辑器内获取显示错误的能力 推荐的其他规则 按照个人或者团队的医院，可以选择一些扩充的 js 规范作为补充。Airbnb Javascript 编码规范（Github 103k星）Airbnb ESLint 合集：https://www.npmjs.com/package/eslint-config-airbnb规则详情：https://github.com/airbnb/javascript#types 关于 Prettier 的使用 使用 Prettier 对代码进行格式化，但是可能会和 ESLint 有冲突，所以需要进行一些设置才能一起进行良好的工作。 项目文件结构规范 项目文件结构和命名规范如下： /assets （静态文件） common logo.png ... ... /components （所有组件, 使用 Pascal 命名方式） ColorPicker index.vue Dropdown index.vue ... /views （所有路由, 使用 Pascal 命名方式） Home index.vue ... /router （路由配置文件） index.js ... /store （全局 store 配置文件） models editor.js user.js ... index.js getters.js ... /utils （公共方法） index.js ... /layout （布局） index.js Header index.vue Sidebar index.vue ... /mixin common-table-list-mixin.js ... /test （测试文件） ColorPicker.spec.js （使用Pascal命名方式，和组件名称相同，以 spec.ts 结尾） App.vue main.js ... Git Flow 规范 规范采用固定双分支 master and devmaster 作为主分支dev 作为开发分支 创建分支 开发新功能或者修复 bug 之前，要用最新的 dev 分支代码，拉新的分支，然后进行开发。git 分支命名规范如下： master 主干分支，当前正在运行的代码。不可直接往 master 提交代码。 dev 开发分支，当前正在开发、但尚未发布的代码。不可直接往 dev 提交代码，但可以合并其他分支。 server 开发分支，用于部署 server 端功能，不可直接往 server 提交代码，但可以合并其他分支。 feature-xxx 开发新功能 fix-xxx bug 修复 hotfix-xxx 高优紧急 bug 修复，修复完需紧急上线 doc-xxx 仅修改文档，不修改代码 提交 commit 请按照一下步骤提交代码，不要怕麻烦 git status 确认修改的文件，都符合预期 git diff 确认修改的内容，都符合预期 git add . git commit -m \"xxx\" 提交代码，此时会自动进行 eslint 和 prettier 的检查和修复，请耐心等待 注意，在执行 git commit 时，请务必遵守 commit 规范，程序也会强制按照如下格式提交： feat: xxx 新功能 —— 【注意】请务必谨慎使用 feat ，除非真的是新功能，否则不要乱用。 fix: xxx bug 修复 style: xxx 修改样式 docs: xxx 修改文档 refactor: xxx 重构某个功能 test: xxx 增加或修改测试用例 chore: xxx 修改辅助功能（如 webpack eslint 等） perf: xxx 性能优化 release: xxx 发布新版本 revert: xxx 回退 例如，你本次 commit 是修复了一个 bug ，那就执行 git commit -m \"fix: 说明本次修改了哪个 bug\" Commit 信息，杜绝 update，fix bug 这类废话，每次提交必须言之有物，至少要言简意赅的把一次 commit 完成的任务说清楚。 创建 PR（Pull Request） 创建 Pull Request ，将当前分支合并到 dev 分支（不是 master 分支），重要！！ 然后，一定要自己先看一看 PR 的 Files Changed ，看是否符合自己的预期，重要！！如果不符合预期，则把这个 PR 关掉，再重新修改代码，重新提交 PR 。 代码 review 过后即可 merge 重要！！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩色积木/":{"url":"pages/彩色积木/","title":"彩色积木","keywords":"","body":"彩色积木 第一周 01-需求分析和架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/彩色积木/01-第一周笔记和作业.html":{"url":"pages/彩色积木/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求背景 需求文档 范围 整个项目分为三种用户，H5 海报制作人，普通用户，管理员分别对应三端，并且每一类用户使用过程中都能形成一个数据闭环，有输入有输出，具体关系如下： 1.海报制作人 海报制作人通过 B 端制作和修改 H5 海报并进行发布和删除，另外海报制作人也能通过统计服务提供的 OpenAPI 查看产品的使用情况 2.普通用户 普通用户通过查看 H5 海报获得需要的信息，统计服务也通过普通用户查看分享的操作收集了海报制作人制作的海报的使用情况 3.管理员 管理员能通过 后台管理系统管理现有 H5 海报（例如：紧急下线），也可以通过管理后台查看项目的运行情况 模块设计 通过简单的需求分析，大概需要如下几个项目 B 端编辑器，前后端分离 biz-editor-fe biz-editor-server H5 H5 SSR h5-server 后台管理系统 admine-fe admine-server 统计系统 组件库 B 端编辑器 模板列表 用户管理： 登陆、注册 作品的管理：删除、恢复、转赠、复制 作品的统计 作品的发布 H5 分享 —对业务增长负责 查看 后台管理系统 数据统计 作品管理，能快速下线作品，防止有违规内容 用户管理，能快速冻结用户，防止有违规用户 模板管理，能控制哪些模块展示、哪些不展示 统计系统 自研统计服务 支持自定义事件统计 支持 Open API 组件库 独立业务组件库，复用，减少冗余 核心数据结构设计 数据结构思路 每个组件尽量符合 vnode 规范，方便学习和扩展，减少沟通成本 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据流转 创建作品：初始化一个 JSON 数据 保存作品：修改 JSON 发布作品：修改数据中发布状态字段 屏蔽作品：修改数据中某个字段达到紧急下线管理 c 端浏览作品：获取 JSON SSR 渲染 扩展性保证 扩展组件 扩展编辑器功能，如锁定，隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 研发提效 脚手架：创建、发布 组件平台：积累业务组件，提高代码复用，降低维护成本 运维保障 -线上服务和运维服务 -安全 -服务扩展性: 基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/点点/":{"url":"pages/点点/","title":"点点","keywords":"","body":"&#x1F408;点点 - 作业 第一周 01-需求分析和架构设计第二周 02-脚手架架构设计和框架搭建 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/点点/01-需求分析和架构设计.html":{"url":"pages/点点/01-需求分析和架构设计.html","title":"需求分析和架构设计","keywords":"","body":"需求分析 熟悉产品需求 以架构师的思维分析需求，不能只停留在表面实现需求，要考虑怎么实现能给业务带来增长 全局思维、整体思维、闭环思维，不能只考虑自己，要全局考虑整个团队，要做到有输出、有输入、有结果 浅层需求 分析表面需要实现的功能，如登录、创建作品、编辑、发布、访问作品等 深度需求 通过浅层需求分析，进一步分析需求 作品的管理 作品统计 作品发布 h5 后台管理 以上需求还有很多细节点，就不一一阐述 需求分析总览图 架构设计 需要的项目 独立业务组件库 编辑器画布使用的组件和渲染逻辑和h5完全一致，为了两边一致，应该抽离出来提供给它们使用，从而保证制作的时候和渲染出来的h5保持一致 自研统计服务 考虑自研服务前，先列出我们统计所需的功能 我们需要实现分渠道统计这个需求，要实现这个需求，我们就需要自定义事件统计 支持自定义事件统计 支持Open API 经过调研后，我们发现，市面上第三方服务要么不支持，要么收费很贵，综合对比，只能选择自研一个 包括： 日志收集 日志分析 Open API 各个项目之间关系 作品数据结构设计 思路： 每个组件尽量符合vnode规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 vuex store { work: { title: '作品标题', setting: {/* 一些可能的配置项，用不到就先预留 */}, props: {/* 页面body的一些设置，如背景色 */}, components: [ // components要用数组，有序结构 // 单个node要符合常见的vnode格式 { id: 'xxx', // 每个组件都有id，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在children，有时候放在attrs或者props，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null } ] } } vuex getter // 图层 { layers: (state) => { state.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 扩展组件 扩展编辑器功能、如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据分析和计算等 研发效率 脚手架：创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性： 基于云服务，可以随时扩展机器和配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/点点/02-脚手架架构设计和框架搭建.html":{"url":"pages/点点/02-脚手架架构设计和框架搭建.html","title":"脚手架架构设计和框架搭建","keywords":"","body":"1. 脚手架实现原理，基于 Lerna 搭建自己的脚手架并发布到npm 1.1 为什么全局安装 @vue/cli 后会添加的命令为 vue ？ 全局安装脚手架后，会根据脚手架的 package.json 中的 bin 来决定脚手架的命令 \"bin\": { \"vue\": \"bin/vue.js\" }, 当执行vue命令的时候，相当于执行node bin/vue.js 1.2 全局安装 @vue/cli 时发生了什么 首先 npm 下载包文件到 node 安装目录下的 node_modules，然后根据 package.json 文件 bin 属性中配置的命令在 C:\\Program Files\\nodejs 生成一个 vue 文件并注册到环境变量 1.3 执行 vue 命令时发生了什么？为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令去执行它呢？ 因为会在 bin/vue.js 文件头部声明了以下代码 #!/usr/bin/env node 它会告诉系统要用 node 去执行 1.4 已发布到npm脚手架 diao-cli https://www.npmjs.com/package/@diao-cli/core https://www.npmjs.com/package/@diao-cli/utils 2. Yargs 常用 API 和开发流程 const yargs = require('yargs/yargs') // 一个ES6字符串标签，从多行字符串中去除缩进。 const dedent = require(\"dedent\"); const cli = yargs() const argv = process.argv.slice(2) // 注入额外参数 const context = { diaoVersion: '1.0.0', }; cli // 开启严格模式，输入无效命令会报错无法识别命令 .strict() // 在头部输出一段信息 .usage('Usage: diao-cli [command] ') // 设置需要输入命令的最小值，这里设置最少输入一个命令，否则则抛出错误信息 .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") // 如果没有找到匹配的命令，yargs提供关于类似命令的建议 .recommendCommands() // 在有错误的时候执行，可以在这里自定义错误信息 .fail((err, msg) => { console.error('err:', err) }) // 设置 command 的别名 .alias('h', 'help') .alias('v', 'version') // 设置命令行输出时候的宽度 .wrap(cli.terminalWidth()) // 在命令行末尾打印的消息 .epilogue(dedent` When a command fails, all logs are written to lerna-debug.log in the current working directory. For more information, find our manual at https://github.com/lerna/lerna `) // 配置额外选项 .options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) // 配置额外选项 .option(\"registry\", { type: \"string\", describe: 'Define global registry', alias: 'r' }) // 对选项进行分组 .group(['debug'], 'Dev Options') .group(['registry'], 'Extra Options') // 注册命令 .command('init [name]', 'Do init a project', (yargs) => { yargs .option('name', { type: 'string', describe: 'Name of a project', alias: 'n' }) }, (argv) => { console.log(argv) }) // 注册命令 .command({ command: 'list', aliases: ['ls', 'la', 'll'], describe: 'List local packages', builder: (yargs) => {}, handler: (argv) => { console.log(argv) } }) // 解析命令输入参数 .parse(argv, context) 3. Lerna 常用命令和实现原理 Lerna 是基于 git+npm 的多package项目管理工具 3.1 常用命令 初始化 Lerna 项目 lerna init 创建 Package lerna create @diao-cli/core packages 安装依赖 lerna add mocha packages/core --dev 删除依赖 lerna clean 安装依赖 lerna boorstaap 执行单元测试 lerna run test 执行特定包单元测试 lerna run test @diao-cli/core link 项目 lerna link 发布项目 lerna publish 3.2 Lerna 实现原理 （需要二刷三刷） 通过 import-local 优先调用本地 lerna 命令 用过 Yargs 生成脚手架，先注册全局属性，再注册命令，最后通过 parse 方法解析参数 lerna 命令注册时需要传入 builder 和 handler 两个方法， builder方法用于注册命令专属的 options，handler 用来处理命令的业务逻辑 lerna 通过配置 npm 本地依赖的方式进行本地开发，具体写法是在 package.json 的依赖中写入：fill:your-kicak-module-path，在 lerna publish 时会自动将该路径替换 4. 理解 import-local 实现原理， 理解 require.resolve 实现原理 懵逼中，后面回过头再看~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/猛男落泪/":{"url":"pages/猛男落泪/","title":"猛男落泪","keywords":"","body":"猛男落泪 - 作业打卡 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/猛男落泪/01-第二周作业.html":{"url":"pages/猛男落泪/01-第二周作业.html","title":"第二周作业","keywords":"","body":"脚手架实现原理 为什么全局安装@vue/cli后会添加命令为vue 实际注册的命令是package.json中bin配置的 全局安装@vue/cli是发生了什么 npm会查看package.json,如果发现了bin字段就会在全局node_module同级目录创建可执行文件 执行vue命令时发生了什么?为什么vue指向一个js文件,我们却可以直接通过vue命令去执行它 1.在环境变量中寻找vue命令,如果存在就先找到实际的包目录(有可能是软连接)再执行命令入口文件; 2.因为入口js 顶部 声明了使用node去执行,!# /usr/bin/env node; 执行vue命令时传入的第一个参数是node Yargs常用API和开发流程 传递参数: require('yargs/yargs')(process.argv.slice(2)).argv 等价于 require('yargs/yargs')(process.argv.slice(2)).parse() const { hideBin } = require('yargs/helpers'); process.argv.slice(2) 等价于 hideBin(process.argv) 脚手架初始化流程 Yargs() - 构造函数 Yargs.options - 批量注册全局options Yargs.option - 单个注册全局option Yargs.group - 给定options的键值 将其归于一个分组 Yargs.demandCommand - 允许输入的参数最小个数 不满足时报错 Yargs.recommendCommands - 如果找不到匹配的命令 提示类似命令 Yargs.strict - 无法识别命令会报错 Yargs.fail - 所有错误处理函数 Yargs.alias - 为option 指定别名 Yargs.wrap - 为命令行指定宽度 Yargs.epilogue - 再命令行结尾输出信息Yargs.command Yargs.command(command, describe, builder, handler) Yargs.command({ command, describe, builder, handler }) command - 命令字符串 describe - 命令描述 builder - 添加命令的options handler - 命令处理函数,处理具体业务lerna的实现原理 lerna简单说明 lerna是基于git+npm 的多package项目管理工具;主要解决了多包管理的重复操作,操作的标准化,提高了效能; 主要api lerna init初始化项目 lerna create 创建package lerna add 安装依赖 lerna link link包的依赖 lerna publish 发布到npm上 给特定的package执行命令使用filter-options --scope lerna原理 通过import-local优先调用本地项目: lerna中使用微任务执行命令 在全局入口判断有本地lerna项目的情况下会加载本地项目并执行,然后执行宏任务下的代码输出 using local version of lerna 通过yargs生成脚手架 lerna 通过配置package.json本地依赖的方式进行本地开发,写法\"module-name\":'file:your-local-module-path',lerna再发布时会自动替换该路径require.resolve 实现原理 通过Module._resolveFileName 解析文件名 解析出绝对路径;首先调用Module._resolveLookupPaths逐层往上级目录找并拼接/node_modules存到paths数组中返回paths;然后通过Module._findPath找到真实模块路径; Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/落叶无声xcm/":{"url":"pages/落叶无声xcm/","title":"落叶无声Xcm","keywords":"","body":"落叶无声 xcm - 笔记分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/落叶无声xcm/01-week01_学习笔记.html":{"url":"pages/落叶无声xcm/01-week01_学习笔记.html","title":"Week01 学习笔记","keywords":"","body":"慕课乐高架构方案设计文档 需求 需求文档地址 范围 我们通过项目需求分析，一共划分出了五个模块，8 个项目，分别是： 可视化编辑器 前端编辑器 服务端 H5 作品展示页面 项目总后管 前端 服务端 数据统计服务 研发公共部分 脚手架 组建平台 模块设计 作品的数据结构 本项目中，用于描述一个页面所使用的到的数据结构如下： { \"work\": { \"title\": \"作品名称\", \"setting\": {}, // 项目设置，扩展字段 \"props\": {}, // 全局设置 \"components\": [ // 数组 { \"id\": \"组件id\", \"name\": \"组件名称\", \"tag\": \"组件类型\", \"attr\": { // 组件自身属性 \"width\": \"宽\", \"height\": \"高\", \"color\": \"颜色\", ... }, \"props\": { // 组件外部传入的属性或方法 ... }, \"children\": [ ... ] }, ], }, } 扩展性保证 组件扩展 编辑器功能扩展 页面配置扩展 编辑器所支持的项目类型扩展 h5 活动页 PC 官网 PC 后管页 开发提效 脚手架 组建平台 运维保障 监控/报警 错误日志 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/落菣/":{"url":"pages/落菣/","title":"落菣","keywords":"","body":"落菣 - 学习笔记 贵在坚持！ 第一周作业 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/落菣/作业-01-架构方案设计文档.html":{"url":"pages/落菣/作业-01-架构方案设计文档.html","title":"作业 01 架构方案设计文档","keywords":"","body":"技术方案设计文档 需求分析 浅层需求 登录（注册、登录、用户信息保存...） 作品（创建、编辑、发布、作品信息保存、删除作品、获取作品列表...） 访问（生成链接分享） 深层需求 作品（删除与恢复、转赠、复制...） 访问（多渠道分享，分渠道统计） 管理（作品管理，防止违规内容；用户管理，防止违规用户；模板管理，私有公用） 架构设计 项目分析 B端和编辑器 biz-editor-fe biz-editor-server H5 H5-server 管理后台 admin-fe admin-server 独立业务组件 编辑器画布使用的组件和渲染逻辑与H5一致，因此抽离出来 自研统计服务 需求：分渠道统计H5 功能：支持自定义事件统计、支持Open API 自研功能设计：日志收集、日志分析、Open API 项目关系 项目关系如图所示： 数据结构设计 设计思路： 尽量符合VNode规范 有序 当前选中组件 图层依赖于其他值，不是单独的数据 { work: { title: '作品标题', setting:{/*options...*/}, props: {/*页面设置*/}, components: [ { id: 'xxx', //组件id name: '文本1', tag: 'text', attrs: {fontSize: '20px'}, children: [ { name: '文本1' } ] }, { id: 'xxx', //组件id name: '文本2', tag: 'text', attrs: {fontSize: '20px'}, children: [ { name: '文本1' } ] } ] }, activeComponentId: 'xxx' } 扩展性 扩展组件 扩展编辑器功能，如添加动画效果... 扩展页面信息，如增加音频播放 扩展其他功能... 研发提效 脚手架创建发布 组件平台 运维保障 线上服务和运维服务 安全 监控和预警 服务扩展性：基于云服务，可以随时扩展机器和配置。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/诸神の黄昏/":{"url":"pages/诸神の黄昏/","title":"诸神の黄昏","keywords":"","body":"诸神の黄昏 - 笔记分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/诸神の黄昏/01-项目研发流程.html":{"url":"pages/诸神の黄昏/01-项目研发流程.html","title":"项目研发流程","keywords":"","body":"笔记链接的wolai https://www.wolai.com/93avnY9gotFRaErFoSVTNn?theme=light Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/":{"url":"pages/郭二蛋/","title":"郭二蛋","keywords":"","body":"郭二蛋 嗨，你好呀！我是郭二蛋，在慕课网混迹已有4个年头，从免费课到实战课到后来的专栏和微课，已经习惯了在慕课网充电学习，期间也认识了不少小伙伴，他们个个都很有才也很骚~ 这门课就当作是在慕课的毕业课程吧，所以要更加认真学习阿，加油！加油！加油！ 在这里记录一下学习《web前端架构》课程的笔记和作业。 没有人天生爱学习，可是这个世界只要成绩,与君共勉。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/01-第一周笔记和作业.html":{"url":"pages/郭二蛋/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 需求（背景） https://www/yuque.com/imooc-lego/zlz87z 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 普通用户使用的 H5 端（C端） 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 开发方式：H5 SSR 的方式。 企业/作者们使用的 B 端（B端） 使用者和用途：企业、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 平台管理员使用的管理系统（后台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计（统计这部分也会用到第三方，比如百度统计）。 开发方式：前后端分离的方式由 admin-fe + admin-server 构成。 模块设计 如下图所示（初次接触，画的不好，多多海涵） 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余 数据结构示例 { work: { title: '作品标题', setting: {}, // 一些可能的配置项 扩展性保证 props: {}, // 页面的一些设置 扩展性保证 components: [ { id: '1', name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: ['文本1'] }, { id: '2', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '120px' }, children: null } ] } } 数据关系流转 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示 扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算 研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件 运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/02-第二周笔记和作业.html":{"url":"pages/郭二蛋/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"脚手架架构设计和框架搭建 站在前端研发的角度，分析开发脚手架的必要性 脚手架核心价值是将研发过程 自动化：项目重复代码拷贝/git操作/发布上线操作 标准化：项目创建/git flow/发布流程/回滚流程 数据化：研发过程数据化、系统化，使得研发过程可量化 自研脚手架和自动化构建工具的区别 市面上已经有了如Jenkins,travis等自动化构建工具，我们为什么还要自研脚手架？ 不满足需求：jenkins/travis通常需要在git hooks中触发，在服务端执行，无法覆盖研发人员本地的功能，如创建项目自动化，git操作自动化 定制复杂：jenkins/travis等工具的定制过程需要开发插件，要用到Java语言，对前端开发人员并不友好 从使用的角度来理解什么是脚手架 脚手架简介 其实脚手架的实质就是一个操作系统上的客户端。它通过命令行来执行，下面我们用一个常见的例子来举例： vue create project 上面这条看似简单常见的命令实际上由3个部分组成： 主命令：vue command：create command的param：project 这条命令大家应该都很常见了，它表示创建一个vue项目，项目的名字叫project。 脚手架执行原理 脚手架执行原理如下 在终端输入vue create project 终端解析出vue 在环境变量中找到vue命令 终端根据vue命令链接到实际文件vue.js 终端利用node执行vue.js vue.js解析command或者param vue.js执行command 执行完毕，退出执行 从应用的角度看 如何开发一个脚手架 新建一个文件夹（项目）使用npm进行初始化，打开package.json 配置bin字段，创建一个命令，指向bin/index.js； 将这个项目发布到npm； 全局安装这个脚手架； 使用第一步中bin字段中配置的命令来使用脚手架即可。 脚手架开发流程详解 开发流程 创建项目，使用npm初始化这个项目 创建脚手架入口文件，第一行写如下代码：#!/usr/bin/env node 配置package.json文件，添加bin属性 编写脚手架代码 将脚手架发布到npm 使用流程 安装脚手架：npm install -g imooc-test-erdan 使用脚手架：imooc-test-erdan / imooc-test-erdan -h 把库发布到npm的流程 打开npm的官网,注册一个账号； 打开邮箱，进行验证； npm login 输入账号、密码和邮箱进行登录； npm publish 将项目发布上去。 加深对npm link的使用和理解 新建&连接本地脚手架 mkdir erdan-test cd erdan-test npm init -y mkdir bin cd bin touch index.js npm link 新建本地库文件并在本地脚手架中使用 mkdir erdan-test-lib npm init -y npm link cd erdan-test npm link erdan-test-lib 取消链接本地库文件 cd erdan-test-lib npm unlink cd erdan-test # link存在的情况下执行下面这行 npm unlink erdan-test-lib # link不存在的情况下删除node_modules # 从安装发布到远程仓库上的库文件 npm i -S erdan-test-lib Lerna学习笔记 lerna简介 我们在使用lerna之前，要知道我们为什么要用lerna，我们不妨看看原生开发脚手架存在什么痛点。 重复操作 多package本地link 多package安装依赖 多package代码提交 多package单元测试 多package代码发布 版本一致性 发布时的版本一致性问题 发布后相互依赖版本升级问题 有了上面这些原生开发脚手架的痛点以后，就有了lerna这个优秀的工具。用一句话概述lerna就是一个优化基于git+npm的多package项目的管理工具。 lerna的优势就是可以大幅减少重复操作、提升操作的标准化。 lerna是架构优化的产物，lerna的产生揭示了一个架构真理：项目复杂度提升以后，就需要对项目进行架构优化，架构优化的目的往往都是以效能为核心。 lerna开发脚手架流程图 lerna实操 使用lerna搭建脚手架框架 mkdir tangmen-cli-dev npm init -y npm install -g lerna (// 全局安装) npm install lerna lerna -v ( // 输出版本号说明安装成功) lerna init (// 初始化lerna项目，会创建一个lerna.json) // 经过上面init这一步，会初始化git仓库，再搞一个.gitignore 配置一些不用上传的目录 git remote xxx (// 添加远程仓库) lerna create core (// 创建一个package) lerna create utils(// 又创建了一个package) lerna add (// 批量给两个package都安装依赖) lerna publish (// 发布项目) lerna核心操作 初始化lerna lerna init 创建package lerna create core // 在这一步可以给package起一个别名 为了防止和npm上其它包重名 可以加个前缀@ // 这里要注意的是后面想成功发布这种带前缀的私包的话，需要先在npm上创建一个组织 // 举个栗子：如果你给这个包起的名字叫@tangmen-cli-dev/core // 那你先要建一个叫tangmen-cli-dev的组织 安装依赖 lerna add mocha --dev (// 给所有package都安装) lerna add mocha package/core --dev (给core这个package安装依赖) 清空依赖 lerna clean // 手动从package的package.json中删除依赖 恢复依赖 lerna bootstrap 执行脚本 lerna exec -- rm -rf node_modules (// 在所有package中都执行) lerna exec --scope @tangmen-cli-dev/core --rm -rf node_modules (// 在特定package中执行脚本) 执行 npm script 命令 lerna run test (// 在所有package中都执行) lerna run --scope @tangmen-cli-dev/core test (// 在特定package中执行脚本) 发布项目 lerna publish 学习使用lerna发布项目时候遇到的几个小坑 有没有登录npm tag重复问题 加了@前缀的包默认是private的，要在package.json中改变一下publishConfig 如果发布的是带前缀@的包，一定一定记得要先在npm上穿件一个group package-lock.json不能添加在.gitignore中 作业 已经发布到npm上的简易脚手架 imooc-test-erdan erdan-test-lib @tangmen-cli-dev/core @tangmen-cli-dev/utils 理解Yargs常用API和开发流程 Yargs常用API Yargs.usage(提示脚手架用法) Yargs.strict(开启以后可以报错提示) Yargs.demandCommand(规定最少传几个command) Yargs.recommendCommands(在输入错误command以后可以给你推荐最接近的正确的command) Yargs.alias(起别名) Yargs.options(定义多个option) Yargs.option(定义option) Yargs.fail(错误处理方法) Yargs.group(分组) Yargs.wrap(命令行工具的宽度) Yargs.epilogue(命令行工具底部的提示) Yargs开发流程 脚手架初始化(将process.argv当参数传递给Yargs()) 脚手架命令注册(Yargs.command) 脚手架参数解析(Yargs.parse) 理解lerna实现原理 通过import-local来优先调用本地lerna命令 通过Yargs初始化脚手架，然后注册全局属性，再注册命令，最后通过parse方法解析参数 lerna命令注册时需要传入build和handler两个函数，build用来注册命令专属的options，handler用来处理命令的业务逻辑 lerna通过配置npm本地依赖的方式进行本地开发，具体写法是在package.json中写入：file:your-locale-module-path,在lerna publish的时候会自动替换路径 Node.js模块路径解析流程 Node.js项目模块路径解析是通过require.resolve方法来实现的 require.resolve就是通过Module._resolveFileName来实现的 require.resolve实现原理： Module._resolveFileName核心的3个点: 1.判断是否为内置模块 2.通过Module._resolveLookupPaths生成node_modules可能存在的路径 3.通过Module._findPath查询模块的真实路径 Module._findPath核心流程有4点: 1.查询缓存(将request和paths通过x00合并成cacheKey) 2.遍历paths,将paths与request组成文件路径basePath 3.如果basePath存在则调用fs.realPathSync获取真实路径 4.将真实路径缓存到Module._pathCache(key就是前面生成的cacheKey) fs.realPathSync核心流程有3点: 1.查询缓存（缓存的key为p，也就是上面Module._findPath生成的路径） 2.从左往右遍历路径字符串遇到/时，拆分路径，判断该路径是否为软连接，如果是软连接则查询其真实链接，并生成新路径P，然后继续往后遍历 3.遍历完成得到对应的真实路径，此时会将原始路径original作为key,真实路径保存为value保存到缓存中 require.resolve.paths等价于Module._resolveLoopupPaths,该方法用于获取所有node_modules可能存在的路径 require.resolve.paths的实现原理: 1.如果路径为根目录，直接返回['/node_modules'] 2.否则将路径字符串从后往前遍历，遇见/时，拆分路经，在后面加上node_modules,并传入一个paths数组，直至查询不到/后返回paths数组 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/03-第三周笔记和作业.html":{"url":"pages/郭二蛋/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"脚手架核心流程开发 脚手架整体架构设计 前端开发过程中的痛点和需求分析 痛点 存在大量重复代码的拷贝 协同开发时，分支混乱， 操作不规范，导致耗时 发布上线耗时，会出现各种各样的错误 需求分析 1.通用的组件/模板创建能力 模板支持定制，定制后能发布生效 模板支持快速接入，极低的接入成本 2.通用的项目/组件发布能力 发布过程中自动完成标准的 git 操作 发布完成后自动删除开发分支并创建 tag 发布后自动完成云构建、cdn、域名绑定 发布过程支持测试/正式两种模式 大厂是如何做项目的 自己动手画了一下示意图 git 操作规范 自己动手画了一下示意图 架构设计图 脚手架模块拆分策略 拆包原则 根据模块的功能来拆分： core: 核心模块 utils: 工具模块 commands: 命令模块 models: 模型模块 拆包结果 核心流程：core 命令模块：commands 初始化 发布 清除缓存 模型： models Command 命令 Project 项目 Component 组件 Npm 模块 Git 仓库 支撑层： utils Git 操作 云构建 工具方法 API 请求 Git API core 模块技术方案 core 模块的技术方案主要分为三个阶段，分别是准备阶段、命令注册、命令执行。第三周的课程内容主要是讲准备阶段。 涉及到的技术点 核心库 import-local commander 工具库 fs-extra (用于文件操作，基于 fs 封装的库) dotenv (可以获取到环境变量) semver (比较 package 的版本) root-check (进行 root 降级) user-home (拿到用户主目录) colors (可以在终端当中打印不同颜色的文本) npmlog (打印日志用，可以进行定制) 实现脚手架准备过程 检查版本号 思路：直接引用 package.json 文件，获取其中的 version 字段，打印到终端。注意：这里打印的时候可以使用 console.log，也可以使用 npmlog 这个依赖库。 const pkg = require('../package.json') function checkVersion() { console.log(pkg.version) // or log.info(pkg.version) } 检查 Node 版本 思路： 获取当前的 node 版本，和我们事先预设好的版本进行比对，如果当前版本较低，那么给用户一个提示。 const semver = require('semver') const colors = require('colors/safe') function checkNodeVersion() { // 获取当前的 node 版本 const currentVersion = process.version // 和我们事先预设好的版本进行比对 const lowestVersion = constant.LOWET_NODE_VERSION // 如果当前版本较低，那么给用户一个提示 if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`tangmen-cli 需要安装${lowestVersion}版本及以上的Node.js`)) } } 检查 root 是否启动 思路：这个功能比较简单，事情都让 root-check 这个库帮我们做了，我们只需要引用并且调用一下就可以实现 root 降级，规避掉因为 root 用户带来的一系列权限问题。 function checkRoot() { const rootCheck = require('root-check') rootCheck() } 检查用户主目录 const userHome = require('user-home') const pathExists = require('path-exists').sync function checkUserHome() { if (!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前用户主目录不存在，请检查!')) } } 检查入参 let args function checkInputArgs() { args = require('minimist')(process.argv.slice(2)) checkArgs() } function checkArgs() { if (args.debug) { process.env.LOG_LEVEL = 'verbose' } else { process.env.LOG_LEVEL = 'info' } log.level = process.env.LOG_LEVEL } 检查环境变量的两种实现方式 function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { dotenv.config({ path: dotenvPath }) } createDefaultConfig() log.verbose('环境变量', process.env.CLI_HOME_PATH) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME) } process.env.CLI_HOME_PATH = cliConfig.cliHome } function checkEnv() { const dotenv = require('dotenv') const dotenvPath = path.resolve(userHome, '.env') if (pathExists(dotenvPath)) { config = dotenv.config({ path: dotenvPath }) } config = createDefaultConfig() log.verbose('环境变量', config, process.env.CLI_HOME) } // 创建默认的环境变量配置 function createDefaultConfig() { const cliConfig = { home: userHome } if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME) } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME) } return cliConfig } 检查是否为最新版本 async function checkGlobalUpdate() { // 获取当前用户安装的版本是多少 const currentVersion = pkg.version const npmName = pkg.name // 通过接口请求拿到最新的版本号 const { getNpmSemverVersion } = require('@tangmen-cli-dev/get-npm-info') const latestVersion = await getNpmSemverVersion(currentVersion, npmName) // 拿npm上最新的版本号和本地安装的版本号进行对比，如果前者大于后者，则给用户一个明显的提示 if (latestVersion && semver.gt(latestVersion, currentVersion)) { log.warn( colors.yellow(`请手动更新${npmName}, 当前版本:${currentVersion}, 最新版本: ${latestVersion} 更新命令: npm install -g ${npmName} `) ) } } 本周作业完成情况 绘制脚手架架构设计图（已完成） 实现脚手架准备过程代码（已完成） 通过 commander 实现一个脚手架，包含自定义 option 和 command 功能：npm i -g imooc-test-erdan（已完成） 通过 webpack 和原生两种方式实现 Node 对 ES Module 的支持（已完成） Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/04-第四周笔记和作业.html":{"url":"pages/郭二蛋/04-第四周笔记和作业.html","title":"第四周笔记和作业","keywords":"","body":"脚手架架构优化示意图 脚手架命令动态加载功能架构设计图 本周作业 1.完成tangmen-cli-dev脚手架动态命令执行代码编写 // core/exec/lib/index.js 'use strict'; const cp = require('child_process') const path = require('path') const Package = require('@tangmen-cli-dev/package') const log = require('@tangmen-cli-dev/log') const SETTINGS = { init: '@tangmen-cli-dev/init' } // 缓存目录 const CACHE_DIR = 'dependencies' async function exec() { // 目标目录 let targetPath = process.env.CLI_TARGET_PATH // 用户主目录 const homePath = process.env.CLI_HOME_PATH let storeDir = '' let pkg const cmdObj = arguments[arguments.length - 1] const cmdName = cmdObj.name() const packageName = SETTINGS[cmdName] const packageVersion = 'latest' // 是否执行本地代码 -> 否的话 就执行下面这段逻辑 if (!targetPath) { targetPath = path.resolve(homePath, CACHE_DIR) // 生成缓存路径 // 存储目录 storeDir = path.resolve(targetPath, 'node_modules') log.verbose('targetPath', targetPath) log.verbose('storeDir', storeDir) // 初始化一个Package pkg = new Package({ targetPath, packageName, packageVersion }) // 如果Package存在 if (await pkg.exists()) { // 更新package await pkg.update(); } else { // 安装package await pkg.install(); } } else { pkg = new Package({ targetPath, packageName, packageVersion }) } // 是否执行本地代码 -> 选择是的话 执行下面这段逻辑 // 获取本地代码入口文件 const rootFile = pkg.getRootFilePath(); // 本地代码存在的情况下执行以下逻辑，否则终止执行 if (rootFile) { try { const args = Array.from(arguments); const cmd = args[args.length - 1]; const o = Object.create(null); Object.keys(cmd).forEach(key => { if (cmd.hasOwnProperty(key) && !key.startsWith('_') && key !== 'parent') { o[key] = cmd[key]; } }); args[args.length - 1] = o; // 生成指令执行代码 const code = `require('${rootFile}').call(null, ${JSON.stringify(args)})`; // 启动新进程执行代码 const child = spawn('node', ['-e', code], { cwd: process.cwd(), stdio: 'inherit', }); // 执行产生异常时 打印异常 并终止执行 child.on('error', e => { log.error(e.message); process.exit(1); }); // 执行完毕 正常退出 child.on('exit', e => { log.verbose('命令执行成功:' + e); process.exit(e); }); } catch (e) { log.error(e.message) } } } // windows操作系统spawn执行命令兼容 function spawn(command, args, options) { const win32 = process.platform === 'win32' const cmd = win32 ? 'cmd' : command const cmdArgs = win32 ? ['/c'].concat(command, args) : args return cp.spawn(cmd, cmdArgs, options || {}) } module.exports = exec; // models/package/lib/index.js 'use strict'; const path = require('path') const fse = require('fs-extra') const pkgDir = require('pkg-dir').sync const pathExists = require('path-exists').sync const npminstall = require('npminstall') const {isObject} = require('@tangmen-cli-dev/utils') const formatPath = require('@tangmen-cli-dev/format-path') const {getDefaultRegistry, getNpmLastVersion} = require('@tangmen-cli-dev/get-npm-info') class Package { constructor(options) { // 判断边界情况 如果没有传参 直接提示用户options不得为空 if (!options) { throw new Error('Package类的options参数不能为空') } // 如果参数不是对象的话提示用户options必须是对象 if (!isObject(options)) { throw new Error('Package类的options参数必须是对象') } // package的目标路径 this.targetPath = options.targetPath // 缓存Package的路径 this.storeDir = options.storeDir // package的名字 this.packageName = options.packageName // package的version this.packageVersion = options.packageVersion // package的缓存目录前缀 this.cacheFilePathPrefix = this.packageName.replace('/', '_') } // 准备(预检)阶段 // 如果缓存package的路径目录不存在的话，我们用fs模块创建一个目录 // 如果使用者传进来的版本参数是latest，那么我们就要调取API获取最新版本的信息 async prepare() { if (this.storeDir && !pathExists(this.storeDir)) { fse.mkdirpSync(this.storeDir) } if (this.packageVersion === 'latest') { this.packageVersion = await getNpmLastVersion(this.packageName) } } // 读取缓存路径 get cacheFilePath() { return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${this.packageVersion}@${this.packageName}`); } // 获取指定的缓存路径 getSpecificCacheFilePath(packageVersion) { return path.resolve(this.storeDir, `_${this.cacheFilePathPrefix}@${packageVersion}@${this.packageName}`); } // 判断当前的package是否存在 async exists() { if (this.storeDir) { await this.prepare() return pathExists(this.cacheFilePath) } else { return pathExists(this.targetPath) } } // 安装package async install() { await this.prepare() return npminstall({ root: this.targetPath, storeDir: this.storeDir, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: this.packageVersion }] }) } // 更新package async update() { await this.prepare() const latestPackageVersion = await getNpmLastVersion(this.packageName) const latestFilePath = this.getSpecificCacheFilePath(latestPackageVersion) if (!pathExists(latestFilePath)) { await npminstall({ root: this.targetPath, storeDir: this.storeDir, registry: getDefaultRegistry(), pkgs: [{ name: this.packageName, version: latestPackageVersion }] }) this.packageVersion = latestPackageVersion } } // 获取入口文件的路径 async getRootFilePath() { function _getRootFile(targetPath) { // 1.获取package.json所在目录 const dir = pkgDir(targetPath) if (dir) { // 2.读取package.json const pkgFile = require(path.resolve(dir, 'package.json')) // 3.寻找main/lib if (pkgFile && pkgFile.main) { // 路径的兼容 return formatPath(path.resolve(dir, pkgFile.main)) } } return null } if (this.storeDir) { return _getRootFile(this.cacheFilePath) } else { return _getRootFile(this.targetPath) } } } module.exports = Package 'use strict'; const semver = require('semver') const colors = require('colors/safe') const log = require('@tangmen-cli-dev/log') const LOWEST_NODE_VERSION = '12.0.0' class Command { constructor(argv) { if (!argv) { throw new Error('参数不能为空') } if (!Array.isArray(argv)) { throw new Error('参数必须为数组') } if (argv.length { let chain = Promise.resolve() // 检查node版本 chain = chain.then(() => this.checkNodeVersion()); // 初始化参数 chain = chain.then(() => this.initArgs()); // init业务逻辑 chain = chain.then(() => this.init()); // 执行 chain = chain.then(() => this.exec()); chain.catch(err => { log.error(err.message) }) }) } // 初始化参数 initArgs() { this._cmd = this._argv[this._argv.length - 1] this._argv = this._argv.slice(0, this._argv.length - 1) } // 检查node版本 checkNodeVersion() { const currentVersion = process.version const lowestVersion = LOWEST_NODE_VERSION if (!semver.gte(currentVersion, lowestVersion)) { throw new Error(colors.red(`tangmen-cli 需要安装${lowestVersion}版本及以上的Node.js`)) } } // 交给子类去实现 init() { throw new Error('init必须实现！'); } // 交给子类去实现 exec() { throw new Error('exec必须实现！'); } } module.exports = Command Node多进程源码总结 exec和execFile/fork/spawn的区别？ exec: 原理是调用/bin/sh -c执行我们传入的shell脚本，底层调用了execFile execFile: 原理是执行我们传入的file和args，底层调用了spawn创建和执行子进程，并建立了回调，一次性将所有的stdout和stderr结果返回 spawn: 原理是调用了internal/childprocess，实例化了ChildProcess子进程对象，再调用child.spawn创建子进程并执行命令，底层是调用了child. handle.spawn执行process_wrap中的spawn方法，执行过程是异步的，执行完毕后通过PIPE进行单向数据通信，通信结束后子进程会发起onexit回调，同时Socket会执行close回调 fork: 原理是通过spawn创建和执行子进程命令，采用node执行命令，通过setupchannel创建IPC用于子进程和父进程之间的双向通信 data/error/exit/close回调的区别 data: 主进程读取数据过程中通过onStreamRead发起的回调 error: 命令执行失败后发起的回调 exit: 子进程关闭完成后发起的回调 close: 子进程所有Socket通信端口全部关闭后发起的回调 stdout close/stderr close: 特定的PIPE读取完成后调用onReadableStreamEnd关闭Socket时发起的回调 Node多进程执行阶段总结 补充：在自己电脑上如何配置多个公钥 因为疫情的原因，国际庄现在不让出门，我平时是用公司的电脑进行练习的，这次用自己的电脑来配置公钥，但是遇到一个问题：我们这个仓库是在github的，但是我另一个仓库是在gitee上面存放的，于是我使用现有的账号可以正常拉取、推送到github，但是推送到gitee的时候它告诉我说权限不足。 通过百度得知是有办法解决的，那就是在一台电脑上配置多个ssh-key，经过参考网上的教程，终于调通了，将这次经历记下来，如果你和我有一样的问题，希望能帮到你。 这里偷个懒，将教程的链接直接贴在这里了：https://www.cnblogs.com/popfisher/p/5731232.html 石家庄加油！河北加油！ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/郭二蛋/05-第五周笔记和作业.html":{"url":"pages/郭二蛋/05-第五周笔记和作业.html","title":"第五周笔记和作业","keywords":"","body":"脚手架创建项目流程设计和开发 脚手架项目创建功能架构设计 “凡事预则立，不预则废”。在开始本周的编码工作之前呢，sam 老师一如既往的会给我们讲一下本周我们要做的内容是什么以及架构设计和流程是怎样的，具体来说主要包括了项目创建前准备阶段架构设计和下载项目模板阶段架构设计两个部分。 项目创建前准备阶段架构设计 下载项目模板阶段架构设计 项目基本信息获取功能开发 根据上面我们画的架构设计图来看，在准备阶段我们要做的事情还真不少呢，概括的说就是获取基本信息，而这些信息从哪里来呢？自然是要让使用者告诉我们啦，那这里就有一个非常好用而强大的库帮助我们和使用者交互，它就是 inquirer。在这一小章节中，我们要完成的功能主要有以下几项： 判断当前目录（要运行我们的脚手架命令进行模板安装的那个目录）是否为空 inquirer 的基本用法和常用属性入门、多种交互形式的演示 强制清空当前目录功能开发 获取项目基本信息功能开发 项目名称和版本号的合法性校验 判断当前目录（要运行我们的脚手架命令进行模板安装的那个目录）是否为空 我们这里使用的是 Node.js 提供给我们的文件系统操作模块（fs）。 isDirEmpty(localPath) { let fileList = fs.readdirSync(localPath) // 文件过滤的逻辑 fileList = fileList.filter(file => (!file.startsWith('.') && ['node_modules'].indexOf(file) 强制清空当前目录功能开发 我们要先判断当前目录是否为空，在不为空的情况下我们会使用 inquirer 来询问用户是否要继续创建项目，这里要注意的是 force 参数的获取；但是因为清空文件夹的操作是一个不可逆的操作，我们还是要至少询问一次用户是否确认清空。如果用户确认清空，那我们就会清空当前目录，用到的库是 fs-extra。 const localPath = process.cwd() if (!this.isDirEmpty(localPath)) { // 询问是否继续创建 使用到inquirer这个库 // 如果 用户不是强制更新，那么就要询问用户是否继续创建 let ifContinue = false if (!this.force) { ifContinue = ( await inquirer.prompt({ type: 'confirm', name: 'ifContinue', message: '当前目录不为空，是否继续创建？', default: false }) ).ifContinue if (!ifContinue) { return } } // 不管用户是否是强制更新，最后都会展示这次询问，因为清空当前目录文件是一个非常严谨的操作 if (ifContinue || this.force) { // 做二次确认 const { confirmDelete } = await inquirer.prompt({ type: 'confirm', name: 'confirmDelete', message: '是否确认清空当前目录下的文件？', default: false }) if (confirmDelete) { // 清空当前目录 使用 fse-extra fse.emptyDirSync(localPath) } } } 获取项目基本信息功能的开发 在清空了文件夹以后，我们要询问用户一些基本信息，比如这个项目的名字、版本号以及可能存在的描述信息（组件模板的情况下），将来这些信息都会通过 ejs 模板引擎渲染到 package.json 文件中。 // 声明一个对象用来接收项目信息 最后返回的也是这个对象 let projectInfo = {} // 校验项目名称的正则，封装在一个函数内 function isValidName(v) { return /^[a-zA-Z]+([-][a-zA-Z][a-zA-Z0-9]*|[_][a-zA-Z][a-zA-Z0-9]*|[a-zA-Z0-9])*$/.test(v) } // 默认项目名称是不通过的 let isProjectNameValid = false // 如果用户在输入命令时的名称符合我们的规则 就直接用这个 if (isValidName(this.projectName)) { isProjectNameValid = true projectInfo.projectName = this.projectName } // inquirer获取用户想要下载的是组件模板还是项目模板 const { type } = await inquirer.prompt({ type: 'list', name: 'type', message: '请选择初始化项目类型?', default: TYPE_PROJECT, choices: [ { name: '项目', value: TYPE_PROJECT }, { name: '组件', value: TYPE_COMPONENT } ] }) // 通过条件过滤对应的模板 this.template = this.template.filter((template) => { return template.tag.includes(type) }) const title = type === TYPE_PROJECT ? '项目' : '组件' // 兼容项目和模板两种情况的交互询问 const projectNamePrompt = { type: 'input', name: 'projectName', message: `请输入${title}名称`, default: '', validate: function (v) { const done = this.async() // 1.首字符必须为英文字符 // 2.尾字符必须为英文字符或数字，不能为字符 // 3.字符仅允许“-_” // 4.兼容只有一个字母的情况 setTimeout(function () { if (!isValidName(v)) { done(`请输入合法的${title}名称,例：a1 | a_b_c | a1_b1_c1`) return } // Pass the return value in the done callback done(null, true) }, 0) }, filter: function (v) { return v } } // 这个数组是最后要传给inquirer的参数 const projectPrompt = [] // 如果用户在命令行输入的名称不符合我们的要求，那么我们就将后来用户输入的名称添加到我们的数组中 if (!isProjectNameValid) { projectPrompt.push(projectNamePrompt) } // 除了项目名称以外 我们还要知道用户输入的版本号、选择的模板 projectPrompt.push( { type: 'input', name: 'projectVersion', message: `请输入${title}版本号`, default: '1.0.0', validate: function (v) { const done = this.async() setTimeout(function () { if (!!!semver.valid(v)) { done('请输入合法的项目版本号,例：1.0.0') return } // Pass the return value in the done callback done(null, true) }, 0) return }, filter: function (v) { if (!!semver.valid(v)) { return semver.valid(v) } return v } }, { type: 'list', name: 'projectTemplate', message: `请选择${title}模板`, choices: this.createProjectTemplate() } ) // 如果用户选择的是项目模板 那我们直接将上面的projectPrompt传递给inquirer即可 然后用将所有我们要用到的信息进行拼装，就是我们要的projectInfo if (type === TYPE_PROJECT) { const project = await inquirer.prompt(projectPrompt) projectInfo = { ...projectInfo, type, ...project } } else if (type === TYPE_COMPONENT) { // 如果用户选择的是组件模板，那么我们要在前面的基础上追问一条描述信息 const descriptionPrompt = { type: 'input', name: 'componentDescription', message: '请输入组件描述信息', default: '', validate: function (v) { const done = this.async() setTimeout(() => { if (!v) { done('请输入组件描述信息') return } done(null, true) }, 0) } } projectPrompt.push(descriptionPrompt) const component = await inquirer.prompt(projectPrompt) projectInfo = { ...projectInfo, type, ...component } } // 最后我们对拿到的项目信息进行一些转换 这里在转换项目名称的时候用到了kebab-case这个库，可以帮助我们将驼峰格式的名称转为连字符格式的 // 生成classname if (projectInfo.projectName) { projectInfo.name = projectInfo.projectName projectInfo.className = require('kebab-case')(projectInfo.projectName) } // 生成version if (projectInfo.projectVersion) { projectInfo.version = projectInfo.projectVersion } // 生成description if (projectInfo.componentDescription) { projectInfo.description = projectInfo.componentDescription } // 至此，我们想要的项目基本信息就获取完成了 return projectInfo egg.js + 云 mongodb 快速入门 在看这部分的时候没有感到什么阻力，可能之前学了双越老师、7 七月老师的相关课程吧，做 web server 的时候用了 mongodb 和 mysql 两种数据库，也就没有开通云 mongodb，所使用的是我们自己服务器上安装的 mongodb 数据库，新建了一个数据库；将 egg.js 模板的代码进行一番修改以后就达到了我们课程的效果（改成自己的接口地址，返回我们自己数据库的内容）；最后将服务运行在自己的服务器上面，使用 nginx 进行 7001 端口的转发。 项目模板开发 + 获取项目模板 API 开发 这里的话我上传了一个 vue3 的模板（使用 vue-cli 创建的项目进行了删减）和花裤衩大佬的 vue-element-admin 模板总共两个模板进行测试，对接的是自己服务器的接口，内容比较简单，就不进行记录了。 脚手架项目模板下载功能开发 到了这一步，我们在前面创建的 Package 这个类就派上用场了，会发现我们已经将安装和更新功能都封装好了，直接用就好了，很方便~，如果模板不存在的话，就调用 Package 实例的 install 方法进行安装，如果存在的话，就要调用 Package 实例的 update 方法进行更新。 async downloadTemplate() { const { projectTemplate } = this.projectInfo const templateInfo = this.template.find((item) => item.npmName === projectTemplate) const targetPath = path.resolve(userHome, '.tangmen-cli-dev', 'template') const storeDir = path.resolve(userHome, '.tangmen-cli-dev', 'template', 'node_modules') const { npmName, version } = templateInfo this.templateInfo = templateInfo const templateNpm = new Package({ targetPath, storeDir, packageName: npmName, packageVersion: version }) if (!await templateNpm.exists()) { const spinner = spinnerStart('正在下载模板...') await sleep() try { await templateNpm.install() } catch (e) { throw e } finally { spinner.stop(true) if (await templateNpm.exists()) { log.success('下载模板成功') } this.templateNpm = templateNpm } } else { const spinner = spinnerStart('正在更新模板...') await sleep() try { await templateNpm.update() } catch (e) { throw e } finally { spinner.stop(true) if (await templateNpm.exists()) { log.success('更新模板成功') } this.templateNpm = templateNpm } } } inquirer源码解析 暂时没啃这块，待更新~ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/野火/":{"url":"pages/野火/","title":"野火","keywords":"","body":"野火 web前端架构师学习 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/野火/01-作业-架构设计方案.html":{"url":"pages/野火/01-作业-架构设计方案.html","title":"作业 架构设计方案","keywords":"","body":"慕课乐高架构设计方案 需求文档 https://www.yuque.com/books/share/af79538c-09eb-4ddd-bfb7-599816c233bf 范围 H5 展示 作品编辑发布 后台管理 模块设计 模块拆分 H5：作品展示 B端前端：画布能力，提供作者编辑、发布作品和模板。 B端服务端：给B端前端提供接口服务。 后台管理前端：管理作品和用户，查看数据统计。 后台管理服务：提供后台管理前端相关接口服务。 公共组件库：H5展示的组件和B端作品编辑组件的复用。 统计服务：统计数据以及自定义事件，提供给B端的作品反馈和后台管理的数据量统计。 脚手架：创建/发布项目。 模块关系 数据结构设计 作品数据结构 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，例如是否展示，是否推荐，是否是新的 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容 ] } ] } } 数据流转关系 C端、B端、后台管理共用一个数据库。 新增作品：新建一条json数据。 修改作品：修改json数据。 删除作品：标识json数据删除标记。 发布作品：标识json数据发布标记。 屏蔽作品：标识json数据屏蔽标记。 C端获取作品：获取json,判断作品是否展示。 扩展性 组件扩展 编辑器扩展，如支持音频等。 页面扩展：增加多语言。 作品扩展：增加类型，分析用户作品用途，如贺卡等。 开发提效 脚手架：创建/发布 组件平台 运维保障 线上服务和运维服务 安全、监控和报警 服务扩展性 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/":{"url":"pages/點滴心宇/","title":"點滴心宇","keywords":"","body":"点滴心语 - 作业&笔记 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/01-第一周笔记和作业.html":{"url":"pages/點滴心宇/01-第一周笔记和作业.html","title":"第一周笔记和作业","keywords":"","body":"慕课乐高架构方案设计文档 范围 三种角色对应三个方面（平台）：普通用户使用的 H5（前台）、企业或者说 H5 作者们使用的编辑器（中台）、平台管理员使用的管理系统（后台）。 普通用户使用的 H5 端（C端） 使用者和用途：普通用户，也就是作品的受众，可以对作品进行分享，对业务增长负责。 开发方式：H5 SSR 的方式。 企业/作者们使用的 B 端（B端） 使用者和用途：企业、H5 作品的作者们可以在此产出自己的海报作品，也就是可以创建、发布、编辑作品 开发方式：前后端分离的方式由 editor-fe + editor-server 构成。 平台管理员使用的管理系统（后台） 使用者和用途：慕课乐高这个平台的管理员使用的后台管理系统，可以在此对作品进行管理，如用户管理、模板管理、作品管理以及数据统计（统计这部分也会用到第三方，比如百度统计）。 开发方式：前后端分离的方式, 前端 admin-fe + 后端 admin-server 。 模块设计 这张图取自双越老师 核心数据结构 数据结构思路 每个组件尽量符合 vnode 规范 用数组来组织数据，有序 尽量使用引用关系，不要冗余数据结构示例 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } 数据关系流转 这张图取自学员郭二蛋 一个核心： B端、C端和管理后台都共用一个数据库。 创建作品：初始化一个JSON数据 发布作品：给后端发请求，对JSON数据修改一个标记 保存作品：给后端发请求，保存JSON数据 C端浏览作品： 获取JSON数据，使用SSR渲染页面 屏蔽作品： 给后端发请求，修改一个标记，C端来判断是否显示扩展性保证 扩展组件 扩展编辑器功能，如锁定、隐藏 扩展页面信息，如增加多语言 扩展其他功能，如大数据计算研发提效 脚手架：创建、发布 组件平台： 减少编写重复代码的时间，对业务组件进行抽象，积累业务组件运维保障 线上服务和运维服务 安全 监控和报警 服务扩展性：基于云服务，可以随时扩展机器配置 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/02-第二周笔记和作业.html":{"url":"pages/點滴心宇/02-第二周笔记和作业.html","title":"第二周笔记和作业","keywords":"","body":"Yargs 配置 #!/usr/bin/env node const dedent = require('dedent') const yargs = require('yargs/yargs'); const pkg = require('../package.json'); const { hideBin } = require('yargs/helpers'); const cli = yargs(); const argv = process.argv.slice(2); const context = { winbridgeVersion: pkg.version } cli .usage('Usage: imooc-test [command] ') .demandCommand(1, \"A command is required. Pass --help to see all available commands and options.\") .strict() .recommendCommands() .alias(\"h\", \"help\") .alias(\"v\", \"version\") .wrap(cli.terminalWidth()) .epilogue(dedent`命令行到这里就结束了`) .options({ debug: { type: 'boolean', describe: 'Bootstrap debug mode', alias: 'd' } }) .option('registry', { type: 'string', describe: 'Define global registry', alias: 'r' }) .group(['debug'], 'Dev Options') .group(['registry'], 'Extra Options') .command('init [name]', 'Do init a project', (yargs) => { yargs.option('name', { type: 'string', describe: 'Name of a project', alias: 'n' }); }, (argv) => { console.log(argv) }) .command({ command: \"list\", aliases: [\"ls\", \"la\", \"ll\"], describe: \"List local packages\", builder: (yargs) => {}, handler: (argv) => { console.log(argv); } }) .fail((err, msg) => console.log(err, msg)) .parse(argv, context); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/03-第三周笔记和作业.html":{"url":"pages/點滴心宇/03-第三周笔记和作业.html","title":"第三周笔记和作业","keywords":"","body":"大厂做项目的流程 大厂的git操作规范 脚手架需求分析 痛点分析 痛点分析: 创建项目/组件时，存在大量重复代码拷贝：快速复用已有沉淀 协同开发时，由于git操作不规范，导致分支混乱，操作耗时：制定标准的git操作规范并集成到脚手架 发布上线时，容易出现各种错误：制定标准的上线流程和规范并集成到脚手架 需求分析 通用的研发脚手架 通用的项目/组件创建能力 模板支持定制 模板支持快速接入，极地的接入成本 通用个的项目/组件发布能力 发布过程自动完成标准的git操作 发布成功后自动删除开发分支并创建tag 发布后自动完成云构建、OSS上传、CDN上传、域名绑定 发布过程支持测试/正式两种模式 winbridge-cli 脚手架架构设计图 核心模块 脚手架 脚手架核心框架 初始化体系 标准git操作体系 发布体系 服务 OPEN API WebSocket 支撑体系 本地缓存 模板库 数据体系 代码仓库 资源体系 远程缓存体系 脚手架拆包策略 拆包结果 核心流程: core 命令: commands 初始化 发布 清除缓存 模型层: models Command 命令 Project 项目 Component 组件 Npm 模块 Git 仓库 支撑模块: utils Git 操作 云构建 工具方法 API 请求 Git API 拆分原则 根据模块的功能拆分: 核心模块: core 命令模块: commands 模型模块: models 工具模块: utils core模块技术方案 命令执行流程 准备阶段 checkPkgVersion 检查当前脚手架的版本号 function checkPkgVersion() { log.info('cli-version', require('package.json').version) } checkNodeVersion 检查Node版本号 function checkNodeVersion() { const semver = require('semver'); // 第一步， 获取当前Node版本号 const currentVersion = process.version; // 第二步， 比对最低版本号 const lowertVersion = '12.0.0'; if(!semver.gte(currentVersion, lowertVersion)) { throw new Error(colors.red(`winbridge-cli 需要安装 v${lowertVersion} 以上版本的 Node.js`)); } } checkRoot 检查root账户 function checkRoot() { const rootCheck = require('root-check'); rootCheck(); } checkUserHome 检查用户主目录 function checkUserHome() { const userHome = require('userHome); if(!userHome || !pathExists(userHome)) { throw new Error(colors.red('当前登录用户主目录不存在！')); } } checkInputArgs 检查命令行参数 // 检查命令行参数 let args; function checkInputArgs() { const minimist = require('minimist'); args = minimist(process.argv.slice(2)); checkArgs(); } // 检查参数 function checkArgs() { if(args.debug) { process.env.LOG_LEVEL = 'verbose'; } else { process.env.LOG_LEVEL = 'info'; } log.level = process.env.LOG_LEVEL; } checkEnv 检查环境变量 // 检查环境变量 const path = require('path'); const userHome = require('user-home'); const pathExits = require('path-exists'); function checkEnv() { const dotenv = require('dotenv'); const dotenvPath = path.resolve(userHome, '.env'); // C:/Users/86130/.env if(pathExists(dotenvPath)) { // 当这个文件存在的时候会生成一个config，不存在就生成一个默认的config dotenv.config({ path: dotenvPath }); // 将.env文件中的内容取出加载到process.env中 } createDefaultConfig(); log.verbose('环境变量', process.env.CLI_HOME); } // 创建默认环境变量配置文件 function createDefaultConfig() { const cliConfig = { home: userHome }; if (process.env.CLI_HOME) { cliConfig['cliHome'] = path.join(userHome, process.env.CLI_HOME); } else { cliConfig['cliHome'] = path.join(userHome, constant.DEFAULT_CLI_HOME); } process.env.CLI_HOME = cliConfig.cliHome; } checkGlobalUpdate 检查是否需要全局更新 async function checkGlobalUpdate() { // 1.获取当前版本号和模块名 const currentVersion = pkg.version; const npmName = pkg.name; // const npmName = '@imooc-cli/core'; // 2.调用npm API, 获取所有版本号 http://registry.npmjs.org/@winbridge-cli/core // 3.提取所有版本号，比对哪些版本号是大于当前版本号 // 4.获取最新的版本号,提示更新 const { getNpmSemverVersion } = require('@winbridge-cli/get-npm-info'); const lastVersions = await getNpmSemverVersion(currentVersion, npmName); if(lastVersions && semver.gt(lastVersions, currentVersion)) { log.warn('更新提示', colors.yellow(`请手动更新 ${npmName} 当前版本: ${currentVersion} 最新版本: ${lastVersions} 更新命令: npm install -g ${npmName}`)) } } *** @winbridge-cli/get-npm-info *** 'use strict'; const axios = require('axios'); const urlJoin = require('url-join'); const semver = require('semver'); // 1 async function getNpmSemverVersion(baseVersion, npmName, registry) { const versions = await getNpmVersions(npmName, registry); const newVersions = getNpmSemverVersions(baseVersion, versions); if(newVersions && newVersions.length > 0) return newVersions[0]; return null; } // 2 async function getNpmVersions(npmName, registry) { const data = await getNpmInfo(npmName, registry); if(data) { return Object.keys(data.versions); } else { return []; } } // 3 function getNpmInfo(npmName, registry) { if(!npmName) { return null; } const registryUrl = registry || getDefaultRegistry(); const npmInfoUrl = urlJoin(registryUrl, npmName); return axios.get(npmInfoUrl) .then(res => { if(res.status === 200) { return res.data; } return null; }).catch(err => { return Promise.reject(err); }) } // 4 function getDefaultRegistry(isOriginal = false) { return isOriginal ? 'http://registry.npmjs.org' : 'http://registry.npm.taobao.org'; } // 5 function getNpmSemverVersions(baseVersion, versions) { return versions .filter(versions => semver.satisfies(versions, `^${baseVersion}`)) .sort((a, b) => semver.gt(b, a)); } 命令注册 命令执行 涉及技术点 核心库 import-local commander #!/usr/bin/env node const { Command } = require('commander'); const pkg = require('../package.json'); // 第一种使用方法: 获取commande的单例 // const { program } = commander; // 第二种使用方法: 手动实例化一个commander实例 const program = new Command(); // 注册参数 program .name(Object.keys(pkg.bin)[0]) // 包名 .usage(' [options]') // 使用建议 .version(pkg.version) // 获取版本号 .option('-d, --debug', '是否开启调试模式', false) // 配置参数 .option('-e, --envName ', '获取环境变量名称', '.imooc-test') // 获取环境变量 // console.log(program.envName); // 获取输入的环境变量参数 // program.outputHelp(); // 输出帮助信息 // console.log(program.opts()); // 输出所有注册的参数 { version: '1.0.3', debug: false, envName: '123' } // command 注册的是当前脚手架下的命令且返回值是command对象而不是program对象 const clone = program.command('clone [destination]'); // 注册命令名称 clone .description('clone a repository into a newly created directory') .option('-f, --force', '是否强制克隆') .action((source, destination, cmdObj) => { console.log(source, destination, cmdObj.force); }); // 注册clone命令的回调 // addCommand 注册的是当前脚手架下的子命令 const service = new Command('service'); service .command('start [port]') .description('start service at some port') .action((prot) => { console.log('do service start', prot) }); service .command('stop [port]') .description('stop service') .action((prot) => { console.log('stop service') }); program.addCommand(service); program .command('install [name]', 'install one or more package', { // 这条命令执行的是个脚本文件相当于在当前目录下执行node node_module@winbridge-cli/core/bin executableFile: 'node_modules/@winbridge-cli/core/bin', // 设置可执行文件路径 // isDefault: true, // 执行imooc-test的时候默认执行这条命令 // hidden: true // 隐藏imooc-test -h 中command的隐藏 }) .alias('i'); // 命令注册的自动匹配 // program // .arguments(' [options]') // .description('test command', { // cmd: 'command to run', // options: 'options for command' // }) // .action((cmd, options) => { // console.log(cmd, options) // }) // 高级定制1: 自定义help信息 program.helpInformation() 获取帮助信息 // console.log(program.helpInformation()); // 方法一 // program.helpInformation = function() { return '' } // 定制 imooc-test --help 返回的帮助信息 // 方法二 // program.on('--help', function() { // 监听 命令行输入的 --help 参数, 并返回信息 // console.log('your help information'); // }) // 高级定制2: 实现 dubug 模式 program.on('option:debug', function() { if(program.debug) { process.env.LOG_LEVEL = 'verbose'; } console.log(process.env.LOG_LEVEL); }) // 高级定制3: 对未知命令监听 program.on('command:*', function(obj) { console.error('未知的命令:' + obj[0]); const availableCommands = program.commands.map(cmd => cmd.name()); console.log('可用命令: '+ availableCommands.join(', ')); }); program .parse(process.argv); // 参数解析 工具库 npmlog (命令行打印) fs-extra () semver (版本比对) colors (命令行输出自定义颜色字体) user-home (获取文件主目录) dotenv (将.env文件内的配置加载到process.env中) root-check (检查是否为root用户) 脚手架执行准备过程实现知识点 require支持加载资源的类型 .js => module.exports/exports .json => JSON.parse .node => process.dloper any => .js (如果任意文件类型内包含的是js代码,那么同样可以解析) 新模块的创建及引用 lerna create 如果需要修改新模块lib目录下的.js文件名, 则需要在新模块package.json文件中修改main的入口 在需要引用新模块的模块中, 修改package.json的dependencies(如：\"@winbridge-cli/log\": \"file:../../utils/log\") 重新执行npm link 这样就可以通过require引入新模块 npmlog可调用的方法 默认 log.level 为'info'，所以小于2000等级的方法都不会被调用 log.addLevel('silly', -Infinity, { inverse: true }, 'sill') log.addLevel('verbose', 1000, { fg: 'blue', bg: 'black' }, 'verb') log.addLevel('info', 2000, { fg: 'green' }) log.addLevel('timing', 2500, { fg: 'green', bg: 'black' }) log.addLevel('http', 3000, { fg: 'green', bg: 'black' }) log.addLevel('notice', 3500, { fg: 'blue', bg: 'black' }) log.addLevel('warn', 4000, { fg: 'black', bg: 'yellow' }, 'WARN') log.addLevel('error', 5000, { fg: 'red', bg: 'black' }, 'ERR!') log.addLevel('silent', Infinity) Node项目如何支持ES Module 方案一: webpack + bable-loader 安装模块 npm i -D babel-loader @babel/core @babel/preset-env npm i -D @babel/plugin-transform-runtime npm i -D @babel/runtime-corejs3 创建webpack.config.js const path = require('path'); module.exports = { entry: './bin/core.js', output: { path: path.join(__dirname, '/dist'), filename: 'core.js' }, mode: 'development', target: 'node', // 默认是 web 环境 // 以上四步完成后就可以支持es module // 还想要支持低版本的node, 就需要配置babel-loader转义 module: { rules: [ { test: /\\.js$/, exclude: /node_modules/, use: { loader: 'babel-loader', options: { presets: ['@babel/preset-env'], plugins: [ [ '@babel/plugin-transform-runtime', { corejs: 3, regenerator: true, useESModules: true, helpers: true } ] ] } } } ] } } 方案二: Node原生支持ES Module 这种方案的实现,所有文件必须以.mjs结尾。文件内必须以ES Module的方式导出或引用 创建index.mjs文件 node版本小于14 node --experimental-modules index.mjs node版本大于14 node index.mjs Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/04-第四周笔记和作业.html":{"url":"pages/點滴心宇/04-第四周笔记和作业.html","title":"第四周笔记和作业","keywords":"","body":"之后会补充这一周的笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/05-第五周笔记和作业.html":{"url":"pages/點滴心宇/05-第五周笔记和作业.html","title":"第五周笔记和作业","keywords":"","body":"inquirer用法 const inquirer = require('inquirer'); inquirer .prompt([ { type: 'input', name: 'youName', message: 'your name', validate: function(v) { return typeof v === 'string'; }, transformer: function(v) { return v + `(input your name)`; }, filter: function(v) { return `name[${v}]` } }, { type: 'number', name: 'youNumber', message: 'your number' }, { type: 'password', name: 'password', message: 'your password' }, { type: 'confirm', name: 'yourConfirm', message: 'your confirm', default: false }, { type: 'confirm', name: 'yourConfirm', message: 'your confirm' }, { type: 'list', name: 'yourChoice', message: 'your choice list', default: 0, choices: [ { value: 1, name: 'sam' }, { value: 2, name: 'shuangyue' }, { value: 3, name: 'zhangxuan' } ] }, { type: 'rawlist', name: 'yourChoice', message: 'your choice list', default: 0, choices: [ { value: 1, name: 'sam' }, { value: 2, name: 'shuangyue' }, { value: 3, name: 'zhangxuan' } ] }, { type: 'expand', name: 'expand', message: 'your expand', default: 'red', choices: [ { key: 'R', value: 'red' }, { key: 'G', value: 'green' }, { key: 'B', value: 'blue' } ] }, { type: 'checkbox', name: 'checkbox', message: 'your checkbox', default: 0, choices: [ { value: 1, name: 'sam' }, { value: 2, name: 'shuangyue' }, { value: 3, name: 'zhangxuan' } ] }, { type: 'editor', name: 'editor', message: 'your editor' }, ]) .then(answers => { console.log(answers) }) .catch(error => { if(error.isTtyError) { // Prompt couldn't be rendered in the current environment } else { // Something else when wrong } }); windows修改域名映射关系 找到C:\\Windows\\System32\\drivers\\etc目录 打开hosts文件修改映射关系 127.0.0.1 www.why.com 浏览器输入www.why.com:7001/project/template 手写readline核心实现 function stepread(cb) { function onKeypress(s) { output.write(s); line += s; switch (s) { case '\\r': input.pause(); cb(line); break; } } const input = process.stdin; const output = process.stdout; let line = ''; emitKeypressEvents(input); input.on('keypress', onKeypress); input.setRawMode(true); input.resume(); } function emitKeypressEvents(input) { function onData(chunk) { g.next(chunk.toString()); } const g = emitKeys(input); g.next(); input.on('data', onData); } function* emitKeys(input) { while (true) { let ch = yield; input.emit('keypress', ch); } } stepread(function (answer) { console.log('answer:' + answer); }); ansi-escape ANSI escape sequences are a standard for in-band signaling to control the cursor location, color, and other options on video text terminals and terminal emulators. console.log(`\\x1B[93m\\x1B[4m%s\\x1B[0m`, 'your name'); rxjs RxJS是ReactiveX编程理念的JavaScript版本。ReactiveX来自微软，它是一种针对异步数据流的编程。简单来说，它将一切数据，包括HTTP请求，DOM事件或者普通数据等包装成流的形式，然后用强大丰富的操作符对流进行处理，使你能以同步编程的方式处理异步数据，并组合不同的操作符来轻松优雅的实现你所需要的功能。 类似Promise const { range } = require('rxjs'); const { map, filter } = require('rxjs/operators'); const pipe = range(1, 200).pipe( filter(x => x % 2 === 1), map(x => x + x), filter(x => x % 3 === 0), filter(x => x % 6 === 0), filter(x => x % 9 === 0) ) pipe.subscribe(x => console.log(x)); 手写命令行交互列表 const EventEmitter = require('events'); const MuteStream = require('mute-stream'); const readline = require('readline'); const {fromEvent} = require('rxjs'); var cliCursor = require('cli-cursor'); const ansiEscapes = require('ansi-escapes'); const option = { type: 'list', name: 'userList', message: '请选择姓名', choices: [ { value: 'sam', name: 'sam'}, { value: 'sy', name: 'shuangyue'}, { value: 'zx', name: 'zhangxuan'} ] } class List extends EventEmitter { constructor(list) { super(); this.type = list.type; this.name = list.name; this.message = list.message; this.choices = list.choices; this.input = process.stdin; const ms = new MuteStream(); ms.pipe(process.stdout); this.output = ms; this.rl = readline.createInterface({ input: this.input, output: this.output }) this.selected = 0; this.height = 0; this.keypress = fromEvent(this.rl.input, 'keypress').forEach(this.onkeypress); this.haveSelected = false; } onkeypress= (keys) => { const key = keys[1]; switch (key.name) { case 'down': if (this.selected === this.choices.length - 1) { this.selected = 0; } else { this.selected++; } this.render(); break; case 'up': if (this.selected === 0) { this.selected = this.choices.length - 1; } else { this.selected--; } this.render(); break; case 'return': this.haveSelected = true; this.render(); this.close(); // 派发给程序开发者的 this.emit('exit', this.choices[this.selected]); break; default: break; } } render() { this.output.unmute(); this.clean(); this.output.write(this.getContent()); this.output.mute(); } getContent() { if (!this.haveSelected) { let content = '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[0m\\x1B[2m(Use arrow keys)\\x1B[22m\\n'; this.choices.forEach((choice, index) => { if (index === this.selected) { if (index === this.choices.length - 1) { content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } else { content += '\\x1B[36m> ' + choice.name + '\\x1B[39m\\n'; } } else { if (index === this.choices.length - 1) { // 最后一行 不要加\\n content += ' ' + choice.name + '\\n'; } else { // 不是最后一行，添加\\n content += ' ' + choice.name + '\\n'; } } }) // 空行 询问标题占两行 this.height = this.choices.length + 2; return content; } else { const name = this.choices[this.selected].name; return '\\x1B[32m?\\x1B[39m \\x1B[1m' + this.message + '\\x1B[22m\\x1B[0m \\x1B[36m' + name + '\\x1B[39m\\x1B[0m \\n'; } } clean() { const emptyLines = ansiEscapes.eraseLines(this.height); this.output.write(emptyLines); } close() { this.output.unmute(); this.rl.output.end(); this.rl.pause(); this.rl.close(); } } function prompt(option) { return new Promise((resolve, reject) => { try { const list = new List(option); list.render(); list.on('exit', s => resolve(s)); } catch(e) { reject(e); } }) } prompt(option).then((result) => { console.log(result); } ); Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/點滴心宇/06-第六周笔记和作业.html":{"url":"pages/點滴心宇/06-第六周笔记和作业.html","title":"第六周笔记和作业","keywords":"","body":"require的使用场景 require的最终执行结果是在例如.js文件源码外层套一个自执行函数，这个函数的入参就有module, exports, dirname, filename, require等。自执行函数的返回结果为exports或modules.exports的值。 加载模块类型: 加载内置模块: require('fs') 加载node_modules模块: require('ejs') 加载本地模块: require('./utils') 支持文件类型: 加载.js文件 加载.mjs文件 加载.json文件 加载.node文件 加载其他类型文件 require源码阅读过程中的一些思考 CommonJs 加载主模块的流程 加载流程和require基本一致, 主要区别就是 isMain 为 true, parent 为 null require 如何加载内置模块? 通过 loadNativeModule(filename, request, experimentalModules) 方法在内置模块的map集合中查找。找到就直接返回 mod.exports require 如何加载node_modules模块 require('ejs') 和 require('./ejs/index.js) 加载的方法基本类似，只不过 require('ejs') 会先通过Module._resolveFileName解析node_modules中文件的真是路径 require 为什么会将非js/json/node 文件视为js文件加载? 非 js/json/node 文件会被添加.js文件后缀，最后通过Module._extensions[.js]执行加载流程 require 连续加载同一个模块时，是如何进行缓存的? 第一次加载的时候通过 Module._cache[filename] = module 将文件缓存下来，第二次加载的时候如果在缓存中找到这个模块，就直接返回 module.exports Module对象 id：源码文件路径，如：/Users/sam/Desktop/vue-test/imooc-test/bin/ejs/index.js path：源码文件对应的文件夹，通过 path.dirname(id) 生成 exports：模块输出的内容，默认为 {} parent：父模块信息 filename：源码文件路径 loaded：是否已经加载完毕 children：子模块对象集合 paths：模块查询范围 Module核心API Module._resolveFileName ： 返回文件的真实路径 Module._nodeModulePaths ：返回请求文件可能存在的所有路径 Module._resolveLookUpPath : 将上一步返回的路径再拼装环境变量中的路径 Module._findPath : 返回文件真实路径 Module.prototype._compile ：将.js文件外层包装一个自执行函数，并注入require、modules、exports、dirname、 filename等参数,返回执行结果。 Module.prototype.load : 解析文件后缀名，执行对应方法 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🎮滔/":{"url":"pages/🎮滔/","title":"🎮滔","keywords":"","body":"滔 - &#x1F393; 学习分享 &#x1F393; &#x1F91D; 多多指教 &#x1F91D; 第一周：01-需求分析及架构设计 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🎮滔/01-需求分析及架构设计.html":{"url":"pages/🎮滔/01-需求分析及架构设计.html","title":"需求分析及架构设计","keywords":"","body":"整体架构设计 v1.0 1. 需求 需求文档 2. 模块设计 项目主要分为三个大端： 编辑器端 H5作品展示端 管理端 除H5端外，均采用前后端分离模式进行开发。此外，为提H5作品展示端的渲染性能，采用服务端渲染。 模块受众： 编辑器端：设计师及其他用户 H5端：作品受众、普通用户 管理端：网站管理人员 模块职责简述： 编辑器端制作发布作品、保存模板，并能查看作品的浏览、分享等数据，管理账户作品及模板等 H5端用于显示成品作品，使用服务端渲染提高性能与用户体验，收集浏览及分享数据，发送到统计服务端 管理端管理作品，紧急下架，编辑器端用户管理，查看网站所有数据（用户数、浏览量、作品数量等） 其他重要部分： 所有数据共用一个数据库 开发一个属于该项目的脚手架，提高开发效率 自研自定义事件统计服务，让项目闭环使日后有方向地让业务增长 开发一个属于本项目的组件库，提高开发效率，为了创作作品后的效果和H5端显示的效果一致，编辑器端及H5作品展示端都使用该组件库 示意图： 3. 数据结构 数据应使用vnode结构 组件内容使用 数组-对象 结构（有序，引用） [ { id: 1, name: \"title\", ... }, { id: 2, name: \"detail\", ... } ] vux store数据结构 { work: { title: \"\", setting: { // 预留页面设置 }, props: { // body配置 }, components: [ { id: 1, name: \"title\", tag: \"text\", attrs: { // 属性 }, content: \"标签里的内容\", children: [ // 子元素 ], }, { id: 2, name: \"detail\", ... }, ... ], activeComponentsId: \"1\", // 当前选中组件 } } 通过计算属性计算出当前选中的组件，vux getter： { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 4. 数据扭转 简述： 项目共用一个数据库 编辑器端及管理端前后端分离 作品发布默认作品状态正常（state: 1），下架作品状态设为 0 （state: 0） 创建作品时，初始化一个默认的作品vnode数据 { work: { title: \"\", setting: { }, props: { }, components: [], activeComponentsId: \"\", } } 5. 扩展 扩展组件 锁定、隐藏组件 页面配置 6. 开发提效 组件平台 脚手架 7. 运维保障 显示服务 运维服务 项目安全 监控及报警 流量大时扩展 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🐏羊羽/":{"url":"pages/🐏羊羽/","title":"🐏羊羽","keywords":"","body":"学习分享 技术方案设计文档 课程相关学习资料 GitHub 的 Fork 是什么 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🐏羊羽/01-技术方案设计文档.html":{"url":"pages/🐏羊羽/01-技术方案设计文档.html","title":"技术方案设计文档","keywords":"","body":"技术方案设计文档 问题 项目是用来做什么的？ 项目是什么样的架构？ 需求背景 https://www.yuque.com/imooc-lego/zlz87z 项目描述 功能主要分为三个部分：运营管理服务、移动端用户服务、系统管理服务； 运营管理服务 给用户提供作品创建、发布、删除作品、恢复作品、统计等服务； 移动端用户服务 用来给用户展示发布的作品，收集用户的访问信息到统计服务； 系统管理服务 管理用户作品的发布，对用户的各种行为进行统计 总结 想要成为一名架构师对于项目应该有完整、闭环、全面这个三个方面的思考。完整和全面是要对项目要有全面的思考，要站在业务全局的角度上面思考问题，闭环是项目要有输入输出，最终形成一个闭环。作品管理、用户查看、采集数据、作品管理查看数据形成一个业务完闭环，系统管理、对作品的管理、数据收集、系统管理检测数据也形成一个闭环。 模块设计 系统应该分为三个主要的业务模块、一个服务收集模块、前端组件模块、脚手架模块； 业务模块应该分别完成：作品创建及作品相关的管理（作品添加、删除、修改、查看、统计）、实现作品价值的模块（使用移动端界面、可以收集用户的数据）、对平台上所有的作品进行管理的模块（屏蔽一些作品、查看作品的一些统计）。 数据采集模块按照业务需要对数据库种的数据进行统计、汇总。 前端组件模块可以被业务模块的前端调用； 脚手架模块简化项目编码、测试、发布、运维的流程 核心数据结构设计 画布的数据模块应该使用JSON来进行保存，可以使用redux、vuex之类的状态管理工具来动态实时的更新、响应数据。 { 'name': '画布名称'， // 画布的名称、创建时间、修改者等画布的属性数据 // .... 'content': [ // 画布中的内容 { // 标签名称、文案、唯一的key、样式 }, // 各种画布中的组件 // ... ], 'selected': 'key', // 被选中的key，用来决定浮层谁被选中 } 拓展性保证 前端组件的可拓展性 后端接口的可拓展性 研发提效 组件化开发 脚手架开发 运维保障 拥有具备运维技能的专业工程师 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🐟红鲤驴与绿驴鱼/":{"url":"pages/🐟红鲤驴与绿驴鱼/","title":"🐟红鲤驴与绿驴鱼","keywords":"","body":"红鲤驴与绿驴鱼 - 学习分享 第一周笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/🐟红鲤驴与绿驴鱼/01-作业-架构方案设计.html":{"url":"pages/🐟红鲤驴与绿驴鱼/01-作业-架构方案设计.html","title":"作业 架构方案设计","keywords":"","body":"整体架构设计方案 v1.0 需求 需求地址 范围 整体设计，架构设计，没有细节 编辑b端(前后分离)、项目服务端(中台)、管理端(前后分离)、作品展示c端(服务端渲染) 模块设计 模块的拆分和关系图，结果模块的关键功能，职责等特殊的模块重点说明 组件库，独立第三方，同时用于编辑器和 H5 自研统计服务，为何自研 作品的数据结构 vuex store 的结构，解释数据流转关系图 { // 作品 work: { title: '作品标题', setting: { /* 一些可能的配置项，用不到就先预留 */ }, props: { /* 页面 body 的一些设置，如背景色 */ }, components: [ // components 要用数组，有序结构 // 单个 node 要符合常见的 vnode 格式 { id: 'xxx', // 每个组件都有 id ，不重复 name: '文本1', tag: 'text', attrs: { fontSize: '20px' }, children: [ '文本1' // 文本内容，有时候放在 children ，有时候放在 attrs 或者 props ，没有标准，看实际情况来确定 ] }, { id: 'yyy', name: '图片1', tag: 'image', attrs: { src: 'xxx.png', width: '100px' }, children: null }, ] }, // 画布当前选中的组件 activeComponentId: 'xxx' } vuex getter 选择当前选中的图层 { layers() => { store.work.components.map(c => { return { id: c.id, name: c.name } }) } } 扩展性保证 扩展组件，数据结构层面扩展编辑器的功能，例如：组件隐藏、锁定扩展页面的配置（讨论，集思广益） 开发提效 脚手架 创建：可以开发快速创建项目原型的脚手架，来省去配置项目初始化的时间。 脚手架 发布：。。。 组件平台 运维保障 线上服务和运维服务安全监控和报警服务扩展性：流量大 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🎓风情炀/":{"url":"pages/👨‍🎓风情炀/","title":"👨‍🎓风情炀","keywords":"","body":"&#x1F468;‍&#x1F393;风情炀 - 作业 先入坑打卡，后面补充 目录 01-weak01学习笔记 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🎓风情炀/01-weak01学习笔记.html":{"url":"pages/👨‍🎓风情炀/01-weak01学习笔记.html","title":"Weak01学习笔记","keywords":"","body":"慕课乐高架构方案设计文档 有空再补充 需求背景 范围 模块设计 数据结构 扩展性保证 研发提效 运维保障 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫Sam老师/01-前端未来趋势分析.html":{"url":"pages/👨‍🏫Sam老师/01-前端未来趋势分析.html","title":"前端未来趋势分析","keywords":"","body":"前端未来趋势分析 前端未来趋势是一个非常大的命题，它错综复杂，涉猎广泛，今天我试图从前端工程师的视角来分析行业未来的发展趋势，这与我们每个前端工程师都息息相关。 趋势一：融合 基本判断：前端与其他领域结合更加紧密，前端领域分工将更加精细 在技术融合的趋势下，前端将不断与其他领域进行融合，开发出各种令人惊叹的应用： 前端+算法：算法将大大提升前端效能，大家可以参考imgcook，这是一个由淘宝团队推出的根据设计稿自动生成前端代码的工具，相信在不远的未来根据设计稿直接生成业务代码不是梦！ 前端+后端：在Node.js+express/koa2/egg.js等一系列后端框架的驱动下，前端和后端结合越来越紧密，从最早的前后端分离，到Serverless、GraphGL，在可预见的未来，前端工程师将包揽所有业务逻辑，并且通过Serverless技术快速生产API，独立完成整个业务系统的研发、发布和运维，所以一手流利的服务端代码能力是必备技能。 前端+架构：前端架构师是未来发展的主流趋势，每个具有一定规模的前端团队都需要合格的前端架构师，前端架构师将完成团队基础架构和工具链设计和开发，并为团队或公司设计和规划业务架构，为公司创造海量业务价值。 趋势二：中台 基本判断：前端中台系统将迅速崛起和壮大 前端工程化的快速普及催生了前端中台的快速发展，一线互联网大厂前端中台发展速度极快，不管是面向营销的h5搭建系统，还是Native动态定制，又或是复杂的中后台可视化搭建平台，可谓百花齐放、应有尽有，前端中台已然成为前端发展的重要方向之一，未来将有大量前端工程师专门从事中台开发，中台开发的核心是前端架构师，他需要负责复杂的中台系统架构、研发效能监控和提升，这是一个极具挑战的工作，但大势所趋，中台的时代已经到来。 趋势三：跨端 基本判断：跨端技术的迅速发展催生新型研发模式 曾几何时，App和Web是完全不同的两个领域，但h5、小程序的火爆，加上javascript日趋成熟，各种跨端技术如雨后春笋，从构建时到运行时，跨端技术正大踏步地前行，面对跨端技术，前端工程师必须拥抱。而跨端技术的背后是高水准前端架构师的精巧构思，掌握跨端技术，合理选择技术栈，是前端工程师的必修课。 总结 要跟紧时代，与时俱进，那么就一定要保持开放的思维，不断吸收新的知识，不断迭代旧的思想，不断拓宽能力边界。前端的发展势头汹涌而又壮阔，每一名前端工程师都有可能成为弄潮儿，这是前端的黄金时代，也是我们每一名前端工程师的黄金时代。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫Sam老师/02-为什么要学习前端架构.html":{"url":"pages/👨‍🏫Sam老师/02-为什么要学习前端架构.html","title":"为什么要学习前端架构","keywords":"","body":"为什么要学习前端架构 无处不在 首先架构无处不在，架构的本质是解决业务快速增长中的技术复杂度问题，所以只要你所在的组织业务存在增长，就需要用架构的思想去解决一些问题，比如： 项目代码量越来越大，如何提升项目的构建性能？ 如何抽取项目公共模块进行快速复用？ 如果你没有架构思维和相对应的技术能力，面对这些问题的时候是无从下手的。所以学习架构的第一目标是为了应对和解决项目开发中碰到的各类问题，通常需要架构层面去解决的问题包括： 工程问题 复杂业务 复用问题 至关重要 其次架构至关重要，2009年node诞生以后，前端工程化得到飞速发展，前端项目量级和研发效率直线上升，目前前端领域已出现进一步细分的趋势，主要有三个方向： 前端业务开发 前端全栈开发（偏服务端node） 前端基础架构开发（偏工具） 而前端架构师可能是这三个岗位中的任意一个： 偏业务的前端架构师主要解决复杂业务问题 偏服务端的前端架构师主要解决服务架构和运维体系问题 偏基础架构的前端架构师主要解决研发体系和效能的问题 所以不管你当前处于哪个岗位、哪个阶段，前端架构对你而言都有价值、都非常重要。 直通高薪 最后架构直通高薪，通过调研不难发现很多中级以上的前端开发岗位中已经对架构能力有需求，包括组件库研发、性能优化、工具开发等等，而高级前端职位中，前端架构能力几乎是绝对和必须的，随着前端技术的飞速发展，薪资基于已经与服务端旗鼓相当，所以掌握架构能力毫无疑问是快速进阶高薪的法宝。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫Sam老师/03-脚手架入门.html":{"url":"pages/👨‍🏫Sam老师/03-脚手架入门.html","title":"脚手架入门","keywords":"","body":"脚手架入门 脚手架简介 脚手架本质是一个操作系统的客户端，它通过命令行执行，比如： vue create vue-test-app 上面这条命令由 3 个部分组成： 主命令: vue command: create command 的 param: vue-test-app 它表示创建一个 vue 项目，项目的名称为 vue-test-app，以上是最一个较为简单的脚手架命令，但实际场景往往更加复杂，比如： 当前目录已经有文件了，我们需要覆盖当前目录下的文件，强制进行安装 vue 项目，此时我们就可以输入： vue create vue-test-app --force 这里的 --force 叫做 option，用来辅助脚手架确认在特定场景下用户的选择（可以理解为配置）。还有一种场景： 通过 vue create 创建项目时，会自动执行 npm install 帮用户安装依赖，如果我们希望使用淘宝源来安装，可以输入命令： vue create vue-test-app --force -r https://registry.npm.taobao.org 这里的 -r 也叫做 option，它与 --force 不同的是它使用 -，并且使用简写，这里的 -r 也可以替换成 --registry，有的同学可能要问，为什么老师知道这个命令，其实我们输入下面的命令就可以看到 vue create 支持的所有 options： vue create --help -r https://registry.npm.taobao.org 后面的 https://registry.npm.taobao.org 成为 option 的 param，其实 --force 可以理解为：--force true，简写为：--force 或 -f 脚手架的执行原理 脚手架的执行原理如下： 在终端输入 vue create vue-test-app 终端解析出 vue 命令 终端在环境变量中找到 vue 命令 终端根据 vue 命令链接到实际文件 vue.js 终端利用 node 执行 vue.js vue.js 解析 command / options vue.js 执行 command 执行完毕，退出执行 从应用的角度看如何开发一个脚手架 这里以 vue-cli 为例 开发 npm 项目，该项目中应包含一个 bin/vue.js 文件，并将这个项目发布到 npm 将 npm 项目安装到 node 的 lib/node_modules 在 node 的 bin 目录下配置 vue 软链接指向 lib/node_modules/@vue/cli/bin/vue.js 这样我们在执行 vue 命令的时候就可以找到 vue.js 进行执行 还有很多疑问需要解答 为什么全局安装 @vue/cli 后会添加的命令为 vue？ npm install -g @vue/cli 全局安装 @vue/cli 时发生了什么？ 为什么 vue 指向一个 js 文件，我们却可以直接通过 vue 命令直接去执行它？ Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫双越老师/":{"url":"pages/👨‍🏫双越老师/","title":"👨‍🏫双越老师","keywords":"","body":"双越老师 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫双越老师/01-我如何理解Web前端架构师的角色和职责.html":{"url":"pages/👨‍🏫双越老师/01-我如何理解Web前端架构师的角色和职责.html","title":"我如何理解Web前端架构师的角色和职责","keywords":"","body":"我如何理解 Web 前端架构师 的角色和职责 架构师的核心指责：保证业务增长 —— 《聊聊架构》 架构师这个角色，在行业中和各个公司中，都没有明确的定位。甚至，有些公司都没有架构师这个职位。 但是，你的身边总是需要这样的角色。他们技术能力好，有深度、有广度，熟悉公司产品的业务需求，熟悉公司各个部门和负责人，遇到问题能拆分任务，计划和跟踪 …… 即，他们不仅仅是做开发，还有其他更加重要的工作。有了这个角色，你就有了依靠，你就会感觉很踏实，很放心。这种角色，就是架构师。 特别是近些年技术栈细分严重，大家各司其职，更加需要这样的角色去整合团队的工作。保证多人协作顺利有效的进行，否则就乱套了。 无论是大公司还是创业公司，只要有了研发团队，不是单兵作战或者小作坊（通讯靠吼），就需要这样的角色。 下面，我根据我的工作经验和理解，说一下 Web 前端架构师这个角色的一些职责。虽然没法给出一个文字定义，但可以从不同的方面来表达一下。 负责人 首先，作为 Web 前端架构师，你就是前端及相关技术方面的负责人。只要跟你相关的，你都要负责，赢了给你奖励，输了你也要得到惩罚。 所以，架构师就是“将”。所谓“千军易得一将难求”，招聘人员很简单，但招聘一个架构师是很难的。一般情况，都是从本公司培养。 三国时 “蜀国无大将廖化作先锋”，蜀国此时也不是没人了，只是没将了。 这个项目或者系统，交给一个架构师（再配一些开发人员）老板就会安心，一切都在掌控之中，不会发生惊喜，但也不会有意外。 高效 有节奏 稳定 安全 高效：发挥每个人的最大价值，不让人闲着。但这并不代表要加班，要 996 —— 反而加班 996 就是因为没有高效而导致的。 有节奏：当下有安排，未来有计划，做完一个任务立马安排下一个任务，持续进行中。 稳定：完善的研发流程（单元测试，接口测试），完善的监控报警体系，才能保证稳定，课程中都会讲到。 安全：不会被轻易攻击，如最常见的 DDOS XSS SQL 注入等。 PS：如何做到以上几点，以及如何让老板放心，这都是有方法论的。具体哪些方法，大家可以参考我们的课程。 深入理解业务 脱离业务的架构，就是耍流氓，架构是基于业务的 —— 要再说：不想做业务，想做架构。 架构师的核心职责是保证业务增长，翻译过来就是：如何用技术只支撑现在和未来的业务。所以，你得非常清楚的了解公司产品的业务，未来规划和目标。 所以，建议各位同学，如果现在的工作机会还不错，一定要积极参与到公司产品业务的讨论中，不要只是一门心思的写代码。 技术是为业务服务的，光靠技术，没有持久的竞争力。 个人技术能力 架构师也要写代码，且要有广度和深度。 广度：做技术方案时，要有多种选择，且能熟悉前后端的关系。 深度：要能解决一些别人搞不定的问题，不一定是亲自解决，可以指导从某个方向入手查询。 总结 无论公司有没有架构师的职位，无论你现在是否还在一线开发。 只要是作为开发人员，你都要学会以架构师的思维去思考问题，这样才能保证持久竞争力。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫双越老师/02-Web 前端架构师课 vs 普通实战课.html":{"url":"pages/👨‍🏫双越老师/02-Web 前端架构师课 vs 普通实战课.html","title":"Web 前端架构师课 Vs 普通实战课","keywords":"","body":"Web 前端架构师课 vs 普通实战课 我们要做一门不一样的课，要能体现出“架构师”这个主题，要和普通的实战课做出明显的区别。 在课程制作过程中，我们三位讲师经常自我提问：我们这门课和实战课有何区别呢？—— 我们必须要说服自己，否则就自欺欺人了。 最终，我们总结出了以下几点，证明我们这门课和实战课确实完全不一样。 真正的线上项目，不是 demo 有一次和七月老师打电话，我们聊了一个多小时，我们都承认，现在的实战课，都是 demo ，远远达不到生产环境的级别要求。 线上项目和 demo 虽然功能看似一样，但实则完全不同。随随便便就能说出很多方面： demo 没有线上环境，如域名，服务器，数据库等 demo 没有上线、回滚的流程 demo 没有运维监控和报警，这些在实际工作中都是重点 demo 没有统计、分享等正式的业务场景 demo 不用考虑安全、攻击、敏感内容过滤等 demo 不用担心万一半夜出 bug 该怎么办？ …… 还有很多，一次性说不完，都在课程里 【注意】并不是说课程中讲到了上述知识点，它就是线上项目了。光讲知识点没用，必须得把项目正式上线，用正式的域名、证书、服务器等跑起来，而且要流程闭环才可以。 业务负责度高，流程闭环 脱离了业务谈架构，就是耍流氓。做架构师课，就得用复杂度高的业务，否则体现不出来。 h5 编辑器，是前端领域中一个非常复杂的业务，这跟“社区” “电商”这种实战课项目，不是一个难度级别。 全栈，流程闭环：创建 h5 ，发布，分享，还有统计，这是闭环的，实战课里是没有这样做的。实战课讲的，都是完整流程的一个环节而已。 不讲业务代码，不讲基础知识 业务代码会演示，但不会在一行一行带着写了。基础知识也不再详细讲，如 vue3 ts 语法等。 实战课基本都 20h 左右，而且要详细演示代码，根本做不出来这么复杂的项目。 我看过其他的号称架构师的课，虽然时间很长，但是大部分都用在讲基础知识上，做的项目也远远达不到这个复杂度。 有些课程会讲框架源码、造轮子，这看似很牛 x ，但其实这些仅仅是架构师的一个能力“个人技术深度”，对于架构师整体的技能，这是很小的一个方面，算不了什么。 更关注设计、研发流程、运维 这些远比开发重要，特别是运维。 如何开发，大部分业务代码，大家学实战课就好了，这些没多少难度。 而设计、流程和运维，这些是实战课不常见的，也是架构师最需要了解的内容 —— 否则，大家都会开发，凭什么你是架构师呢？ 总结 实战课能带你从 0 到 1 入门，接下来 1 - 2 就需要架构师课来帮助你突破瓶颈。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫双越老师/03-动真格的了！为做一门课程花费 1.5万 购买云服务.html":{"url":"pages/👨‍🏫双越老师/03-动真格的了！为做一门课程花费 1.5万 购买云服务.html","title":"动真格的了！为做一门课程花费 1.5万 购买云服务","keywords":"","body":"动真格的了！为做一门课程花费 1.5万 购买云服务.md 最贵的 iPhone12 Pro Max 要 11899 元，我没有买。今年新出的 iPad mini 据说玩游戏体验很好，要 2921 元，我也没有买。 我把这些钱都花在了正在制作的课程上，1.5w 购买了各种云服务：两台云服务器、各种数据库、OSS、CDN、域名、https 证书、Web 防火墙、短信服务、内容审核服务…… 哦，还花钱请了以为 UI 设计师来设计页面。 你可能会疑问：就讲一门课而已吗，还需要花钱？现在网上各种“Vue 做电商”，就写代码就好了，一分钱都不用花。 对此，我也有一个疑问：现在有哪一门课程，讲师会亲自花钱来投资？（平台的广告、运营费用不能算哈～） 你可以说我：不按套路出牌，可能会踩坑～ 但我还是要坚持自己的风格和态度：输出优质内容，独立思考，做不一样的事情，做真正有价值的课程！ PS：课程链接这里不写了，有意向的可以私聊我。本文我们只谈钱～ 为何要花钱呢？ 书归正传。不开玩笑、不卖关子了，正式解释一下这个问题。 其实答案很简单 —— 我要做一个真实的线上项目，而不是 demo 。这是项目地址 https://www.imooc-lego.com/ ，有兴趣的可以体验，这里不过多介绍。【但是】要解释一下，虽然看着就是一个网站，但它背后有 12 个代码仓库，所以复杂度还是很高的。 我要把一个真实项目的从 0 到 1 的过程，搬到课程里。包括需求、架构设计、技术方案、研发流程、CI/CD ，发布上线/回滚，运维，监控和报警。 我在这最近忙碌的半年多里，我都傻傻分不清自己到底是一名讲师，还是一名外包。 讲课为何非得用真实项目，不都是 demo 吗？ 这个问题要分开说。 入门适合用 demo 零基础入门的课程，为了让学员能更快的学习到语言、环境、框架和工具的使用，就在本地运行，用 demo 非常合适。 此时如果强行用线上环境，第一会扰乱学员的学习重点，第二是难度太大学员不易接受。 近几年是国内在线编程教育的高速发展阶段，但也是刚刚起步不久（回想 5 年之前，哪儿有那么多付费课程）。 正好近几年又是程序员行业发展壮大的关键时间，新人纷纷涌入。 所以，这段时间出现了大量的入门课程，各个平台，各个讲师，各个框架，各种“vue + 电商”的课程铺天盖地。以至于学员写简历，都写这些项目，面试官们应该有点印象。 在此，也就解答了本文一开始的问题“就讲一门课而已吗，还需要花钱？” —— 这是和我们大环境相关的。 进阶不再适合 demo 为啥进阶还要学习课程？而且花钱更多？—— 你上班的时候看看你身边的人，就知道了。 一块和你挤地铁的有多少人？一块和你堵车的有多少人？你上午占个厕所的坑位有多不容易？—— 就是因为人多，竞争激烈，不进则退呀！ 我家人经常劝告我：别那么累了，慢着点干，你现在这么忙每月挣 xxx 钱，你歇着干每月挣个 70% 不也挺好的吗？ 我说：这和你想的不一样，我现在这么干，每月挣 xxx ，我要稍微一懈怠，别说 70% 60% ，我一分钱都挣不到。因为大家都是一个集体，不再是自己种那一亩三分地了，你歇着干就会影响其他人，你就会被淘汰。大家想一下是不是这个道理？ 好了，把话题拉回来。 所以，进阶的课程，我觉得不应该再用 demo ，要把标准提高，要能输出更有竞争力的内容。demo 和线上项目，哪个更有竞争力，这一点大家都知道。 真实项目有啥特别的，看功能和我做的 demo 一样啊？ 举个例子。demo 就是实验室里的概念车，线上项目就是大街上跑的量产车。看着功能都一样，但本质有很大区别的。 加入要把这个概念车卖给你，你敢买吗？万一坏了零部件怎么办，有地方换吗？4S 店是否也有 10w 公里的质保？它作出碰撞测试吗，安全吗？它内饰做过甲醛等气体测试吗？它排量标准符合国家规定吗？它有出厂检测和 3C 证书吗？…… 同理，对于我们软件项目，demo 和线上项目也是有本质区别的。 demo 没有线上环境，如域名，服务器，数据库等 demo 没有上线、回滚的流程 demo 没有运维监控和报警，这些在实际工作中都是重点 demo 没有统计、分享等正式的业务场景 demo 不用考虑安全、攻击、敏感内容过滤等 demo 不用担心万一半夜出 bug 该怎么办？ …… 还有很多，一次性说不完，都在课程里 上述这些，对于一个网站或者任何一个软件产品，是不是都非常重要？相信大家都懂得。但是这些都要借助线上项目，来讲出来，否则就是空口白说。 为啥很少见其他课程也用线上项目？ 成本高啊，而且收益如何都还不知道呢～ 首先得像我，花钱买各种服务。而且现在服务器都不便宜，看看阿里云服务器，一年动辄 3k+ 。有人说可以买华为云、腾讯云 —— 是便宜，但做课程吗，还是要考虑找个大众的，这样容易理解。 再者，多了上线、回滚、运维、监控和报警、网络安全预防，这么多内容，自己的时间成本会增加很多。 但是，我还是做了这样的尝试，不试试怎么知道不行呢。 这些钱给报销吗？ &#x1F62D;很明显，不给报销。 发票都还没开呢，哪位需要的话，可以私信我。 现在各个平台，都没有给讲师报销服务器花费的机制。因为现在我没发现哪门课是在做一个正式的线上项目。PS：也或许有，只是我没发现。 即便是所谓的线上项目，最常见的形式，也就是平台给免费提供一个测试机，然后给一个二级甚至三级域名，能给学员演示一下。 毫不客气的说，全都是 demo 。 未来编程教育方向，之我见 第三次科技革命还在进行中，所有涉及的行业，都会越来越多元化、精细化。编程教育也是一样，各个技术栈，入门教程、进阶教程都会越来越精细。 而且，随着行业的发展，初期红利期结束，淘汰掉很多凑热闹的。课程会越来越贴合实际应用，越来越以产出实际价值为主，无论是入门的还是进阶的，学的就是工作中要用的到，有价值的东西。 基于以上两点，我还是坚信自己走的方向是正确的。 如果反馈不如预期的好，那可能是时机未到。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫张轩老师/":{"url":"pages/👨‍🏫张轩老师/","title":"👨‍🏫张轩老师","keywords":"","body":"张轩老师 - 课程分享 请直接看下级目录 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫张轩老师/01-在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？.html":{"url":"pages/👨‍🏫张轩老师/01-在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？.html","title":"在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？","keywords":"","body":"在学习了一门技术的基础知识后，怎样持续提升这门技术达到更高水平？ 因为很多同学学习技术陷于一个瓶颈，尤其是很多在中小型公司的同学，发现工作中每天都深陷重复业务的泥潭，不由的产生一种恐慌的心情，觉得自己在浪费时间没有提高。很多同学都向我要求的复杂前端项目和高级课程。 什么是复杂项目 那么什么是复杂项目呢？一个陈年老项目有10w+代码 ？ 一个增删改查项目有 50 个分开的页面算复杂吗？虽然它的代码量够大，但是它更不称不上复杂。反而会让人很有挫败感和无力感。 我认为想真正尝试复杂的项目的必须要是一个现代的前端开发项目，涉猎多个不同领域： 交互的复杂性 - 可能包含元素的复杂交互 移动，拖动大小，拖动排序 等。 数据状态的复杂性 - 嵌套数据和多种类型的组件相对应，同时两者要互相同步。 多项目之间的依赖性 - 有可能要抽取出一系列的公共库供多个项目使用。 测试 - 保证代码质量，减少 Bug 的必备技能。 打包 - 对应不同类型的功能的项目（web 应用或者是 library），怎样生成多种类型对应的可复用的代码格式。 性能优化 - 大型项目性能是要点，让加载速度提升就等于省的是真金白银。 第三方库使用和二次开发 - 怎样快速找到和使用已经有的技术方案解决特定问题。 持续集成 - 让代码能够自动化的测试，部署，是去大厂的敲门砖。也是大型项目必备的内容。 ... 只有满足了这样需求的项目才能把前端开发的方方面面都包含在其中，才能掌握其中的复杂项目的奥义。 写出高质量符合大厂要求的代码 除了项目，代码质量也是一块需要考量的因素。 很多人都知道大厂镀金是个对于每个人的职业都是重要的一环，但是很多在中小心公司的同学都不熟悉大厂开发的流程和要求，有的人甚至经常是公司的“全干工程师”，从前端到后端都是一个人说了算。大厂由于工程师众多，必须采取一套标准化自动高效的流程来管理代码和部署以及测试。 简单可以描述为： 从 git flow 分支的创建，管理已经合并 到 lint 工具保证代码的格式正确 到 单元测试 尽可能保证代码的质量 到 代码提交 尽可能详尽可追溯的提交信息， 到 PR review，再次保证代码的质量 到最后 CI/CD ，保证持续迭代和部署等等。 这些概念如果你觉得陌生，一两句话很难说的清楚，那么就需要通过一个大型多人协作的项目去真是的实践这些过程。软件开发肯定会伴随着 Bug 的出现，关键是怎样使用科学和优良的实践来尽可能的发现和规避风险。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "},"pages/👨‍🏫张轩老师/02-Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程.html":{"url":"pages/👨‍🏫张轩老师/02-Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程.html","title":"Typescript 是不是前端开发必备的技能？一个 Ts 黑到 Ts 粉的心路历程","keywords":"","body":"Typescript 是不是前端开发必备的技能？一个 ts 黑到 ts 粉的心路历程 2020年 Typescript 各种火，就像我之前说的在 jsconf 2019上，typescript 也变成了一个主要议题，占到了很大比重，来自微软的讲师韩骏还拿出了这么一张图，来表达自己的观点， 我觉得这个不是夸大其词，而实实在在的是一个趋势，来自 2018 年 stateofjs 权威调查显示，80% 的程序员都希望在新的项目中学习和使用 typescript。大家可以明显看到从 2016 年到 2018年 这个趋势的绝大变化，这就说明 typescript 越来越流行了。 在我的编程生涯到现在，我一直在使用动态类型语言（Dynamically Typed Language），聊起这个概念，那就要说说 动态类型语言 和他的对立面 - 静态类型语言（Statically Typed Language）。我刚写 typescript 的时候，对类型声明嗤之以鼻，添加一大堆类型浪费我宝贵的时间，还时不时遇到根本看不懂的类型错误，感觉很抓狂，我当时想对 ts 编译器说：“老子能管好自己写的类型，不用你报错”，实在搞不定的类型错误发生的时候，我就会使用 any 大法，完全是一副应付差事的用法。 我当时维护的项目是一个十几万行的大型项目，当时还在推另外一个小型项目，我极力反对 typescript，据理力争，“你是想让我赶快完成任务？还是浪费时间在写 any 上面？这玩意儿根本就不能给你避免 Bug，都是扯犊子。” 后来我花更多的时间在老项目上面，我每天写 any 发 PR 被老外一阵喷。这时候可不能给自己丢脸啊，我开始认真对待起 type 来。 我发现当我在代码中打入了越来越多类型的时候，效率居然变得很高（自动补全），遇到各种傻瓜错误（比如说 typo，我的单词记不住，经常打错 ）的几率也越来越少，在后来两年的工作生涯中，我在很多比较大型的项目中都使用了它，并且越来越感受到它的优势。虽然精通 ts 真的有一定的难度，但是其实你也不必那么精通，能差不多看懂，帮你提高效率就好了，我总结几点编码过程中，实实在在帮助到我的点。 1 程序更容易理解 当我们进行编码的时时候，我们非常关心这几个问题，一个函数或者方法接受什么样什么类型的参数，它的返回值和类型是什么？有什么其他外部数据需要被引进？为了解决这几个问题，我们一般都要详细的查阅文档，搞清楚所有的来龙去脉，因为动态语言的约束我们很难完成这几项任务，我们需要在代码真正运行的时候来调试才能知道答案，比如说加断点或者 console.log 去查看输出，甚至还需要社交过程，我有好几次都是直接跑去问同事或者blame原来写这段代码的人，发个邮件问这些代码究竟是干嘛的，扯皮扯个好几天。有了 typescript，这几个问题都迎刃而解，代码就是全部的注释，通过代码你不再需要去进行猜测，而是直接就可以知道这些问题的答案。看下面上古神器 jQuery 的提示，这参数，返回值的说明，还有文档地址和代码示例，这水平比你百度出来不知几百年前的csdn博客文章不知道高到哪里去了。 2 效率更高 有了 IDE 和 compiler 的帮助，你可以非常方便的在不同的代码块和定义之间进行跳转，同时进行代码补全，还有丰富的接口提示，可以是事半功倍。我就享受这个感觉，能让 IDE 炫酷的提示是每个程序员的梦想。可以疯狂的体验下“老夫就是 jQuery 一把梭”的快感。 3 更少的错误 在编译期间能够发现大部分的错误，这远远要比运行时候再出现这些错误要好的多。在 typescript 之前，我不知道有多少次出现变量名称打错这种错误，传入错误类型的参数，还有就是还有就是排在前端错误第一名：最经典的“Cannot read property 'xxx' on undefined：无法在 undefined 上读取 xxx 属性，通常出现在 a.b.c 的情况。” 4 非常好的包容性 typescript 是 javascript 超集，即使我们把 js 文件直接命名为 ts 文件，也不会有任何的问题，兼容第三方库，即使这些库没有用 ts 编写，也可以给他们编写单独的类型文件进行读取。大部分非常流行的库都用 typescript 实现或者提供写好的类型文件供开发者使用，比如 React，vue，angular，和 ant design 等等，使用起来可谓是无缝衔接。 5 提高自身水平 ts 内部有非常多的内置对象，这些对象我们平时在使用的时候都没有过多的在意，比如 NodeList 和 HTMLCollection 的异同，Event 对象，衍生出来的 MouseEvent，TouchEvent 都有啥区别和属性 等等。。。 把这些接口都一一搞清楚以后，对BOM 和 DOM 的机制了解可以达到另外一个境界，潜移默化的就变成了 API 使用高手。当别人看到没用过的属性的时候，你可以骄傲的化身 API 达人。 结论： 假如你工作在一个大中型项目上面，typescript 对你应该是利大于弊。可以学！还能从另外一个方便了解静态类型语言是怎么玩的，看到别人的 Java 代码居然能有看得懂的部分了。 当然要学会根据自己的需求和项目的规模合理选用工具，如果你的应用就是一个简单的展示页面，加几个 UI 状态改变，就没有必要使用。 Copyright © imooc-lego (2020 - present) all right reserved，powered by GitbookFile Modify: 2021-06-27 08:04:42 "}}